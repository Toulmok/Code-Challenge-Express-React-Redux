{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { glsl as e } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as t } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as o } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { VertexAttribute as a } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { addResolutionUniform as r } from \"../views/3d/webgl-engine/shaders/SMAAPassParameters.js\";\nconst l = {\n  threshold: .05,\n  localConstrastAdaption: 2\n};\nfunction s() {\n  const s = new t(),\n    {\n      attributes: d,\n      varyings: x,\n      vertex: i,\n      fragment: c\n    } = s;\n  return d.add(a.POSITION, \"vec2\"), r(i), x.add(\"uv\", \"vec2\"), x.add(\"offsets[3]\", \"vec4\"), i.code.add(e`void main() {\nuv = position * 0.5 + vec2(0.5);\ngl_Position = vec4(position, 0, 1);\noffsets[0] = uv.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\noffsets[1] = uv.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\noffsets[2] = uv.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}`), c.uniforms.add(new o(\"colorTexture\", e => e.colorTexture)), c.code.add(e`\n    float absMax3(vec3 v) {\n      vec3 t = abs(v);\n      return max(max(t.r, t.g), t.b);\n    }\n\n    void main() {\n      // Calculate color deltas:\n      vec4 delta;\n      vec3 C = texture2D(colorTexture, uv).rgb;\n\n      vec3 Cleft = texture2D(colorTexture, offsets[0].xy).rgb;\n      delta.x = absMax3(C - Cleft);\n\n      vec3 Ctop = texture2D(colorTexture, offsets[0].zw).rgb;\n      delta.y = absMax3(C - Ctop);\n\n      vec2 edges = step(vec2(${e.float(l.threshold)}), delta.xy);\n\n      // discard if there is no edge:\n      if (dot(edges, vec2(1.0)) == 0.0) {\n        discard;\n      }\n\n      // Calculate right and bottom deltas:\n      vec3 Cright = texture2D(colorTexture, offsets[1].xy).rgb;\n      delta.z = absMax3(C - Cright);\n\n      vec3 Cbottom  = texture2D(colorTexture, offsets[1].zw).rgb;\n      delta.w = absMax3(C - Cbottom);\n\n      // Calculate the maximum delta in the direct neighborhood:\n      float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n\n      // Calculate left-left and top-top deltas:\n      vec3 Cleftleft  = texture2D(colorTexture, offsets[2].xy).rgb;\n      delta.z = absMax3(C - Cleftleft);\n\n      vec3 Ctoptop = texture2D(colorTexture, offsets[2].zw).rgb;\n      delta.w = absMax3(C - Ctoptop);\n\n      // Calculate the final maximum delta:\n      maxDelta = max(max(maxDelta, delta.z), delta.w);\n\n      // Local contrast adaptation in action:\n      edges.xy *= step(maxDelta, float(${e.float(l.localConstrastAdaption)}) * delta.xy);\n\n      gl_FragColor = vec4(edges, 0.0, 0.0);\n    }\n  `), s;\n}\nconst d = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: s\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { d as E, s as b };","map":{"version":3,"names":["glsl","e","ShaderBuilder","t","Texture2DPassUniform","o","VertexAttribute","a","addResolutionUniform","r","l","threshold","localConstrastAdaption","s","attributes","d","varyings","x","vertex","i","fragment","c","add","POSITION","code","uniforms","colorTexture","float","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","E","b"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/EdgeDetect.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{glsl as e}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as t}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as o}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as a}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{addResolutionUniform as r}from\"../views/3d/webgl-engine/shaders/SMAAPassParameters.js\";const l={threshold:.05,localConstrastAdaption:2};function s(){const s=new t,{attributes:d,varyings:x,vertex:i,fragment:c}=s;return d.add(a.POSITION,\"vec2\"),r(i),x.add(\"uv\",\"vec2\"),x.add(\"offsets[3]\",\"vec4\"),i.code.add(e`void main() {\nuv = position * 0.5 + vec2(0.5);\ngl_Position = vec4(position, 0, 1);\noffsets[0] = uv.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\noffsets[1] = uv.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\noffsets[2] = uv.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}`),c.uniforms.add(new o(\"colorTexture\",(e=>e.colorTexture))),c.code.add(e`\n    float absMax3(vec3 v) {\n      vec3 t = abs(v);\n      return max(max(t.r, t.g), t.b);\n    }\n\n    void main() {\n      // Calculate color deltas:\n      vec4 delta;\n      vec3 C = texture2D(colorTexture, uv).rgb;\n\n      vec3 Cleft = texture2D(colorTexture, offsets[0].xy).rgb;\n      delta.x = absMax3(C - Cleft);\n\n      vec3 Ctop = texture2D(colorTexture, offsets[0].zw).rgb;\n      delta.y = absMax3(C - Ctop);\n\n      vec2 edges = step(vec2(${e.float(l.threshold)}), delta.xy);\n\n      // discard if there is no edge:\n      if (dot(edges, vec2(1.0)) == 0.0) {\n        discard;\n      }\n\n      // Calculate right and bottom deltas:\n      vec3 Cright = texture2D(colorTexture, offsets[1].xy).rgb;\n      delta.z = absMax3(C - Cright);\n\n      vec3 Cbottom  = texture2D(colorTexture, offsets[1].zw).rgb;\n      delta.w = absMax3(C - Cbottom);\n\n      // Calculate the maximum delta in the direct neighborhood:\n      float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n\n      // Calculate left-left and top-top deltas:\n      vec3 Cleftleft  = texture2D(colorTexture, offsets[2].xy).rgb;\n      delta.z = absMax3(C - Cleftleft);\n\n      vec3 Ctoptop = texture2D(colorTexture, offsets[2].zw).rgb;\n      delta.w = absMax3(C - Ctoptop);\n\n      // Calculate the final maximum delta:\n      maxDelta = max(max(maxDelta, delta.z), delta.w);\n\n      // Local contrast adaptation in action:\n      edges.xy *= step(maxDelta, float(${e.float(l.localConstrastAdaption)}) * delta.xy);\n\n      gl_FragColor = vec4(edges, 0.0, 0.0);\n    }\n  `),s}const d=Object.freeze(Object.defineProperty({__proto__:null,build:s},Symbol.toStringTag,{value:\"Module\"}));export{d as E,s as b};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,IAAI,IAAIC,CAAC,QAAK,2DAA2D;AAAC,SAAOC,aAAa,IAAIC,CAAC,QAAK,8DAA8D;AAAC,SAAOC,oBAAoB,IAAIC,CAAC,QAAK,qEAAqE;AAAC,SAAOC,eAAe,IAAIC,CAAC,QAAK,iDAAiD;AAAC,SAAOC,oBAAoB,IAAIC,CAAC,QAAK,wDAAwD;AAAC,MAAMC,CAAC,GAAC;EAACC,SAAS,EAAC,GAAG;EAACC,sBAAsB,EAAC;AAAC,CAAC;AAAC,SAASC,CAACA,CAAA,EAAE;EAAC,MAAMA,CAAC,GAAC,IAAIV,CAAC;IAAC;MAACW,UAAU,EAACC,CAAC;MAACC,QAAQ,EAACC,CAAC;MAACC,MAAM,EAACC,CAAC;MAACC,QAAQ,EAACC;IAAC,CAAC,GAACR,CAAC;EAAC,OAAOE,CAAC,CAACO,GAAG,CAACf,CAAC,CAACgB,QAAQ,EAAC,MAAM,CAAC,EAACd,CAAC,CAACU,CAAC,CAAC,EAACF,CAAC,CAACK,GAAG,CAAC,IAAI,EAAC,MAAM,CAAC,EAACL,CAAC,CAACK,GAAG,CAAC,YAAY,EAAC,MAAM,CAAC,EAACH,CAAC,CAACK,IAAI,CAACF,GAAG,CAACrB,CAAE;AACrqB;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACoB,CAAC,CAACI,QAAQ,CAACH,GAAG,CAAC,IAAIjB,CAAC,CAAC,cAAc,EAAEJ,CAAC,IAAEA,CAAC,CAACyB,YAAY,CAAE,CAAC,EAACL,CAAC,CAACG,IAAI,CAACF,GAAG,CAACrB,CAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+BA,CAAC,CAAC0B,KAAK,CAACjB,CAAC,CAACC,SAAS,CAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyCV,CAAC,CAAC0B,KAAK,CAACjB,CAAC,CAACE,sBAAsB,CAAE;AAC3E;AACA;AACA;AACA,GAAG,CAAC,EAACC,CAAC;AAAA;AAAC,MAAME,CAAC,GAACa,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;EAACC,SAAS,EAAC,IAAI;EAACC,KAAK,EAACnB;AAAC,CAAC,EAACoB,MAAM,CAACC,WAAW,EAAC;EAACC,KAAK,EAAC;AAAQ,CAAC,CAAC,CAAC;AAAC,SAAOpB,CAAC,IAAIqB,CAAC,EAACvB,CAAC,IAAIwB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}