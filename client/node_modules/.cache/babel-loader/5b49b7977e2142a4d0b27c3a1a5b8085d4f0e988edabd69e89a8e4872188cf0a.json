{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { addNearFar as e, addLinearDepth as o } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { ShaderOutput as t } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as r } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as a } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { VertexColor as i } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { OutputDepth as n } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as l } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { multipassTerrainTest as c } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { symbolAlphaCutoff as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as s } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as p, addCameraPosition as g } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float4PassUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as m } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as f } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { TransparencyPassType as h } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nimport { VertexAttribute as w } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { Style as b } from \"../views/3d/webgl-engine/materials/PatternStyle.js\";\nconst y = .70710678118,\n  S = y,\n  j = .08715574274;\nfunction x(x) {\n  const T = new f(),\n    C = x.hasMultipassTerrain && (x.output === t.Color || x.output === t.Alpha);\n  x.draped || T.extensions.add(\"GL_OES_standard_derivatives\");\n  const {\n    vertex: R,\n    fragment: $\n  } = T;\n  p(R, x), T.include(a, x), T.include(i, x), x.draped ? R.uniforms.add(new v(\"worldToScreenRatio\", (e, o) => 1 / o.screenToPCSRatio)) : T.attributes.add(w.BOUNDINGRECT, \"mat3\"), T.attributes.add(w.POSITION, \"vec3\"), T.attributes.add(w.UVMAPSPACE, \"vec4\"), T.varyings.add(\"vpos\", \"vec3\"), T.varyings.add(\"vuv\", \"vec2\"), C && T.varyings.add(\"depth\", \"float\");\n  const D = x.style === b.ForwardDiagonal || x.style === b.BackwardDiagonal || x.style === b.DiagonalCross;\n  D && R.code.add(m`\n      const mat2 rotate45 = mat2(${m.float(y)}, ${m.float(-S)},\n                                 ${m.float(S)}, ${m.float(y)});\n    `), x.draped || (g(R, x), R.uniforms.add(new v(\"worldToScreenPerDistanceRatio\", (e, o) => 1 / o.camera.perScreenPixelRatio)), R.code.add(m`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`), R.code.add(m`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`), R.code.add(m`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${m.float(j)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)), R.code.add(m`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${D ? \" * rotate45\" : \"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${D ? \" * rotate45\" : \"\"};\n\n      ${x.draped ? \"\" : m`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${m.float(x.patternSpacing)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `);\n  const V = x.output === t.Depth;\n  return V && (T.include(n, x), e(T), o(T)), R.code.add(m`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${C ? \"depth = (view * vec4(vpos, 1.0)).z;\" : \"\"}\n      forwardNormalizedVertexColor();\n      gl_Position = ${V ? m`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);` : m`transformPosition(proj, view, vpos);`}\n    }\n  `), T.include(r, x), $.include(s), x.draped && $.uniforms.add(new v(\"texelSize\", (e, o) => 1 / o.camera.pixelRatio)), x.output === t.Highlight && T.include(l, x), C && T.include(c, x), x.output !== t.Highlight && ($.code.add(m`\n      const float lineWidth = ${m.float(x.lineWidth)};\n      const float spacing = ${m.float(x.patternSpacing)};\n      const float spacingINV = ${m.float(1 / x.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `), x.draped || $.code.add(m`const int maxSamples = 5;\nfloat sample(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)), $.uniforms.add(new u(\"uColor\", e => e.color)), $.code.add(m`\n    void main() {\n      discardBySlice(vpos);\n      ${C ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n      vec4 color = ${x.hasVertexColors ? \"vColor * uColor;\" : \"uColor;\"}\n      color = highlightSlice(color, vpos);\n\n      ${x.output !== t.Highlight ? m`color.a *= ${P(x)};` : \"\"}\n\n      ${x.output === t.ObjectAndLayerIdColor ? m`color.a = 1.0;` : \"\"}\n\n      if (color.a < ${m.float(d)}) {\n        discard;\n      }\n\n      ${x.output === t.Alpha ? m`gl_FragColor = vec4(color.a);` : \"\"}\n\n      ${x.output === t.Color ? m`gl_FragColor = color; ${x.transparencyPassType === h.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}` : \"\"}\n      ${x.output === t.Highlight ? m`outputHighlight();` : \"\"}\n      ${x.output === t.Depth ? m`outputDepth(linearDepth);` : \"\"};\n    }\n  `), T;\n}\nfunction P(e) {\n  function o(o) {\n    return e.draped ? m`coverage(vuv.${o}, texelSize)` : m`sample(vuv.${o})`;\n  }\n  switch (e.style) {\n    case b.ForwardDiagonal:\n    case b.Horizontal:\n      return o(\"y\");\n    case b.BackwardDiagonal:\n    case b.Vertical:\n      return o(\"x\");\n    case b.DiagonalCross:\n    case b.Cross:\n      return m`\n        1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})\n      `;\n    default:\n      return \"0.0\";\n  }\n}\nconst T = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: x\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { T as P, x as b };","map":{"version":3,"names":["addNearFar","e","addLinearDepth","o","ShaderOutput","t","SliceDraw","r","Transform","a","VertexColor","i","OutputDepth","n","OutputHighlight","l","multipassTerrainTest","c","symbolAlphaCutoff","d","ColorConversion","s","addProjViewLocalOrigin","p","addCameraPosition","g","Float4PassUniform","u","FloatPassUniform","v","glsl","m","ShaderBuilder","f","TransparencyPassType","h","VertexAttribute","w","Style","b","y","S","j","x","T","C","hasMultipassTerrain","output","Color","Alpha","draped","extensions","add","vertex","R","fragment","$","include","uniforms","screenToPCSRatio","attributes","BOUNDINGRECT","POSITION","UVMAPSPACE","varyings","D","style","ForwardDiagonal","BackwardDiagonal","DiagonalCross","code","float","camera","perScreenPixelRatio","patternSpacing","V","Depth","pixelRatio","Highlight","lineWidth","color","hasVertexColors","P","ObjectAndLayerIdColor","transparencyPassType","Horizontal","Vertical","Cross","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/Pattern.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{addNearFar as e,addLinearDepth as o}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as t}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as r}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as a}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{VertexColor as i}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{OutputDepth as n}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as l}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{multipassTerrainTest as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as s}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as p,addCameraPosition as g}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float4PassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as m}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as f}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{TransparencyPassType as h}from\"../views/3d/webgl-engine/lib/TransparencyPassType.js\";import{VertexAttribute as w}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{Style as b}from\"../views/3d/webgl-engine/materials/PatternStyle.js\";const y=.70710678118,S=y,j=.08715574274;function x(x){const T=new f,C=x.hasMultipassTerrain&&(x.output===t.Color||x.output===t.Alpha);x.draped||T.extensions.add(\"GL_OES_standard_derivatives\");const{vertex:R,fragment:$}=T;p(R,x),T.include(a,x),T.include(i,x),x.draped?R.uniforms.add(new v(\"worldToScreenRatio\",((e,o)=>1/o.screenToPCSRatio))):T.attributes.add(w.BOUNDINGRECT,\"mat3\"),T.attributes.add(w.POSITION,\"vec3\"),T.attributes.add(w.UVMAPSPACE,\"vec4\"),T.varyings.add(\"vpos\",\"vec3\"),T.varyings.add(\"vuv\",\"vec2\"),C&&T.varyings.add(\"depth\",\"float\");const D=x.style===b.ForwardDiagonal||x.style===b.BackwardDiagonal||x.style===b.DiagonalCross;D&&R.code.add(m`\n      const mat2 rotate45 = mat2(${m.float(y)}, ${m.float(-S)},\n                                 ${m.float(S)}, ${m.float(y)});\n    `),x.draped||(g(R,x),R.uniforms.add(new v(\"worldToScreenPerDistanceRatio\",((e,o)=>1/o.camera.perScreenPixelRatio))),R.code.add(m`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`),R.code.add(m`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`),R.code.add(m`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${m.float(j)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)),R.code.add(m`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${D?\" * rotate45\":\"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${D?\" * rotate45\":\"\"};\n\n      ${x.draped?\"\":m`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${m.float(x.patternSpacing)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `);const V=x.output===t.Depth;return V&&(T.include(n,x),e(T),o(T)),R.code.add(m`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${C?\"depth = (view * vec4(vpos, 1.0)).z;\":\"\"}\n      forwardNormalizedVertexColor();\n      gl_Position = ${V?m`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);`:m`transformPosition(proj, view, vpos);`}\n    }\n  `),T.include(r,x),$.include(s),x.draped&&$.uniforms.add(new v(\"texelSize\",((e,o)=>1/o.camera.pixelRatio))),x.output===t.Highlight&&T.include(l,x),C&&T.include(c,x),x.output!==t.Highlight&&($.code.add(m`\n      const float lineWidth = ${m.float(x.lineWidth)};\n      const float spacing = ${m.float(x.patternSpacing)};\n      const float spacingINV = ${m.float(1/x.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `),x.draped||$.code.add(m`const int maxSamples = 5;\nfloat sample(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)),$.uniforms.add(new u(\"uColor\",(e=>e.color))),$.code.add(m`\n    void main() {\n      discardBySlice(vpos);\n      ${C?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n      vec4 color = ${x.hasVertexColors?\"vColor * uColor;\":\"uColor;\"}\n      color = highlightSlice(color, vpos);\n\n      ${x.output!==t.Highlight?m`color.a *= ${P(x)};`:\"\"}\n\n      ${x.output===t.ObjectAndLayerIdColor?m`color.a = 1.0;`:\"\"}\n\n      if (color.a < ${m.float(d)}) {\n        discard;\n      }\n\n      ${x.output===t.Alpha?m`gl_FragColor = vec4(color.a);`:\"\"}\n\n      ${x.output===t.Color?m`gl_FragColor = color; ${x.transparencyPassType===h.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}`:\"\"}\n      ${x.output===t.Highlight?m`outputHighlight();`:\"\"}\n      ${x.output===t.Depth?m`outputDepth(linearDepth);`:\"\"};\n    }\n  `),T}function P(e){function o(o){return e.draped?m`coverage(vuv.${o}, texelSize)`:m`sample(vuv.${o})`}switch(e.style){case b.ForwardDiagonal:case b.Horizontal:return o(\"y\");case b.BackwardDiagonal:case b.Vertical:return o(\"x\");case b.DiagonalCross:case b.Cross:return m`\n        1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})\n      `;default:return\"0.0\"}}const T=Object.freeze(Object.defineProperty({__proto__:null,build:x},Symbol.toStringTag,{value:\"Module\"}));export{T as P,x as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}