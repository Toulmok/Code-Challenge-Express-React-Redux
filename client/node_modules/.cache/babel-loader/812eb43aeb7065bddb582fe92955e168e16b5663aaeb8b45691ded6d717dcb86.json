{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { isSome as e } from \"../core/maybe.js\";\nimport { s as i } from \"./vec2.js\";\nimport { a as o } from \"./vec2f64.js\";\nimport { Z as r } from \"./vec4f64.js\";\nimport { SliceDraw as t } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { AlignPixel as a } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";\nimport { HUD as l } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";\nimport { multipassGeometryTest as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";\nimport { addScreenSizePerspectiveAlignment as s } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";\nimport { Float2PassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as p } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as g } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as h } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction S(o) {\n  const r = new g();\n  r.include(a), r.include(l, o), r.include(t, o), r.attributes.add(h.UV0, \"vec2\");\n  const {\n    vertex: S,\n    fragment: u\n  } = r;\n  return S.uniforms.add([new c(\"viewport\", (e, i) => i.camera.fullViewport), new f(\"lineSize\", (e, i) => Math.ceil(e.size) * i.camera.pixelRatio), new d(\"pixelToNDC\", (e, o) => i(m, 2 / o.camera.fullViewport[2], 2 / o.camera.fullViewport[3])), new f(\"borderSize\", (i, o) => e(i.borderColor) ? o.camera.pixelRatio : 0), new d(\"screenOffset\", (e, o) => i(m, e.screenOffset[0] * o.camera.pixelRatio, e.screenOffset[1] * o.camera.pixelRatio))]), r.varyings.add(\"coverageSampling\", \"vec4\"), r.varyings.add(\"lineSizes\", \"vec2\"), o.hasMultipassGeometry && r.varyings.add(\"depth\", \"float\"), o.hasScreenSizePerspective && s(S), S.code.add(p`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${o.occlusionTestEnabled ? p`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }` : \"\"}\n\n    ${o.hasScreenSizePerspective ? p`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        ` : p`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${o.hasMultipassGeometry ? \"depth = posView.z;\" : \"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${o.depthHudEnabled ? o.depthHudAlignStartEnabled ? p`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : p`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : \"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${o.hasScreenSizePerspective ? p`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        ` : p`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `), u.uniforms.add([new c(\"uColor\", e => v(e.color)), new c(\"borderColor\", e => v(e.borderColor))]), o.hasMultipassGeometry && (u.include(n, o), u.uniforms.add(new d(\"inverseViewport\", (e, i) => i.inverseViewport))), u.code.add(p`\n    void main() {\n      ${o.hasMultipassGeometry ? \"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\" : \"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = uColor.a * borderColor.a * coverage.y;\n      float colorAlpha = uColor.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${o.depthHudEnabled ? p`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      ` : p`\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `), r;\n}\nfunction v(i) {\n  return e(i) ? i : r;\n}\nconst m = o(),\n  u = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: S\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { u as L, S as b };","map":{"version":3,"names":["isSome","e","s","i","a","o","Z","r","SliceDraw","t","AlignPixel","HUD","l","multipassGeometryTest","n","addScreenSizePerspectiveAlignment","Float2PassUniform","d","Float4PassUniform","c","FloatPassUniform","f","glsl","p","ShaderBuilder","g","VertexAttribute","h","S","include","attributes","add","UV0","vertex","fragment","u","uniforms","camera","fullViewport","Math","ceil","size","pixelRatio","m","borderColor","screenOffset","varyings","hasMultipassGeometry","hasScreenSizePerspective","code","occlusionTestEnabled","depthHudEnabled","depthHudAlignStartEnabled","v","color","inverseViewport","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","L","b"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/LineCallout.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{isSome as e}from\"../core/maybe.js\";import{s as i}from\"./vec2.js\";import{a as o}from\"./vec2f64.js\";import{Z as r}from\"./vec4f64.js\";import{SliceDraw as t}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as l}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{multipassGeometryTest as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as s}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as p}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as g}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as h}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function S(o){const r=new g;r.include(a),r.include(l,o),r.include(t,o),r.attributes.add(h.UV0,\"vec2\");const{vertex:S,fragment:u}=r;return S.uniforms.add([new c(\"viewport\",((e,i)=>i.camera.fullViewport)),new f(\"lineSize\",((e,i)=>Math.ceil(e.size)*i.camera.pixelRatio)),new d(\"pixelToNDC\",((e,o)=>i(m,2/o.camera.fullViewport[2],2/o.camera.fullViewport[3]))),new f(\"borderSize\",((i,o)=>e(i.borderColor)?o.camera.pixelRatio:0)),new d(\"screenOffset\",((e,o)=>i(m,e.screenOffset[0]*o.camera.pixelRatio,e.screenOffset[1]*o.camera.pixelRatio)))]),r.varyings.add(\"coverageSampling\",\"vec4\"),r.varyings.add(\"lineSizes\",\"vec2\"),o.hasMultipassGeometry&&r.varyings.add(\"depth\",\"float\"),o.hasScreenSizePerspective&&s(S),S.code.add(p`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${o.occlusionTestEnabled?p`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }`:\"\"}\n\n    ${o.hasScreenSizePerspective?p`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        `:p`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${o.hasMultipassGeometry?\"depth = posView.z;\":\"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${o.depthHudEnabled?o.depthHudAlignStartEnabled?p`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);`:p`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);`:\"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${o.hasScreenSizePerspective?p`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        `:p`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `),u.uniforms.add([new c(\"uColor\",(e=>v(e.color))),new c(\"borderColor\",(e=>v(e.borderColor)))]),o.hasMultipassGeometry&&(u.include(n,o),u.uniforms.add(new d(\"inverseViewport\",((e,i)=>i.inverseViewport)))),u.code.add(p`\n    void main() {\n      ${o.hasMultipassGeometry?\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\":\"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = uColor.a * borderColor.a * coverage.y;\n      float colorAlpha = uColor.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${o.depthHudEnabled?p`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      `:p`\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `),r}function v(i){return e(i)?i:r}const m=o(),u=Object.freeze(Object.defineProperty({__proto__:null,build:S},Symbol.toStringTag,{value:\"Module\"}));export{u as L,S as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}