{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { lerp as t } from \"../core/mathUtils.js\";\nimport { isSome as e } from \"../core/maybe.js\";\nimport { c as a } from \"./mat3f64.js\";\nimport { s as o } from \"./vec2.js\";\nimport { a as i } from \"./vec2f64.js\";\nimport { cloudPresets as s } from \"../views/3d/environment/CloudsPresets.js\";\nimport { RayMarchingSteps as n } from \"../views/3d/environment/CloudsTechniqueConfiguration.js\";\nimport { ATLAS_SIZE as r, TILE_ROWS as l, TILE_SIZE as c, TEXTURE_SCALE as d, WEATHER_MAP_SCALE as u } from \"../views/3d/environment/NoiseTextureAtlasDimensions.js\";\nimport { ScreenSpacePass as f } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";\nimport { Float2PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { NoParameters as p, glsl as g } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix3DrawUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js\";\nimport { ShaderBuilder as y } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as w } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass S extends p {\n  constructor() {\n    super(...arguments), this.cloudRadius = 0, this.cloudSize = 0, this.detailSize = 0, this.absorption = 0, this.density = 0, this.smoothness = 0, this.cloudHeight = 0, this.coverage = 0, this.raymarchingSteps = s.default.raymarchingSteps, this.weatherTile = i();\n  }\n}\nclass x extends p {\n  constructor() {\n    super(...arguments), this.viewMatrix = a();\n  }\n}\nfunction b(a) {\n  const i = new y();\n  i.include(f, !1);\n  const s = i.fragment;\n  return s.uniforms.add([new h(\"cloudRadius\", t => t.cloudRadius), new h(\"power\", e => t(35, 120, e.absorption)), new h(\"sigmaE\", t => 1 + t.absorption), new h(\"density\", e => t(0, .3, e.density)), new h(\"cloudSize\", e => t(0, .02, Math.max(.01, 1 - e.cloudSize))), new h(\"detailSize\", e => t(0, .2, Math.max(.01, 1 - e.detailSize))), new h(\"smoothness\", e => t(0, .5, 1 - e.smoothness)), new h(\"cloudHeight\", e => t(0, 1500, e.cloudHeight)), new h(\"coverage\", t => t.coverage), new v(\"view\", t => t.viewMatrix), new w(\"cloudShapeTexture\", t => e(t.noiseTexture) ? t.noiseTexture.textureAtlas : null), new m(\"cloudVariables\", t => o(D, t.coverage, t.absorption))]), s.constants.add(\"halfCubeMapSize\", \"float\", .5 * a.cubeMapSize), s.code.add(g`\n    const int STEPS = ${a.steps === n.SIXTEEN ? g`16` : a.steps === n.HUNDRED ? g`100` : g`200`};\n    const int STEPS_LIGHT = 6;\n    const float stepL = 300.0 / float(STEPS_LIGHT);\n    const float cloudStart = 1500.0;\n\n    vec3 rayDirection(vec2 fragCoord) {\n      vec2 xy = fragCoord - halfCubeMapSize;\n      return normalize(vec3(-xy, -halfCubeMapSize));\n    }\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }`), s.code.add(g`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = ${g.float(r)};\n      const float dataWidth = ${g.float(r)};\n      const float tileRows = ${g.float(l)};\n      const vec3 atlasDimensions = vec3(${g.float(c)}, ${g.float(c)}, tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = float(${g.float(d)}) * pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture2D(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }\n\n    float getCloudMap(vec2 p){\n      // Non-power-of-two textures can't be tiled using WebGL1\n      // Get fractional part of uv to tile\n      // Shift the texture center to origin to avoid seam artifacts\n      vec2 uv = fract((${g.float(u)} * p) / ${g.float(r)} + 0.5);\n\n      return texture2D(cloudShapeTexture, uv).a;\n    }\n    `), s.code.add(g`float clouds(vec3 p) {\nfloat cloud = saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat cloudMap = getCloudMap(cloudSize * p.xy);\ncloud = mix(cloud, min(2.0 * (coverage), 1.0) * cloudMap, min(2.0 * (1.0 - coverage), 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat shape = getCloudShape(8.0 * cloudSize * p, 0.0);\ncloud = saturate(remap(cloud, smoothness * shape, 1.0, 0.0, 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat heightFraction = saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\ncloud *= saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * smoothstep(1.0, 0.25, heightFraction);\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nreturn density * saturate(remap(cloud, 0.35 * smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n}`), s.code.add(g`vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - (radius * radius);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}\nfloat HenyeyGreenstein(float g, float costh) {\nreturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}`), s.code.add(\"\\n    float multipleOctaves(float extinction, float mu, float stepL) {\\n      float attenuation = 1.0;\\n      float contribution = 1.0;\\n      float phaseAttenuation = 1.0;\\n      float luminance = 0.0;\\n\\n      for (int i = 0; i < 4; i++) {\\n        float phase = mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\\n        luminance += contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\\n        attenuation *= 0.2;\\n        contribution *= 0.6;\\n        phaseAttenuation *= 0.5;\\n      }\\n\\n      return luminance;\\n    }\"), s.code.add(g`float lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\nfloat lightRayDensity = clouds(p);\nlightRayDensity += clouds(p + sunDirection * 1.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 2.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 3.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 4.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 5.0 * stepL);\nfloat beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\nreturn mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n}`), s.code.add(g`float mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\nif (dir.z < 0.0) {\nreturn 0.0;\n}\ntotalTransmittance = 1.0;\nfloat stepS = totalDistance / float(STEPS);\nfloat cameraHeight = length(org);\nfloat mu = 0.5 + 0.5 * dot(sunDirection, dir);\nfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\nvec3 p = org + distToStart  * dir;\nfloat dist = distToStart;\nfloat shading = 0.0;\nfor (int i = 0; i < STEPS; i++) {\nfloat sampleDensity = clouds(p);\nfloat sampleSigmaE = sampleDensity * sigmaE;\nif (sampleDensity > 0.0 ) {\nfloat ambient = mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\nfloat luminance = sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\nfloat transmittance = exp(-sampleSigmaE * stepS);\nshading += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\ntotalTransmittance *= transmittance;\nif (totalTransmittance <= 0.001) {\ntotalTransmittance = 0.0;\nbreak;\n}\n}\ndist += stepS;\np = org + dir * dist;\n}\nreturn shading;\n}`), s.code.add(g`void main() {\nif (coverage ==  0.0) {\ngl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\nreturn;\n}\nvec3 rayDir = rayDirection(gl_FragCoord.xy);\nrayDir = normalize(view * rayDir);\nvec3 viewPos = vec3(0, 0, cloudRadius + 1.0);\nbool hitsPlanet = rayDir.z < 0.0;\nfloat hazeFactor = smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(dot(rayDir, vec3(0, 0, 1))));\nfloat totalTransmittance = 1.0;\nfloat shading = 0.0;\nif (hitsPlanet) {\nshading = clamp(1.0 - cloudVariables.y, 0.6, 1.0) * (1.0 - hazeFactor);\ntotalTransmittance = hazeFactor;\ngl_FragColor = vec4(shading, totalTransmittance, shading, totalTransmittance);\nreturn;\n}\nvec2 rayStartIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\nvec2 rayEndIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\nfloat distToStart = rayStartIntersect.y;\nfloat totalDistance = rayEndIntersect.y - distToStart;\nvec3 sunDirection = normalize(vec3(0, 0, 1));\nshading = 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance);\nshading = mix(clamp(1.0 - cloudVariables.y, 0.6, 1.0), shading, hazeFactor);\ntotalTransmittance = mix(0.0, totalTransmittance, hazeFactor);\ngl_FragColor = vec4(shading, totalTransmittance, shading, totalTransmittance);\n}`), i;\n}\nconst D = i(),\n  T = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    CloudsDrawParameters: x,\n    CloudsPassParameters: S,\n    build: b\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { S as C, x as a, T as b, b as c };","map":{"version":3,"names":["lerp","t","isSome","e","c","a","s","o","i","cloudPresets","RayMarchingSteps","n","ATLAS_SIZE","r","TILE_ROWS","l","TILE_SIZE","TEXTURE_SCALE","d","WEATHER_MAP_SCALE","u","ScreenSpacePass","f","Float2PassUniform","m","FloatPassUniform","h","NoParameters","p","glsl","g","Matrix3DrawUniform","v","ShaderBuilder","y","Texture2DPassUniform","w","S","constructor","arguments","cloudRadius","cloudSize","detailSize","absorption","density","smoothness","cloudHeight","coverage","raymarchingSteps","default","weatherTile","x","viewMatrix","b","include","fragment","uniforms","add","Math","max","noiseTexture","textureAtlas","D","constants","cubeMapSize","code","steps","SIXTEEN","HUNDRED","float","T","Object","freeze","defineProperty","__proto__","CloudsDrawParameters","CloudsPassParameters","build","Symbol","toStringTag","value","C"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/Clouds.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{lerp as t}from\"../core/mathUtils.js\";import{isSome as e}from\"../core/maybe.js\";import{c as a}from\"./mat3f64.js\";import{s as o}from\"./vec2.js\";import{a as i}from\"./vec2f64.js\";import{cloudPresets as s}from\"../views/3d/environment/CloudsPresets.js\";import{RayMarchingSteps as n}from\"../views/3d/environment/CloudsTechniqueConfiguration.js\";import{ATLAS_SIZE as r,TILE_ROWS as l,TILE_SIZE as c,TEXTURE_SCALE as d,WEATHER_MAP_SCALE as u}from\"../views/3d/environment/NoiseTextureAtlasDimensions.js\";import{ScreenSpacePass as f}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";import{Float2PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{FloatPassUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{NoParameters as p,glsl as g}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix3DrawUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js\";import{ShaderBuilder as y}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as w}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class S extends p{constructor(){super(...arguments),this.cloudRadius=0,this.cloudSize=0,this.detailSize=0,this.absorption=0,this.density=0,this.smoothness=0,this.cloudHeight=0,this.coverage=0,this.raymarchingSteps=s.default.raymarchingSteps,this.weatherTile=i()}}class x extends p{constructor(){super(...arguments),this.viewMatrix=a()}}function b(a){const i=new y;i.include(f,!1);const s=i.fragment;return s.uniforms.add([new h(\"cloudRadius\",(t=>t.cloudRadius)),new h(\"power\",(e=>t(35,120,e.absorption))),new h(\"sigmaE\",(t=>1+t.absorption)),new h(\"density\",(e=>t(0,.3,e.density))),new h(\"cloudSize\",(e=>t(0,.02,Math.max(.01,1-e.cloudSize)))),new h(\"detailSize\",(e=>t(0,.2,Math.max(.01,1-e.detailSize)))),new h(\"smoothness\",(e=>t(0,.5,1-e.smoothness))),new h(\"cloudHeight\",(e=>t(0,1500,e.cloudHeight))),new h(\"coverage\",(t=>t.coverage)),new v(\"view\",(t=>t.viewMatrix)),new w(\"cloudShapeTexture\",(t=>e(t.noiseTexture)?t.noiseTexture.textureAtlas:null)),new m(\"cloudVariables\",(t=>o(D,t.coverage,t.absorption)))]),s.constants.add(\"halfCubeMapSize\",\"float\",.5*a.cubeMapSize),s.code.add(g`\n    const int STEPS = ${a.steps===n.SIXTEEN?g`16`:a.steps===n.HUNDRED?g`100`:g`200`};\n    const int STEPS_LIGHT = 6;\n    const float stepL = 300.0 / float(STEPS_LIGHT);\n    const float cloudStart = 1500.0;\n\n    vec3 rayDirection(vec2 fragCoord) {\n      vec2 xy = fragCoord - halfCubeMapSize;\n      return normalize(vec3(-xy, -halfCubeMapSize));\n    }\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }`),s.code.add(g`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = ${g.float(r)};\n      const float dataWidth = ${g.float(r)};\n      const float tileRows = ${g.float(l)};\n      const vec3 atlasDimensions = vec3(${g.float(c)}, ${g.float(c)}, tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = float(${g.float(d)}) * pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture2D(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }\n\n    float getCloudMap(vec2 p){\n      // Non-power-of-two textures can't be tiled using WebGL1\n      // Get fractional part of uv to tile\n      // Shift the texture center to origin to avoid seam artifacts\n      vec2 uv = fract((${g.float(u)} * p) / ${g.float(r)} + 0.5);\n\n      return texture2D(cloudShapeTexture, uv).a;\n    }\n    `),s.code.add(g`float clouds(vec3 p) {\nfloat cloud = saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat cloudMap = getCloudMap(cloudSize * p.xy);\ncloud = mix(cloud, min(2.0 * (coverage), 1.0) * cloudMap, min(2.0 * (1.0 - coverage), 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat shape = getCloudShape(8.0 * cloudSize * p, 0.0);\ncloud = saturate(remap(cloud, smoothness * shape, 1.0, 0.0, 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat heightFraction = saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\ncloud *= saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * smoothstep(1.0, 0.25, heightFraction);\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nreturn density * saturate(remap(cloud, 0.35 * smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n}`),s.code.add(g`vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - (radius * radius);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}\nfloat HenyeyGreenstein(float g, float costh) {\nreturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}`),s.code.add(\"\\n    float multipleOctaves(float extinction, float mu, float stepL) {\\n      float attenuation = 1.0;\\n      float contribution = 1.0;\\n      float phaseAttenuation = 1.0;\\n      float luminance = 0.0;\\n\\n      for (int i = 0; i < 4; i++) {\\n        float phase = mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\\n        luminance += contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\\n        attenuation *= 0.2;\\n        contribution *= 0.6;\\n        phaseAttenuation *= 0.5;\\n      }\\n\\n      return luminance;\\n    }\"),s.code.add(g`float lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\nfloat lightRayDensity = clouds(p);\nlightRayDensity += clouds(p + sunDirection * 1.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 2.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 3.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 4.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 5.0 * stepL);\nfloat beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\nreturn mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n}`),s.code.add(g`float mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\nif (dir.z < 0.0) {\nreturn 0.0;\n}\ntotalTransmittance = 1.0;\nfloat stepS = totalDistance / float(STEPS);\nfloat cameraHeight = length(org);\nfloat mu = 0.5 + 0.5 * dot(sunDirection, dir);\nfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\nvec3 p = org + distToStart  * dir;\nfloat dist = distToStart;\nfloat shading = 0.0;\nfor (int i = 0; i < STEPS; i++) {\nfloat sampleDensity = clouds(p);\nfloat sampleSigmaE = sampleDensity * sigmaE;\nif (sampleDensity > 0.0 ) {\nfloat ambient = mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\nfloat luminance = sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\nfloat transmittance = exp(-sampleSigmaE * stepS);\nshading += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\ntotalTransmittance *= transmittance;\nif (totalTransmittance <= 0.001) {\ntotalTransmittance = 0.0;\nbreak;\n}\n}\ndist += stepS;\np = org + dir * dist;\n}\nreturn shading;\n}`),s.code.add(g`void main() {\nif (coverage ==  0.0) {\ngl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\nreturn;\n}\nvec3 rayDir = rayDirection(gl_FragCoord.xy);\nrayDir = normalize(view * rayDir);\nvec3 viewPos = vec3(0, 0, cloudRadius + 1.0);\nbool hitsPlanet = rayDir.z < 0.0;\nfloat hazeFactor = smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(dot(rayDir, vec3(0, 0, 1))));\nfloat totalTransmittance = 1.0;\nfloat shading = 0.0;\nif (hitsPlanet) {\nshading = clamp(1.0 - cloudVariables.y, 0.6, 1.0) * (1.0 - hazeFactor);\ntotalTransmittance = hazeFactor;\ngl_FragColor = vec4(shading, totalTransmittance, shading, totalTransmittance);\nreturn;\n}\nvec2 rayStartIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\nvec2 rayEndIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\nfloat distToStart = rayStartIntersect.y;\nfloat totalDistance = rayEndIntersect.y - distToStart;\nvec3 sunDirection = normalize(vec3(0, 0, 1));\nshading = 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance);\nshading = mix(clamp(1.0 - cloudVariables.y, 0.6, 1.0), shading, hazeFactor);\ntotalTransmittance = mix(0.0, totalTransmittance, hazeFactor);\ngl_FragColor = vec4(shading, totalTransmittance, shading, totalTransmittance);\n}`),i}const D=i(),T=Object.freeze(Object.defineProperty({__proto__:null,CloudsDrawParameters:x,CloudsPassParameters:S,build:b},Symbol.toStringTag,{value:\"Module\"}));export{S as C,x as a,T as b,b as c};\n"],"mappings":"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yBAAyBY,CAAC,CAACuC,KAAK,CAACjD,CAAC,CAAE,WAAUU,CAAC,CAACuC,KAAK,CAACxD,CAAC,CAAE;AACzD;AACA;AACA;AACA,KAAK,CAAC,EAACP,CAAC,CAAC2D,IAAI,CAACR,GAAG,CAAC3B,CAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACxB,CAAC,CAAC2D,IAAI,CAACR,GAAG,CAAC3B,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACxB,CAAC,CAAC2D,IAAI,CAACR,GAAG,CAAC,mkBAAmkB,CAAC,EAACnD,CAAC,CAAC2D,IAAI,CAACR,GAAG,CAAC3B,CAAE;AACjmB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACxB,CAAC,CAAC2D,IAAI,CAACR,GAAG,CAAC3B,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACxB,CAAC,CAAC2D,IAAI,CAACR,GAAG,CAAC3B,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACtB,CAAC;AAAA;AAAC,MAAMsD,CAAC,GAACtD,CAAC,EAAE;EAAC8D,CAAC,GAACC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;IAACC,SAAS,EAAC,IAAI;IAACC,oBAAoB,EAACxB,CAAC;IAACyB,oBAAoB,EAACvC,CAAC;IAACwC,KAAK,EAACxB;EAAC,CAAC,EAACyB,MAAM,CAACC,WAAW,EAAC;IAACC,KAAK,EAAC;EAAQ,CAAC,CAAC,CAAC;AAAC,SAAO3C,CAAC,IAAI4C,CAAC,EAAC9B,CAAC,IAAI9C,CAAC,EAACiE,CAAC,IAAIjB,CAAC,EAACA,CAAC,IAAIjD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}