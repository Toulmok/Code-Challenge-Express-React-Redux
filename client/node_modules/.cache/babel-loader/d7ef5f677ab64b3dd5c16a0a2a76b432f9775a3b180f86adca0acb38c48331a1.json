{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { f as e } from \"../../../../../../chunks/vec2f64.js\";\nimport { PositionAttribute as o } from \"./PositionAttribute.glsl.js\";\nimport { Float2PassUniform as i } from \"../../shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as r } from \"../../shaderModules/Float3PassUniform.js\";\nimport { Float4sPassUniform as t } from \"../../shaderModules/Float4sPassUniform.js\";\nimport { FloatsPassUniform as a } from \"../../shaderModules/FloatsPassUniform.js\";\nimport { glsl as l } from \"../../shaderModules/interfaces.js\";\nimport { VertexAttribute as v } from \"../../../lib/VertexAttribute.js\";\nimport { vvColorNumber as s, VisualVariablePassParameters as c } from \"../../../materials/VisualVariablePassParameters.js\";\nconst f = 8;\nfunction n(e, c) {\n  const n = v.FEATUREVALUE;\n  e.attributes.add(n, \"vec4\");\n  const p = e.vertex;\n  p.code.add(l`\n  bool isCapVertex() {\n    return ${n}.w == 1.0;\n  }\n  `), p.uniforms.add(new i(\"size\", e => e.size)), c.vvSize ? (p.uniforms.add(new r(\"vvSizeMinSize\", e => e.vvSizeMinSize)), p.uniforms.add(new r(\"vvSizeMaxSize\", e => e.vvSizeMaxSize)), p.uniforms.add(new r(\"vvSizeOffset\", e => e.vvSizeOffset)), p.uniforms.add(new r(\"vvSizeFactor\", e => e.vvSizeFactor)), p.code.add(l`\n    vec2 getSize() {\n      return size * clamp(vvSizeOffset + ${n}.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;\n    }\n    `)) : p.code.add(l`vec2 getSize(){\nreturn size;\n}`), c.vvOpacity ? (p.constants.add(\"vvOpacityNumber\", \"int\", f), p.uniforms.add([new a(\"vvOpacityValues\", e => e.vvOpacityValues, f), new a(\"vvOpacityOpacities\", e => e.vvOpacityOpacities, f)]), p.code.add(l`\n    vec4 applyOpacity(vec4 color) {\n      float value = ${n}.z;\n      if (value <= vvOpacityValues[0]) {\n        return vec4( color.xyz, vvOpacityOpacities[0]);\n      }\n\n      for (int i = 1; i < vvOpacityNumber; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));\n        }\n      }\n\n      return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);\n    }\n    `)) : p.code.add(l`vec4 applyOpacity(vec4 color){\nreturn color;\n}`), c.vvColor ? (p.constants.add(\"vvColorNumber\", \"int\", s), p.uniforms.add([new a(\"vvColorValues\", e => e.vvColorValues, s), new t(\"vvColorColors\", e => e.vvColorColors, s)]), p.code.add(l`\n    vec4 getColor() {\n      float value = ${n}.y;\n      if (value <= vvColorValues[0]) {\n        return applyOpacity(vvColorColors[0]);\n      }\n\n      for (int i = 1; i < vvColorNumber; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));\n        }\n      }\n\n      return applyOpacity(vvColorColors[vvColorNumber - 1]);\n    }\n    `)) : p.code.add(l`vec4 getColor(){\nreturn applyOpacity(vec4(1, 1, 1, 1));\n}`), e.include(o), e.attributes.add(v.PROFILERIGHT, \"vec4\"), e.attributes.add(v.PROFILEUP, \"vec4\"), e.attributes.add(v.PROFILEVERTEXANDNORMAL, \"vec4\"), p.code.add(l`vec3 calculateVPos() {\nvec2 size = getSize();\nvec3 origin = position;\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileVertex = profileVertexAndNormal.xy * size;\nvec2 profileNormal = profileVertexAndNormal.zw;\nfloat positionOffsetAlongProfilePlaneNormal = 0.0;\nfloat normalOffsetAlongProfilePlaneNormal = 0.0;`), p.code.add(l`if(!isCapVertex()) {\nvec2 rotationRight = vec2(profileRight.w, profileUp.w);\nfloat maxDistance = length(rotationRight);`), p.code.add(l`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);\nfloat rx = dot(profileVertex, rotationRight);\nif (abs(rx) > maxDistance) {\nvec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);\nfloat ry = dot(profileVertex, rotationUp);\nprofileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;\n}\n}else{\npositionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];\nnormalOffsetAlongProfilePlaneNormal = profileUp.w;\n}\nvec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;\nreturn origin + offset;\n}`), p.code.add(l`vec3 localNormal() {\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileNormal = profileVertexAndNormal.zw;\nvec3 normal = right * profileNormal.x + up * profileNormal.y;\nif(isCapVertex()) {\nnormal += forward * profileUp.w;\n}\nreturn normal;\n}`);\n}\nclass p extends c {\n  constructor() {\n    super(...arguments), this.size = e(1, 1);\n  }\n}\nexport { n as PathVertexPosition, p as PathVertexPositionPassParameters };","map":{"version":3,"names":["f","e","PositionAttribute","o","Float2PassUniform","i","Float3PassUniform","r","Float4sPassUniform","t","FloatsPassUniform","a","glsl","l","VertexAttribute","v","vvColorNumber","s","VisualVariablePassParameters","c","n","FEATUREVALUE","attributes","add","p","vertex","code","uniforms","size","vvSize","vvSizeMinSize","vvSizeMaxSize","vvSizeOffset","vvSizeFactor","vvOpacity","constants","vvOpacityValues","vvOpacityOpacities","vvColor","vvColorValues","vvColorColors","include","PROFILERIGHT","PROFILEUP","PROFILEVERTEXANDNORMAL","constructor","arguments","PathVertexPosition","PathVertexPositionPassParameters"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{f as e}from\"../../../../../../chunks/vec2f64.js\";import{PositionAttribute as o}from\"./PositionAttribute.glsl.js\";import{Float2PassUniform as i}from\"../../shaderModules/Float2PassUniform.js\";import{Float3PassUniform as r}from\"../../shaderModules/Float3PassUniform.js\";import{Float4sPassUniform as t}from\"../../shaderModules/Float4sPassUniform.js\";import{FloatsPassUniform as a}from\"../../shaderModules/FloatsPassUniform.js\";import{glsl as l}from\"../../shaderModules/interfaces.js\";import{VertexAttribute as v}from\"../../../lib/VertexAttribute.js\";import{vvColorNumber as s,VisualVariablePassParameters as c}from\"../../../materials/VisualVariablePassParameters.js\";const f=8;function n(e,c){const n=v.FEATUREVALUE;e.attributes.add(n,\"vec4\");const p=e.vertex;p.code.add(l`\n  bool isCapVertex() {\n    return ${n}.w == 1.0;\n  }\n  `),p.uniforms.add(new i(\"size\",(e=>e.size))),c.vvSize?(p.uniforms.add(new r(\"vvSizeMinSize\",(e=>e.vvSizeMinSize))),p.uniforms.add(new r(\"vvSizeMaxSize\",(e=>e.vvSizeMaxSize))),p.uniforms.add(new r(\"vvSizeOffset\",(e=>e.vvSizeOffset))),p.uniforms.add(new r(\"vvSizeFactor\",(e=>e.vvSizeFactor))),p.code.add(l`\n    vec2 getSize() {\n      return size * clamp(vvSizeOffset + ${n}.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;\n    }\n    `)):p.code.add(l`vec2 getSize(){\nreturn size;\n}`),c.vvOpacity?(p.constants.add(\"vvOpacityNumber\",\"int\",f),p.uniforms.add([new a(\"vvOpacityValues\",(e=>e.vvOpacityValues),f),new a(\"vvOpacityOpacities\",(e=>e.vvOpacityOpacities),f)]),p.code.add(l`\n    vec4 applyOpacity(vec4 color) {\n      float value = ${n}.z;\n      if (value <= vvOpacityValues[0]) {\n        return vec4( color.xyz, vvOpacityOpacities[0]);\n      }\n\n      for (int i = 1; i < vvOpacityNumber; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));\n        }\n      }\n\n      return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);\n    }\n    `)):p.code.add(l`vec4 applyOpacity(vec4 color){\nreturn color;\n}`),c.vvColor?(p.constants.add(\"vvColorNumber\",\"int\",s),p.uniforms.add([new a(\"vvColorValues\",(e=>e.vvColorValues),s),new t(\"vvColorColors\",(e=>e.vvColorColors),s)]),p.code.add(l`\n    vec4 getColor() {\n      float value = ${n}.y;\n      if (value <= vvColorValues[0]) {\n        return applyOpacity(vvColorColors[0]);\n      }\n\n      for (int i = 1; i < vvColorNumber; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));\n        }\n      }\n\n      return applyOpacity(vvColorColors[vvColorNumber - 1]);\n    }\n    `)):p.code.add(l`vec4 getColor(){\nreturn applyOpacity(vec4(1, 1, 1, 1));\n}`),e.include(o),e.attributes.add(v.PROFILERIGHT,\"vec4\"),e.attributes.add(v.PROFILEUP,\"vec4\"),e.attributes.add(v.PROFILEVERTEXANDNORMAL,\"vec4\"),p.code.add(l`vec3 calculateVPos() {\nvec2 size = getSize();\nvec3 origin = position;\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileVertex = profileVertexAndNormal.xy * size;\nvec2 profileNormal = profileVertexAndNormal.zw;\nfloat positionOffsetAlongProfilePlaneNormal = 0.0;\nfloat normalOffsetAlongProfilePlaneNormal = 0.0;`),p.code.add(l`if(!isCapVertex()) {\nvec2 rotationRight = vec2(profileRight.w, profileUp.w);\nfloat maxDistance = length(rotationRight);`),p.code.add(l`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);\nfloat rx = dot(profileVertex, rotationRight);\nif (abs(rx) > maxDistance) {\nvec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);\nfloat ry = dot(profileVertex, rotationUp);\nprofileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;\n}\n}else{\npositionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];\nnormalOffsetAlongProfilePlaneNormal = profileUp.w;\n}\nvec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;\nreturn origin + offset;\n}`),p.code.add(l`vec3 localNormal() {\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileNormal = profileVertexAndNormal.zw;\nvec3 normal = right * profileNormal.x + up * profileNormal.y;\nif(isCapVertex()) {\nnormal += forward * profileUp.w;\n}\nreturn normal;\n}`)}class p extends c{constructor(){super(...arguments),this.size=e(1,1)}}export{n as PathVertexPosition,p as PathVertexPositionPassParameters};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}