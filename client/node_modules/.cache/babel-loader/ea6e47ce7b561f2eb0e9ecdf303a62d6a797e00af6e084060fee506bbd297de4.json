{"ast":null,"code":"import Portal from '@arcgis/core/portal/Portal';\nimport PortalItem from '@arcgis/core/portal/PortalItem';\nimport { unwrapOrThrow as l } from \"@arcgis/core/core/maybe\";\nimport i from \"@arcgis/core/core/Error\";\nimport { LOAD_PORTAL, SET_IDENTITY, GET_USER_ITEMS, SET_USER_ITEMS, GET_USER_TAGS, SET_USER_TAGS, UPDATE_ITEM_TAGS } from '../constants/action-types';\nconst portal = new Portal({\n  authMode: 'immediate'\n});\nconst qParamArray = ['title', 'type', 'created', 'tag'];\n\n/**\r\n * Middleware function with the signature\r\n *\r\n * storeInstance =>\r\n * functionToCallWithAnActionThatWillSendItToTheNextMiddleware =>\r\n * actionThatDispatchWasCalledWith =>\r\n * valueToUseAsTheReturnValueOfTheDispatchCall\r\n *\r\n * Typically written as\r\n *\r\n * store => next => action => result\r\n */\nconst arcgisMiddleWare = store => next => action => {\n  switch (action.type) {\n    case LOAD_PORTAL:\n      portal.load().then(() => {\n        store.dispatch({\n          type: SET_IDENTITY,\n          username: portal.user.username,\n          fullname: portal.user.fullName,\n          email: portal.user.email,\n          thumbnailurl: portal.user.thumbnailUrl\n        });\n        store.dispatch({\n          type: GET_USER_ITEMS\n        });\n      }).then(() => {\n        store.dispatch({\n          type: GET_USER_TAGS\n        });\n      });\n      break;\n    case GET_USER_ITEMS:\n      //Does this sanitize?\n      let myUrlGet = new URL(window.location.href); //console.log(myUrlGet.toString())\n      let myUrlHas = new URLSearchParams(myUrlGet.search);\n      let qString = '';\n      if (myUrlHas.has(\"dcreated\")) {\n        let qDCreated = myUrlHas.get(\"dcreated\"); //console.log(qDCreated)\n        if (qDCreated !== '') {\n          let created = new Date(qDCreated);\n          let createdUnix = created.getTime().toString();\n          if (myUrlHas.get(\"rcreated\") === \"before\") {\n            createdUnix = '[0 TO ' + createdUnix + ']';\n          } else if (myUrlHas.get(\"rcreated\") === \"after\") {\n            createdUnix = '[' + createdUnix + ' TO 99999999999999]';\n          }\n          ; //console.log(createdUnix)\n          myUrlHas.set(\"created\", createdUnix);\n        }\n      }\n      myUrlGet.search = myUrlHas.toString();\n      //const new_url = myUrlGet.toString(); console.log(new_url)\n      window.history.replaceState('', '', myUrlGet.search);\n      for (const field of qParamArray) {\n        if (myUrlHas.has(field)) {\n          if (myUrlGet.searchParams.get(field) !== '') {\n            qString += ' AND ' + field + ':' + myUrlGet.searchParams.get(field);\n          }\n        }\n      }\n      if (portal.user != null) {\n        //console.log(\"query string is \" + qString)\n        try {\n          return portal.queryItems({\n            //portal.user.fetchItems() might be better\n            query: `owner:${portal.user.username}` + qString,\n            sortField: 'modified',\n            sortOrder: 'desc',\n            num: 20,\n            //max is 100, default is 10\n            start: 1\n          }).then(_ref => {\n            let {\n              results\n            } = _ref;\n            //console.log(results)\n            store.dispatch({\n              type: SET_USER_ITEMS,\n              userItems: results\n            });\n          });\n        } catch (err) {\n          console.log(err.message);\n        } finally {\n          console.log(portal.user.username + ' is getting items');\n        }\n      }\n      break;\n    case GET_USER_TAGS:\n      if (portal.user != null) {\n        try {\n          return portal.user.fetchTags().then(result => {\n            //console.log(result.map(({tag}) => tag))\n            store.dispatch({\n              type: SET_USER_TAGS,\n              userTags: result.map(_ref2 => {\n                let {\n                  tag\n                } = _ref2;\n                return tag;\n              })\n            });\n          });\n        } catch (err) {\n          console.log(err.message);\n        } finally {\n          console.log(portal.user.username + ' is fetching tags');\n        }\n      }\n      break;\n    case UPDATE_ITEM_TAGS:\n      const addTags = []; //: { id: string, tag: string, }[] = []\n      document.querySelectorAll(\"select.selectTags option:checked\").forEach(option => {\n        if (option.id !== '') {\n          addTags.push({\n            id: option.id.replace(option.value, ''),\n            //(option as HTMLInputElement)\n            tag: option.value\n          });\n        }\n      }); //console.log(addTags)\n\n      addTags.forEach(item => {\n        //__esri.PortalItemUpdateParams\n        const portalItem = new PortalItem({\n          id: item.id\n        });\n        const e = 'tag4, tag5, tag6';\n        portalItem.id ? portalItem.load().then(() => l(portalItem.portal).signIn()).then(() => {\n          const t = e && e.data,\n            i = {\n              method: \"post\"\n            },\n            j = portalItem.toJSON();\n          for (const i of [\"tags\", \"typeKeywords\", \"categories\"]) j[i] && (j[i] = j[i].join(\", \"));\n          const {\n            extent: x\n          } = j;\n          i.query = (x && (j.extent = JSON.stringify(x)), j);\n          for (const e in i.query) null === i.query[e] && (i.query[e] = \"\");\n          return i.query.clearEmptyFields = !0, null != t && (\"string\" == typeof t ? i.query.text = t : \"object\" == typeof t && (i.query.text = JSON.stringify(t))), this.portal.request(`${portalItem.userItemUrl}/update`, i).then(() => portalItem.reload());\n        }) : Promise.reject(new i(\"portal:item-does-not-exist\", \"The item does not exist yet and cannot be updated\"));\n\n        /*\r\n        createPostQuery(){\r\n          const e=this.toJSON();\r\n          for(const i of [\"tags\",\"typeKeywords\",\"categories\"])\r\n              e[i]&&(e[i]=e[i].join(\", \"));\r\n          const{extent:t}=e;\r\n          return t&&(e.extent=JSON.stringify(t)),e\r\n        }*/\n\n        /*\r\n        portalItem.load().then(() => {\r\n          const tagsCsv = 'tag4, tag5, tag6'\r\n            if (portalItem.loaded) { \r\n            //portalItem.update({data: {tags:tagsCsv}}).catch(function(error){console.log(error.message)})\r\n            \r\n            try {portalItem.update({tag: \"blah\"})}\r\n            catch(err) { console.log(err.message) }\r\n            finally {console.log(\"updating tags\")} \r\n          }\r\n        })*/\n      });\n      /*\r\n      update(e){\r\n        return this.id?this.load()\r\n        .then((()=>l(this.portal).signIn()))\r\n        .then((()=>{\r\n            const t=e&&e.data,i={method:\"post\"};\r\n            i.query=this.createPostQuery();\r\n            for(const e in i.query)\r\n                null===i.query[e]&&(i.query[e]=\"\");\r\n            return i.query.clearEmptyFields=!0,\r\n                null!=t&&(\r\n                    \"string\"==typeof t\r\n                    ?i.query.text=t:\"object\"==typeof t&&(i.query.text=JSON.stringify(t))\r\n                ),\r\n                this.portal.request(`${this.userItemUrl}/update`,i)\r\n                .then((()=>this.reload()))\r\n        })):\r\n        Promise.reject(new i(\"portal:item-does-not-exist\",\"The item does not exist yet and cannot be updated\"))\r\n      }*/\n\n      return next(action);\n    default:\n      return next(action);\n  }\n};\nexport default arcgisMiddleWare;","map":{"version":3,"names":["Portal","PortalItem","unwrapOrThrow","l","i","LOAD_PORTAL","SET_IDENTITY","GET_USER_ITEMS","SET_USER_ITEMS","GET_USER_TAGS","SET_USER_TAGS","UPDATE_ITEM_TAGS","portal","authMode","qParamArray","arcgisMiddleWare","store","next","action","type","load","then","dispatch","username","user","fullname","fullName","email","thumbnailurl","thumbnailUrl","myUrlGet","URL","window","location","href","myUrlHas","URLSearchParams","search","qString","has","qDCreated","get","created","Date","createdUnix","getTime","toString","set","history","replaceState","field","searchParams","queryItems","query","sortField","sortOrder","num","start","_ref","results","userItems","err","console","log","message","fetchTags","result","userTags","map","_ref2","tag","addTags","document","querySelectorAll","forEach","option","id","push","replace","value","item","portalItem","e","signIn","t","data","method","j","toJSON","join","extent","x","JSON","stringify","clearEmptyFields","text","request","userItemUrl","reload","Promise","reject"],"sources":["C:/code-challenge-react/frontend/src/middleware/arcgis-portal.js"],"sourcesContent":["import Portal from '@arcgis/core/portal/Portal'\r\nimport PortalItem from '@arcgis/core/portal/PortalItem'\r\nimport{unwrapOrThrow as l} from \"@arcgis/core/core/maybe\";\r\nimport i from \"@arcgis/core/core/Error\";\r\n\r\nimport {\r\n  LOAD_PORTAL,\r\n  SET_IDENTITY,\r\n  GET_USER_ITEMS,\r\n  SET_USER_ITEMS,\r\n  GET_USER_TAGS,\r\n  SET_USER_TAGS,\r\n  UPDATE_ITEM_TAGS,\r\n} from '../constants/action-types'\r\n\r\nconst portal = new Portal({ authMode: 'immediate' })\r\nconst qParamArray = ['title','type','created','tag']\r\n\r\n/**\r\n * Middleware function with the signature\r\n *\r\n * storeInstance =>\r\n * functionToCallWithAnActionThatWillSendItToTheNextMiddleware =>\r\n * actionThatDispatchWasCalledWith =>\r\n * valueToUseAsTheReturnValueOfTheDispatchCall\r\n *\r\n * Typically written as\r\n *\r\n * store => next => action => result\r\n */\r\nconst arcgisMiddleWare = store => next => (action) => {\r\n  switch (action.type) {\r\n    case LOAD_PORTAL:\r\n      portal.load()\r\n      .then(() => {\r\n        store.dispatch({\r\n          type: SET_IDENTITY,\r\n          username: portal.user.username,\r\n          fullname: portal.user.fullName,\r\n          email: portal.user.email,\r\n          thumbnailurl: portal.user.thumbnailUrl,\r\n        })\r\n        store.dispatch({ type: GET_USER_ITEMS })\r\n      }).then(() => {\r\n        store.dispatch({ type: GET_USER_TAGS })\r\n      })\r\n      break\r\n\r\n    case GET_USER_ITEMS:\r\n      //Does this sanitize?\r\n      let myUrlGet = new URL(window.location.href); //console.log(myUrlGet.toString())\r\n      let myUrlHas = new URLSearchParams(myUrlGet.search)\r\n      let qString = ''\r\n\r\n      if(myUrlHas.has(\"dcreated\")) {\r\n        let qDCreated = myUrlHas.get(\"dcreated\"); //console.log(qDCreated)\r\n        if((qDCreated !== '')){\r\n          let created = new Date(qDCreated)\r\n          let createdUnix = created.getTime().toString()\r\n          if(myUrlHas.get(\"rcreated\")===\"before\") {\r\n            createdUnix = '[0 TO ' + createdUnix + ']'\r\n          } else if (myUrlHas.get(\"rcreated\")===\"after\") {\r\n            createdUnix = '[' + createdUnix + ' TO 99999999999999]'\r\n          }; //console.log(createdUnix)\r\n          myUrlHas.set(\"created\",createdUnix)\r\n        }\r\n      }\r\n\r\n      myUrlGet.search = myUrlHas.toString()\r\n      //const new_url = myUrlGet.toString(); console.log(new_url)\r\n      window.history.replaceState('','',myUrlGet.search)\r\n\r\n      for (const field of qParamArray) {\r\n        if(myUrlHas.has(field)) {\r\n          if((myUrlGet.searchParams.get(field) !== '')){\r\n            qString += ' AND ' + field + ':' + myUrlGet.searchParams.get(field)\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (portal.user != null) { //console.log(\"query string is \" + qString)\r\n        try { \r\n          return portal.queryItems({ //portal.user.fetchItems() might be better\r\n            query: `owner:${portal.user.username}` + qString,\r\n            sortField: 'modified',\r\n            sortOrder: 'desc',\r\n            num: 20, //max is 100, default is 10\r\n            start: 1,\r\n          })\r\n          .then(({ results }) => { //console.log(results)\r\n            store.dispatch({ \r\n              type: SET_USER_ITEMS, userItems: results,\r\n            })\r\n          })\r\n        }\r\n        catch(err) { console.log(err.message) }\r\n        finally { console.log(portal.user.username + ' is getting items') }\r\n      }\r\n      break\r\n\r\n    case GET_USER_TAGS:\r\n      if (portal.user != null) {\r\n        try { \r\n          return portal.user.fetchTags()\r\n          .then((result) => { //console.log(result.map(({tag}) => tag))\r\n            store.dispatch({ \r\n              type: SET_USER_TAGS, userTags: result.map(({tag}) => tag)\r\n            })\r\n          })\r\n        }\r\n        catch(err) { console.log(err.message) }\r\n        finally { console.log(portal.user.username + ' is fetching tags') }\r\n      }\r\n      break\r\n\r\n    case UPDATE_ITEM_TAGS:\r\n      const addTags = [] //: { id: string, tag: string, }[] = []\r\n      document.querySelectorAll(\"select.selectTags option:checked\").forEach(option => {\r\n        if (option.id !== '') {      \r\n          addTags.push({\r\n            id: option.id.replace((option.value),''), //(option as HTMLInputElement)\r\n            tag: option.value,\r\n          })\r\n        }\r\n      }); //console.log(addTags)\r\n\r\n      addTags.forEach((item) => { //__esri.PortalItemUpdateParams\r\n        const portalItem = new PortalItem({id: item.id})\r\n        const e = 'tag4, tag5, tag6'\r\n\r\n        portalItem.id?portalItem.load()\r\n        .then((()=>l(portalItem.portal).signIn()))\r\n        .then((()=>{\r\n            const t = e&&e.data,\r\n                  i= {method:\"post\"},\r\n                  j = portalItem.toJSON();\r\n            for(const i of [\"tags\",\"typeKeywords\",\"categories\"])\r\n                  j[i]&&(j[i]=j[i].join(\", \"));\r\n            const{extent:x}=j;\r\n            i.query = (x&&(j.extent=JSON.stringify(x)),j)\r\n            for(const e in i.query)\r\n                null===i.query[e]&&(i.query[e]=\"\");\r\n            return i.query.clearEmptyFields=!0,\r\n                null!=t&&(\r\n                    \"string\"==typeof t\r\n                    ?i.query.text=t:\"object\"==typeof t&&(i.query.text=JSON.stringify(t))\r\n                ),\r\n                this.portal.request(`${portalItem.userItemUrl}/update`,i)\r\n                .then((()=>portalItem.reload()))\r\n        })):\r\n        Promise.reject(\r\n          new i(\"portal:item-does-not-exist\",\r\n          \"The item does not exist yet and cannot be updated\"\r\n        ))\r\n\r\n        /*\r\n        createPostQuery(){\r\n          const e=this.toJSON();\r\n          for(const i of [\"tags\",\"typeKeywords\",\"categories\"])\r\n              e[i]&&(e[i]=e[i].join(\", \"));\r\n          const{extent:t}=e;\r\n          return t&&(e.extent=JSON.stringify(t)),e\r\n        }*/\r\n\r\n        /*\r\n        portalItem.load().then(() => {\r\n          const tagsCsv = 'tag4, tag5, tag6'\r\n\r\n          if (portalItem.loaded) { \r\n            //portalItem.update({data: {tags:tagsCsv}}).catch(function(error){console.log(error.message)})\r\n            \r\n            try {portalItem.update({tag: \"blah\"})}\r\n            catch(err) { console.log(err.message) }\r\n            finally {console.log(\"updating tags\")} \r\n          }\r\n        })*/\r\n      })\r\n      /*\r\n      update(e){\r\n        return this.id?this.load()\r\n        .then((()=>l(this.portal).signIn()))\r\n        .then((()=>{\r\n            const t=e&&e.data,i={method:\"post\"};\r\n            i.query=this.createPostQuery();\r\n            for(const e in i.query)\r\n                null===i.query[e]&&(i.query[e]=\"\");\r\n            return i.query.clearEmptyFields=!0,\r\n                null!=t&&(\r\n                    \"string\"==typeof t\r\n                    ?i.query.text=t:\"object\"==typeof t&&(i.query.text=JSON.stringify(t))\r\n                ),\r\n                this.portal.request(`${this.userItemUrl}/update`,i)\r\n                .then((()=>this.reload()))\r\n        })):\r\n        Promise.reject(new i(\"portal:item-does-not-exist\",\"The item does not exist yet and cannot be updated\"))\r\n      }*/\r\n\r\n      return(next(action))\r\n\r\n    default:\r\n      return next(action)\r\n  }\r\n}\r\n\r\nexport default arcgisMiddleWare"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}