{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { H as e, s as t, w as o, g as a, n as i, e as r, h as n } from \"./vec3.js\";\nimport { c as s, f as d } from \"./vec3f64.js\";\nimport { PrecipitationType as c } from \"../views/3d/environment/PrecipitationTechniqueConfiguration.js\";\nimport { Float3PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as l } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as p } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as u } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction h(e) {\n  const t = new p();\n  return t.attributes.add(u.POSITION, \"vec3\"), t.attributes.add(u.INSTANCEFEATUREATTRIBUTE, \"float\"), t.vertex.uniforms.add(new m(\"cameraPosition\", (e, t) => t.camera.eye)), t.vertex.uniforms.add(new m(\"offset\", (e, t) => g(e, t))), t.vertex.uniforms.add(new v(\"width\", e => e.width)), t.vertex.uniforms.add(new f(\"proj\", (e, t) => t.camera.projectionMatrix)), t.vertex.uniforms.add(new f(\"view\", (e, t) => t.camera.viewMatrix)), t.vertex.uniforms.add(new v(\"time\", e => e.time)), t.varyings.add(\"vUv\", \"vec2\"), t.vertex.code.add(l`\n    vec3 hash31(float p){\n      vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xxy + p3.yzz) * p3.zyx);\n    }\n\n    float hash11(float p){\n      p = fract(p * 0.1031);\n      p *= p + 33.33;\n      p *= p + p;\n      return fract(p);\n    }\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n      return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n    }\n\n    void main(void) {\n\n      vUv = position.xz;\n\n      vec3 rand = hash31(instanceFeatureAttribute);\n\n      // Set random position for all particles\n      // The hash function space is not high resolution so offset particles by an additional random value\n      // This creates grids of 1000 particles which are shifted by random hundreths of the tile width\n      // overlaying multiple identical but offset grids\n      vec3 randomPosition = 2.0 * (rand + (0.01 + 0.01 * rand) * floor(0.001 * instanceFeatureAttribute)) - 1.0;\n\n      // Random orientation of rain drops\n      float angle = 3.1415 * hash11(instanceFeatureAttribute);\n\n      vec3 up = vec3(0, 0, 1);\n\n      // Gravity and wind direction\n      vec3 direction = normalize(cameraPosition);\n\n      vec3 tangent = normalize(cross(direction, up));\n\n      // Gravity\n      vec3 animatedPos = randomPosition + direction * -time;\n\n      // Rain particles fall straight down and are randomly oriented\n      // Snow particles have random sinusoid trajectories and are rotated to face the camera\n      ${e.type === c.Rain ? l`\n            // Random rotation for particle\n            vec3 rotationAxis = up;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n            vec3 transformedPos = rotateVectorByQuaternion(vec3(0.2, 0.2, 4.0) * (position - vec3(0.5, 0.0, 0.5)), quat);\n\n            // Rotate particle to planetary position\n            rotationAxis = tangent;\n            angle = 0.5 * -acos(dot(direction, up));\n            quat = vec4(rotationAxis * sin(angle), cos(angle));\n            transformedPos = rotateVectorByQuaternion(transformedPos, quat);\n\n            vec4 pos = mat4(mat3(view)) * vec4(transformedPos + (mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * pos;\n      ` : l`\n            vec3 rotationAxis = direction;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n\n            tangent = rotateVectorByQuaternion(tangent, quat);\n            // Random sinusoid from friction\n            animatedPos += tangent * 0.25 * sin(dot(animatedPos, direction));\n            vec4 pos = mat4(mat3(view)) * vec4((mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * (0.5 * vec4(position.xzy, 0.0) + pos);\n      `}\n    }\n  `), t.fragment.uniforms.add([new v(\"opacity\", e => e.opacity), new m(\"particleColor\", (t, o) => w(o, e))]), t.fragment.code.add(l`\n    void main() {\n\n      // Cut off corners of the triangle\n      if(vUv.x < 0.0 || vUv.y < 0.0){\n        discard;\n      }\n\n      float d = length(vUv - vec2(0.5));\n\n      ${e.type === c.Rain ? l`d = 0.35 * smoothstep(0.5, 0.0, d);` : l`d = smoothstep(0.5, 0.1, d);`}\n      gl_FragColor = opacity * vec4(particleColor * d, d);\n    }\n  `), t;\n}\nfunction g(i, r) {\n  const n = r.camera.eye,\n    s = .5 * i.width,\n    d = 1 / i.width,\n    c = e(y, t(y, (n[0] + s) * d, (n[1] + s) * d, (n[2] + s) * d));\n  return o(c, n, a(c, c, i.width));\n}\nfunction w(e, t) {\n  const o = t.type === c.Rain ? P : b,\n    s = a(y, o, j),\n    d = e.camera.eye;\n  i(x, d);\n  const m = Math.max(0, r(x, e.lighting.mainLight.direction));\n  return n(s, s, o, m);\n}\nconst y = s(),\n  x = s(),\n  b = d(1, 1, 1),\n  P = d(.85, .85, .85),\n  j = .7,\n  A = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: h\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { A as P, h as b };","map":{"version":3,"names":["H","e","s","t","w","o","g","a","n","i","r","h","c","f","d","PrecipitationType","Float3PassUniform","m","FloatPassUniform","v","glsl","l","Matrix4PassUniform","ShaderBuilder","p","VertexAttribute","u","attributes","add","POSITION","INSTANCEFEATUREATTRIBUTE","vertex","uniforms","camera","eye","width","projectionMatrix","viewMatrix","time","varyings","code","type","Rain","fragment","opacity","y","P","b","j","x","Math","max","lighting","mainLight","direction","A","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/Precipitation.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{H as e,s as t,w as o,g as a,n as i,e as r,h as n}from\"./vec3.js\";import{c as s,f as d}from\"./vec3f64.js\";import{PrecipitationType as c}from\"../views/3d/environment/PrecipitationTechniqueConfiguration.js\";import{Float3PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{FloatPassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as l}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as p}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as u}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function h(e){const t=new p;return t.attributes.add(u.POSITION,\"vec3\"),t.attributes.add(u.INSTANCEFEATUREATTRIBUTE,\"float\"),t.vertex.uniforms.add(new m(\"cameraPosition\",((e,t)=>t.camera.eye))),t.vertex.uniforms.add(new m(\"offset\",((e,t)=>g(e,t)))),t.vertex.uniforms.add(new v(\"width\",(e=>e.width))),t.vertex.uniforms.add(new f(\"proj\",((e,t)=>t.camera.projectionMatrix))),t.vertex.uniforms.add(new f(\"view\",((e,t)=>t.camera.viewMatrix))),t.vertex.uniforms.add(new v(\"time\",(e=>e.time))),t.varyings.add(\"vUv\",\"vec2\"),t.vertex.code.add(l`\n    vec3 hash31(float p){\n      vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xxy + p3.yzz) * p3.zyx);\n    }\n\n    float hash11(float p){\n      p = fract(p * 0.1031);\n      p *= p + 33.33;\n      p *= p + p;\n      return fract(p);\n    }\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n      return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n    }\n\n    void main(void) {\n\n      vUv = position.xz;\n\n      vec3 rand = hash31(instanceFeatureAttribute);\n\n      // Set random position for all particles\n      // The hash function space is not high resolution so offset particles by an additional random value\n      // This creates grids of 1000 particles which are shifted by random hundreths of the tile width\n      // overlaying multiple identical but offset grids\n      vec3 randomPosition = 2.0 * (rand + (0.01 + 0.01 * rand) * floor(0.001 * instanceFeatureAttribute)) - 1.0;\n\n      // Random orientation of rain drops\n      float angle = 3.1415 * hash11(instanceFeatureAttribute);\n\n      vec3 up = vec3(0, 0, 1);\n\n      // Gravity and wind direction\n      vec3 direction = normalize(cameraPosition);\n\n      vec3 tangent = normalize(cross(direction, up));\n\n      // Gravity\n      vec3 animatedPos = randomPosition + direction * -time;\n\n      // Rain particles fall straight down and are randomly oriented\n      // Snow particles have random sinusoid trajectories and are rotated to face the camera\n      ${e.type===c.Rain?l`\n            // Random rotation for particle\n            vec3 rotationAxis = up;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n            vec3 transformedPos = rotateVectorByQuaternion(vec3(0.2, 0.2, 4.0) * (position - vec3(0.5, 0.0, 0.5)), quat);\n\n            // Rotate particle to planetary position\n            rotationAxis = tangent;\n            angle = 0.5 * -acos(dot(direction, up));\n            quat = vec4(rotationAxis * sin(angle), cos(angle));\n            transformedPos = rotateVectorByQuaternion(transformedPos, quat);\n\n            vec4 pos = mat4(mat3(view)) * vec4(transformedPos + (mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * pos;\n      `:l`\n            vec3 rotationAxis = direction;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n\n            tangent = rotateVectorByQuaternion(tangent, quat);\n            // Random sinusoid from friction\n            animatedPos += tangent * 0.25 * sin(dot(animatedPos, direction));\n            vec4 pos = mat4(mat3(view)) * vec4((mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * (0.5 * vec4(position.xzy, 0.0) + pos);\n      `}\n    }\n  `),t.fragment.uniforms.add([new v(\"opacity\",(e=>e.opacity)),new m(\"particleColor\",((t,o)=>w(o,e)))]),t.fragment.code.add(l`\n    void main() {\n\n      // Cut off corners of the triangle\n      if(vUv.x < 0.0 || vUv.y < 0.0){\n        discard;\n      }\n\n      float d = length(vUv - vec2(0.5));\n\n      ${e.type===c.Rain?l`d = 0.35 * smoothstep(0.5, 0.0, d);`:l`d = smoothstep(0.5, 0.1, d);`}\n      gl_FragColor = opacity * vec4(particleColor * d, d);\n    }\n  `),t}function g(i,r){const n=r.camera.eye,s=.5*i.width,d=1/i.width,c=e(y,t(y,(n[0]+s)*d,(n[1]+s)*d,(n[2]+s)*d));return o(c,n,a(c,c,i.width))}function w(e,t){const o=t.type===c.Rain?P:b,s=a(y,o,j),d=e.camera.eye;i(x,d);const m=Math.max(0,r(x,e.lighting.mainLight.direction));return n(s,s,o,m)}const y=s(),x=s(),b=d(1,1,1),P=d(.85,.85,.85),j=.7,A=Object.freeze(Object.defineProperty({__proto__:null,build:h},Symbol.toStringTag,{value:\"Module\"}));export{A as P,h as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}