{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { s as e } from \"./vec2.js\";\nimport { a as i } from \"./vec2f64.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { multipassTerrainTest as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { Float2PassUniform as n } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as t } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as a } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as l } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Uniform as r } from \"../views/3d/webgl-engine/core/shaderModules/Uniform.js\";\nimport { VertexAttribute as c } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { AdjustProjectedPosition as p } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js\";\nimport { DiscardByCoverage as P } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl.js\";\nimport { DiscardNonSilhouetteEdges as u } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl.js\";\nimport { EdgeUtil as g, EdgeUtilMode as v } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js\";\nimport { LineAmplitude as f } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl.js\";\nimport { LineOffset as m } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl.js\";\nimport { UnpackAttributes as x } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl.js\";\nfunction w(i) {\n  const r = new l(),\n    {\n      vertex: w,\n      fragment: L\n    } = r;\n  return i.legacy && w.uniforms.add([new A(\"model\"), new A(\"localView\")]), r.include(p, i), r.include(g, i), r.include(f, i), r.include(x, i), r.include(m, i), r.include(o, i), r.include(u, i), r.include(P, i), r.include(s, i), r.varyings.add(\"vColor\", \"vec4\"), r.varyings.add(\"vRadius\", \"float\"), r.varyings.add(\"vPosition\", \"vec3\"), r.varyings.add(\"vWorldPosition\", \"vec3\"), r.varyings.add(\"vViewPos\", \"vec3\"), r.varyings.add(\"vLineLengthPixels\", \"float\"), r.varyings.add(\"vSizeFalloffFactor\", \"float\"), w.uniforms.add([new n(\"pixelToNDC\", (i, o) => e(h, 2 / o.camera.fullViewport[2], 2 / o.camera.fullViewport[3])), new t(\"viewport\", (e, i) => i.camera.fullViewport), new d(\"pixelRatio\", (e, i) => i.camera.pixelRatio)]), r.attributes.add(c.POSITION0, \"vec3\"), r.attributes.add(c.POSITION1, \"vec3\"), r.attributes.add(c.VARIANTOFFSET, \"float\"), r.attributes.add(c.VARIANTSTROKE, \"float\"), r.attributes.add(c.VARIANTEXTENSION, \"float\"), w.code.add(a`\n    const float opaqueCutoff = 1.0 / 255.0;\n\n    void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n      vec2 sideness = unpackedAttributes.sideness;\n      vec2 sidenessNorm = unpackedAttributes.sidenessNorm;\n\n      vWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\n\n      vec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);\n      vViewPos = viewPos;\n\n      vec4 projPosV0 = projFromViewPosition(viewPosV0);\n      vec4 projPosV1 = projFromViewPosition(viewPosV1);\n      vec4 projPos = projFromViewPosition(viewPos);\n\n      vec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n      vec2 ndcToPixel = viewport.zw * 0.5;\n      vec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * ndcToPixel;\n      float lineLengthPixels = length(screenSpaceLinePixels);\n\n      float dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;\n      vec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n\n      float falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * pixelRatio;\n      float lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;\n\n      float extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n      float lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * pixelRatio;\n\n      vSizeFalloffFactor = falloffFactor;\n\n      float lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n      float extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n\n      ${i.antialiasing ? a`\n        const float aaPaddingPixels = 1.0;\n\n        // Line size with padding\n        float halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n        float aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;` : a`\n        float halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n        float aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;`}\n\n      // Half line width in NDC including padding for anti aliasing\n      vec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * pixelToNDC;\n      vec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * pixelToNDC;\n      vec2 extensionLengthNDC = extensionLengthPixels * pixelToNDC;\n\n      // Compute screen space position of vertex, offsetting for line size and end caps\n      vec2 ndcOffset = (\n          screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n        + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n      );\n\n      projPos.xy += ndcOffset * projPos.w;\n      projPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n\n      projPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n\n      // Line length with end caps\n      float aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n\n      float pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n\n      // Position in pixels with origin at first vertex of line segment\n      vPosition = vec3(\n        halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n        pixelPositionAlongLine,\n        pixelPositionAlongLine / extendedLineLengthPixels\n      );\n\n      // The line width radius in pixels\n      vRadius = lineWidthPixels * 0.5;\n      vLineLengthPixels = extendedLineLengthPixels;\n\n      // discard short edges below a certain length threshold\n      ${i.mode === v.SKETCH ? a`\n        if (lineLengthPixels <= 3.0) {\n          gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n          return;\n        }` : i.mode === v.MIXED ? a`\n        if (lineLengthPixels <= 3.0 && unpackedAttributes.type <= 0.0) {\n           gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n           return;\n        }` : \"\"}\n      gl_Position = projPos;\n    }\n\n    void main() {\n      ComponentData component = readComponentData();\n      UnpackedAttributes unpackedAttributes = unpackAttributes(component);\n\n      vec3 worldPosV0, worldPosV1, viewPosV0, viewPosV1;\n      worldAndViewFromModelPosition(position0, component.verticalOffset, worldPosV0, viewPosV0);\n      worldAndViewFromModelPosition(position1, component.verticalOffset, worldPosV1, viewPosV1);\n\n      // Component color\n      vColor = component.color;\n\n      // Discard fully transparent edges\n      if (vColor.a < opaqueCutoff) {\n        gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n        return;\n      }\n\n      if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {\n        return;\n      }\n\n      // General geometric computation for all types of edges\n      calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);\n\n      // Specific computation for different edge styles\n      calculateStyleOutputs(unpackedAttributes);\n    }\n  `), L.code.add(a`\n    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n      float positionX = position.x - calculateLineOffset();\n\n      if (radius < 1.0) {\n        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n        return vec2(0.5 - min(coverageX, coverageY), 0.0);\n      }\n      else {\n        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius\n        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);\n\n        vec2 lineToPosition = vec2(positionX, positionOnCap);\n        return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n      }\n    }\n\n    void main() {\n      ${i.hasMultipassTerrain ? \"terrainDepthTest(gl_FragCoord, vViewPos.z);\" : \"\"}\n      float radius = vRadius * calculateLinePressure();\n\n      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);\n\n      discardByCoverage(radius, coverage);\n      discardBySlice(vWorldPosition);\n\n      gl_FragColor = vec4(vColor.rgb, vColor.a * coverage);\n    }\n  `), r;\n}\nconst h = i();\nclass A extends r {\n  constructor(e) {\n    super(e, \"mat4\");\n  }\n}\nconst L = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: w\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { L as E, w as b };","map":{"version":3,"names":["s","e","a","i","SliceDraw","o","multipassTerrainTest","Float2PassUniform","n","Float4PassUniform","t","FloatPassUniform","d","glsl","ShaderBuilder","l","Uniform","r","VertexAttribute","c","AdjustProjectedPosition","p","DiscardByCoverage","P","DiscardNonSilhouetteEdges","u","EdgeUtil","g","EdgeUtilMode","v","LineAmplitude","f","LineOffset","m","UnpackAttributes","x","w","vertex","fragment","L","legacy","uniforms","add","A","include","varyings","h","camera","fullViewport","pixelRatio","attributes","POSITION0","POSITION1","VARIANTOFFSET","VARIANTSTROKE","VARIANTEXTENSION","code","antialiasing","mode","SKETCH","MIXED","hasMultipassTerrain","constructor","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","E","b"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/EdgeShader.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{s as e}from\"./vec2.js\";import{a as i}from\"./vec2f64.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{multipassTerrainTest as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{Float2PassUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as t}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as a}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as l}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Uniform as r}from\"../views/3d/webgl-engine/core/shaderModules/Uniform.js\";import{VertexAttribute as c}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{AdjustProjectedPosition as p}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js\";import{DiscardByCoverage as P}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl.js\";import{DiscardNonSilhouetteEdges as u}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl.js\";import{EdgeUtil as g,EdgeUtilMode as v}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js\";import{LineAmplitude as f}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl.js\";import{LineOffset as m}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl.js\";import{UnpackAttributes as x}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl.js\";function w(i){const r=new l,{vertex:w,fragment:L}=r;return i.legacy&&w.uniforms.add([new A(\"model\"),new A(\"localView\")]),r.include(p,i),r.include(g,i),r.include(f,i),r.include(x,i),r.include(m,i),r.include(o,i),r.include(u,i),r.include(P,i),r.include(s,i),r.varyings.add(\"vColor\",\"vec4\"),r.varyings.add(\"vRadius\",\"float\"),r.varyings.add(\"vPosition\",\"vec3\"),r.varyings.add(\"vWorldPosition\",\"vec3\"),r.varyings.add(\"vViewPos\",\"vec3\"),r.varyings.add(\"vLineLengthPixels\",\"float\"),r.varyings.add(\"vSizeFalloffFactor\",\"float\"),w.uniforms.add([new n(\"pixelToNDC\",((i,o)=>e(h,2/o.camera.fullViewport[2],2/o.camera.fullViewport[3]))),new t(\"viewport\",((e,i)=>i.camera.fullViewport)),new d(\"pixelRatio\",((e,i)=>i.camera.pixelRatio))]),r.attributes.add(c.POSITION0,\"vec3\"),r.attributes.add(c.POSITION1,\"vec3\"),r.attributes.add(c.VARIANTOFFSET,\"float\"),r.attributes.add(c.VARIANTSTROKE,\"float\"),r.attributes.add(c.VARIANTEXTENSION,\"float\"),w.code.add(a`\n    const float opaqueCutoff = 1.0 / 255.0;\n\n    void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n      vec2 sideness = unpackedAttributes.sideness;\n      vec2 sidenessNorm = unpackedAttributes.sidenessNorm;\n\n      vWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\n\n      vec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);\n      vViewPos = viewPos;\n\n      vec4 projPosV0 = projFromViewPosition(viewPosV0);\n      vec4 projPosV1 = projFromViewPosition(viewPosV1);\n      vec4 projPos = projFromViewPosition(viewPos);\n\n      vec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n      vec2 ndcToPixel = viewport.zw * 0.5;\n      vec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * ndcToPixel;\n      float lineLengthPixels = length(screenSpaceLinePixels);\n\n      float dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;\n      vec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n\n      float falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * pixelRatio;\n      float lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;\n\n      float extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n      float lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * pixelRatio;\n\n      vSizeFalloffFactor = falloffFactor;\n\n      float lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n      float extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n\n      ${i.antialiasing?a`\n        const float aaPaddingPixels = 1.0;\n\n        // Line size with padding\n        float halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n        float aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;`:a`\n        float halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n        float aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;`}\n\n      // Half line width in NDC including padding for anti aliasing\n      vec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * pixelToNDC;\n      vec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * pixelToNDC;\n      vec2 extensionLengthNDC = extensionLengthPixels * pixelToNDC;\n\n      // Compute screen space position of vertex, offsetting for line size and end caps\n      vec2 ndcOffset = (\n          screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n        + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n      );\n\n      projPos.xy += ndcOffset * projPos.w;\n      projPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n\n      projPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n\n      // Line length with end caps\n      float aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n\n      float pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n\n      // Position in pixels with origin at first vertex of line segment\n      vPosition = vec3(\n        halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n        pixelPositionAlongLine,\n        pixelPositionAlongLine / extendedLineLengthPixels\n      );\n\n      // The line width radius in pixels\n      vRadius = lineWidthPixels * 0.5;\n      vLineLengthPixels = extendedLineLengthPixels;\n\n      // discard short edges below a certain length threshold\n      ${i.mode===v.SKETCH?a`\n        if (lineLengthPixels <= 3.0) {\n          gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n          return;\n        }`:i.mode===v.MIXED?a`\n        if (lineLengthPixels <= 3.0 && unpackedAttributes.type <= 0.0) {\n           gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n           return;\n        }`:\"\"}\n      gl_Position = projPos;\n    }\n\n    void main() {\n      ComponentData component = readComponentData();\n      UnpackedAttributes unpackedAttributes = unpackAttributes(component);\n\n      vec3 worldPosV0, worldPosV1, viewPosV0, viewPosV1;\n      worldAndViewFromModelPosition(position0, component.verticalOffset, worldPosV0, viewPosV0);\n      worldAndViewFromModelPosition(position1, component.verticalOffset, worldPosV1, viewPosV1);\n\n      // Component color\n      vColor = component.color;\n\n      // Discard fully transparent edges\n      if (vColor.a < opaqueCutoff) {\n        gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n        return;\n      }\n\n      if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {\n        return;\n      }\n\n      // General geometric computation for all types of edges\n      calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);\n\n      // Specific computation for different edge styles\n      calculateStyleOutputs(unpackedAttributes);\n    }\n  `),L.code.add(a`\n    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n      float positionX = position.x - calculateLineOffset();\n\n      if (radius < 1.0) {\n        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n        return vec2(0.5 - min(coverageX, coverageY), 0.0);\n      }\n      else {\n        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius\n        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);\n\n        vec2 lineToPosition = vec2(positionX, positionOnCap);\n        return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n      }\n    }\n\n    void main() {\n      ${i.hasMultipassTerrain?\"terrainDepthTest(gl_FragCoord, vViewPos.z);\":\"\"}\n      float radius = vRadius * calculateLinePressure();\n\n      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);\n\n      discardByCoverage(radius, coverage);\n      discardBySlice(vWorldPosition);\n\n      gl_FragColor = vec4(vColor.rgb, vColor.a * coverage);\n    }\n  `),r}const h=i();class A extends r{constructor(e){super(e,\"mat4\")}}const L=Object.freeze(Object.defineProperty({__proto__:null,build:w},Symbol.toStringTag,{value:\"Module\"}));export{L as E,w as b};\n"],"mappings":"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AAC,CAACgC,SAAS,EAAC,MAAM,CAAC,EAAClC,CAAC,CAACiC,UAAU,CAACR,GAAG,CAACvB,CAAC,CAACiC,SAAS,EAAC,MAAM,CAAC,EAACnC,CAAC,CAACiC,UAAU,CAACR,GAAG,CAACvB,CAAC,CAACkC,aAAa,EAAC,OAAO,CAAC,EAACpC,CAAC,CAACiC,UAAU,CAACR,GAAG,CAACvB,CAAC,CAACmC,aAAa,EAAC,OAAO,CAAC,EAACrC,CAAC,CAACiC,UAAU,CAACR,GAAG,CAACvB,CAAC,CAACoC,gBAAgB,EAAC,OAAO,CAAC,EAACnB,CAAC,CAACoB,IAAI,CAACd,GAAG,CAACxC,CAAE;AACvmF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQC,CAAC,CAACsD,YAAY,GAACvD,CAAE;AACzB;AACA;AACA;AACA;AACA,sFAAsF,GAACA,CAAE;AACzF;AACA,8EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQC,CAAC,CAACuD,IAAI,KAAG7B,CAAC,CAAC8B,MAAM,GAACzD,CAAE;AAC5B;AACA;AACA;AACA,UAAU,GAACC,CAAC,CAACuD,IAAI,KAAG7B,CAAC,CAAC+B,KAAK,GAAC1D,CAAE;AAC9B;AACA;AACA;AACA,UAAU,GAAC,EAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,EAACqC,CAAC,CAACiB,IAAI,CAACd,GAAG,CAACxC,CAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQC,CAAC,CAAC0D,mBAAmB,GAAC,6CAA6C,GAAC,EAAG;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,EAAC5C,CAAC;AAAA;AAAC,MAAM6B,CAAC,GAAC3C,CAAC,EAAE;AAAC,MAAMwC,CAAC,SAAS1B,CAAC;EAAC6C,WAAWA,CAAC7D,CAAC,EAAC;IAAC,KAAK,CAACA,CAAC,EAAC,MAAM,CAAC;EAAA;AAAC;AAAC,MAAMsC,CAAC,GAACwB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;EAACC,SAAS,EAAC,IAAI;EAACC,KAAK,EAAC/B;AAAC,CAAC,EAACgC,MAAM,CAACC,WAAW,EAAC;EAACC,KAAK,EAAC;AAAQ,CAAC,CAAC,CAAC;AAAC,SAAO/B,CAAC,IAAIgC,CAAC,EAACnC,CAAC,IAAIoC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}