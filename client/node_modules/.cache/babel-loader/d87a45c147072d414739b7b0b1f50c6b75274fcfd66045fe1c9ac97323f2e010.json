{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { clamp as o } from \"../../../../../../core/mathUtils.js\";\nimport { isSome as a } from \"../../../../../../core/maybe.js\";\nimport { earth as t } from \"../../../../../../geometry/support/Ellipsoid.js\";\nimport { FadeInOutStages as e } from \"../../../../environment/CloudsCompositionParameters.js\";\nimport { CloudsTextureChannels as r, CloudsRenderingStages as d } from \"../../../../environment/CloudsData.js\";\nimport { addMainLightDirection as i, addMainLightIntensity as c } from \"../shading/MainLighting.glsl.js\";\nimport { BooleanPassUniform as n } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { Float3PassUniform as l } from \"../../shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as s } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as u } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as C } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { TextureCubePassUniform as m } from \"../../shaderModules/TextureCubePassUniform.js\";\nfunction v(v) {\n  const R = v.fragment;\n  R.uniforms.add([new C(\"rotationMatrixClouds\", (o, a) => a.cloudsFade.parallax.transform), new C(\"rotationMatrixCloudsCrossFade\", (o, a) => a.cloudsFade.parallaxNew.transform), new l(\"anchorPosition\", (o, a) => a.cloudsFade.parallax.anchorPointClouds), new l(\"anchorPositionCrossFade\", (o, a) => a.cloudsFade.parallaxNew.anchorPointClouds), new s(\"cloudsHeight\", (o, a) => a.cloudsFade.parallax.cloudsHeight), new s(\"radiusCurvatureCorrectionFactor\", (o, a) => a.cloudsFade.parallax.radiusCurvatureCorrectionFactor), new s(\"totalFadeInOut\", (o, a) => a.cloudsFade.fadeInOut.stage === e.FINISHED ? a.cloudsFade.fadeInOutHeight.factor + 1 - a.cloudsFade.fadeIn.factor : a.cloudsFade.fadeInOutHeight.factor + 1 - a.cloudsFade.fadeInOut.factor), new s(\"crossFadeAnchorFactor\", (a, t) => o(t.cloudsFade.crossFade.factor, 0, 1)), new m(\"cubeMap\", (o, t) => a(t.cloudsFade.data) && a(t.cloudsFade.data.cubeMap) ? t.cloudsFade.data.cubeMap.colorTexture : null), new n(\"crossFade\", (o, a) => a.cloudsFade.crossFade.enabled), new n(\"readChannelsRG\", (o, a) => a.cloudsFade.readChannels === r.RG), new n(\"fadeTextureChannels\", (o, a) => a.cloudsFade.renderingStage === d.FADING_TEXTURE_CHANNELS)]), R.constants.add(\"planetRadius\", \"float\", t.radius), R.code.add(u`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)\n{\nfloat radiusClouds = planetRadius + cloudsHeight;\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nvec3 intersectionPont = cameraPosition + dir * pointIntDist;\nintersectionPont =  intersectionPont - spherePos;\nreturn intersectionPont;\n}`), R.code.add(u`vec3 correctForPlanetCurvature(vec3 dir)\n{\ndir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;\nreturn dir;\n}`), R.code.add(u`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)\n{\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`), i(R), c(R), R.code.add(u`const float SUNSET_TRANSITION_FACTOR = 0.3;\nconst vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);\nconst float RIM_SCATTERING_FACTOR = 140.0;\nconst float BACKLIGHT_FACTOR = 0.2;\nconst float BACKLIGHT_SCATTERING_FACTOR = 10.0;\nconst float BACKLIGHT_TRANSITION_FACTOR = 0.3;\nvec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)\n{\nfloat upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));\nfloat dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);\nfloat sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);\nvec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);\nvec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);\nvec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\nvec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\nfloat scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\nfloat rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);\nvec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;\nfloat additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;\nreturn vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);\n}`), R.code.add(u`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)\n{\nvec4 cloudData = textureCube(cubeMap, rayDir);\nfloat mu = dot(rayDir, vec3(0, 0, 1));\nbool readChannels = readChannelsRG ^^ readOtherChannel;\nif (readChannels) {\ncloudData = vec4(vec3(cloudData.r), cloudData.g);\n} else {\ncloudData = vec4(vec3(cloudData.b), cloudData.a);\n}\nif (length(cloudData) == 0.0) {\nreturn vec4(cloudData.rgb, 1.0);\n}\nreturn cloudData;\n}`), R.code.add(u`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected, false);\nfloat totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudData.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);\n}`), R.code.add(u`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected, false);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\nintersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);\nvec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);\nfloat totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudColor.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`), R.code.add(u`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)\n{\nreturn crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);\n}`);\n}\nexport { v as CloudsParallaxShading };","map":{"version":3,"names":["clamp","o","isSome","a","earth","t","FadeInOutStages","e","CloudsTextureChannels","r","CloudsRenderingStages","d","addMainLightDirection","i","addMainLightIntensity","c","BooleanPassUniform","n","Float3PassUniform","l","FloatPassUniform","s","glsl","u","Matrix4PassUniform","C","TextureCubePassUniform","m","v","R","fragment","uniforms","add","cloudsFade","parallax","transform","parallaxNew","anchorPointClouds","cloudsHeight","radiusCurvatureCorrectionFactor","fadeInOut","stage","FINISHED","fadeInOutHeight","factor","fadeIn","crossFade","data","cubeMap","colorTexture","enabled","readChannels","RG","renderingStage","FADING_TEXTURE_CHANNELS","constants","radius","code","CloudsParallaxShading"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{clamp as o}from\"../../../../../../core/mathUtils.js\";import{isSome as a}from\"../../../../../../core/maybe.js\";import{earth as t}from\"../../../../../../geometry/support/Ellipsoid.js\";import{FadeInOutStages as e}from\"../../../../environment/CloudsCompositionParameters.js\";import{CloudsTextureChannels as r,CloudsRenderingStages as d}from\"../../../../environment/CloudsData.js\";import{addMainLightDirection as i,addMainLightIntensity as c}from\"../shading/MainLighting.glsl.js\";import{BooleanPassUniform as n}from\"../../shaderModules/BooleanPassUniform.js\";import{Float3PassUniform as l}from\"../../shaderModules/Float3PassUniform.js\";import{FloatPassUniform as s}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as u}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as C}from\"../../shaderModules/Matrix4PassUniform.js\";import{TextureCubePassUniform as m}from\"../../shaderModules/TextureCubePassUniform.js\";function v(v){const R=v.fragment;R.uniforms.add([new C(\"rotationMatrixClouds\",((o,a)=>a.cloudsFade.parallax.transform)),new C(\"rotationMatrixCloudsCrossFade\",((o,a)=>a.cloudsFade.parallaxNew.transform)),new l(\"anchorPosition\",((o,a)=>a.cloudsFade.parallax.anchorPointClouds)),new l(\"anchorPositionCrossFade\",((o,a)=>a.cloudsFade.parallaxNew.anchorPointClouds)),new s(\"cloudsHeight\",((o,a)=>a.cloudsFade.parallax.cloudsHeight)),new s(\"radiusCurvatureCorrectionFactor\",((o,a)=>a.cloudsFade.parallax.radiusCurvatureCorrectionFactor)),new s(\"totalFadeInOut\",((o,a)=>a.cloudsFade.fadeInOut.stage===e.FINISHED?a.cloudsFade.fadeInOutHeight.factor+1-a.cloudsFade.fadeIn.factor:a.cloudsFade.fadeInOutHeight.factor+1-a.cloudsFade.fadeInOut.factor)),new s(\"crossFadeAnchorFactor\",((a,t)=>o(t.cloudsFade.crossFade.factor,0,1))),new m(\"cubeMap\",((o,t)=>a(t.cloudsFade.data)&&a(t.cloudsFade.data.cubeMap)?t.cloudsFade.data.cubeMap.colorTexture:null)),new n(\"crossFade\",((o,a)=>a.cloudsFade.crossFade.enabled)),new n(\"readChannelsRG\",((o,a)=>a.cloudsFade.readChannels===r.RG)),new n(\"fadeTextureChannels\",((o,a)=>a.cloudsFade.renderingStage===d.FADING_TEXTURE_CHANNELS))]),R.constants.add(\"planetRadius\",\"float\",t.radius),R.code.add(u`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)\n{\nfloat radiusClouds = planetRadius + cloudsHeight;\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nvec3 intersectionPont = cameraPosition + dir * pointIntDist;\nintersectionPont =  intersectionPont - spherePos;\nreturn intersectionPont;\n}`),R.code.add(u`vec3 correctForPlanetCurvature(vec3 dir)\n{\ndir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;\nreturn dir;\n}`),R.code.add(u`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)\n{\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`),i(R),c(R),R.code.add(u`const float SUNSET_TRANSITION_FACTOR = 0.3;\nconst vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);\nconst float RIM_SCATTERING_FACTOR = 140.0;\nconst float BACKLIGHT_FACTOR = 0.2;\nconst float BACKLIGHT_SCATTERING_FACTOR = 10.0;\nconst float BACKLIGHT_TRANSITION_FACTOR = 0.3;\nvec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)\n{\nfloat upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));\nfloat dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);\nfloat sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);\nvec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);\nvec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);\nvec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\nvec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\nfloat scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\nfloat rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);\nvec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;\nfloat additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;\nreturn vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);\n}`),R.code.add(u`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)\n{\nvec4 cloudData = textureCube(cubeMap, rayDir);\nfloat mu = dot(rayDir, vec3(0, 0, 1));\nbool readChannels = readChannelsRG ^^ readOtherChannel;\nif (readChannels) {\ncloudData = vec4(vec3(cloudData.r), cloudData.g);\n} else {\ncloudData = vec4(vec3(cloudData.b), cloudData.a);\n}\nif (length(cloudData) == 0.0) {\nreturn vec4(cloudData.rgb, 1.0);\n}\nreturn cloudData;\n}`),R.code.add(u`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected, false);\nfloat totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudData.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);\n}`),R.code.add(u`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected, false);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\nintersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);\nvec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);\nfloat totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudColor.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`),R.code.add(u`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)\n{\nreturn crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);\n}`)}export{v as CloudsParallaxShading};\n"],"mappings":"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AS,CAACvB,GAAG,CAAC,cAAc,EAAC,OAAO,EAAC3B,CAAC,CAACmD,MAAM,CAAC,EAAC3B,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AAC5mE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACM,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AACjB;AACA;AACA;AACA,EAAE,CAAC,EAACM,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AACjB;AACA;AACA,EAAE,CAAC,EAACV,CAAC,CAACgB,CAAC,CAAC,EAACd,CAAC,CAACc,CAAC,CAAC,EAACA,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACM,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACM,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACM,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACM,CAAC,CAAC4B,IAAI,CAACzB,GAAG,CAACT,CAAE;AACjB;AACA;AACA,EAAE,CAAC;AAAA;AAAC,SAAOK,CAAC,IAAI8B,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}