{"ast":null,"code":"import _toArray from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\nimport { ArcGISAuthError, request } from \"./request.js\";\nimport { decodeQueryString } from \"./utils/decode-query-string.js\";\nimport { encodeQueryString } from \"./utils/encode-query-string.js\";\nimport { fetchToken } from \"./fetch-token.js\";\nimport { canUseOnlineToken, isFederated } from \"./federation-utils.js\";\nimport { validateAppAccess as _validateAppAccess } from \"./validate-app-access.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\nimport { revokeToken } from \"./revoke-token.js\";\nimport { generateCodeChallenge } from \"./utils/generate-code-challenge.js\";\nimport { generateRandomString } from \"./utils/generate-random-string.js\";\nimport { ArcGISAccessDeniedError } from \"./utils/ArcGISAccessDeniedError.js\";\nimport { ArcGISTokenRequestError, ArcGISTokenRequestErrorCodes } from \"./utils/ArcGISTokenRequestError.js\";\nimport { NODEJS_DEFAULT_REFERER_HEADER } from \"./index.js\";\n/**\n * Used to authenticate both ArcGIS Online and ArcGIS Enterprise users. `ArcGISIdentityManager` includes helper methods for [OAuth 2.0](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/oauth-2.0/) in both browser and server applications.\n *\n * **It is not recommended to construct `ArcGISIdentityManager` directly**. Instead there are several static methods used for specific workflows. The 2 primary workflows relate to oAuth 2.0:\n *\n * * {@linkcode ArcGISIdentityManager.beginOAuth2} and {@linkcode ArcGISIdentityManager.completeOAuth2()} for oAuth 2.0 in browser-only environment.\n * * {@linkcode ArcGISIdentityManager.authorize} and {@linkcode ArcGISIdentityManager.exchangeAuthorizationCode} for oAuth 2.0 for server-enabled application.\n *\n * Other more specialized helpers for less common workflows also exist:\n *\n * * {@linkcode ArcGISIdentityManager.fromToken} for when you have an existing token from another source and would like create an `ArcGISIdentityManager` instance.\n * * {@linkcode ArcGISIdentityManager.fromCredential} for creating  an `ArcGISIdentityManager` instance from a `Credentials` object in the ArcGIS JS API `IdentityManager`\n * * {@linkcode ArcGISIdentityManager.signIn} for authenticating directly with a user's username and password for environments with a user interface for oAuth 2.0.\n *\n * Once a manager is created there are additional utilities:\n *\n * * {@linkcode ArcGISIdentityManager.serialize} can be used to create a JSON object representing an instance of `ArcGISIdentityManager`\n * * {@linkcode ArcGISIdentityManager.deserialize} will create a new `ArcGISIdentityManager` from a JSON object created with {@linkcode ArcGISIdentityManager.serialize}\n * * {@linkcode ArcGISIdentityManager.destroy} or {@linkcode ArcGISIdentityManager.signOut} will invalidate any tokens in use by the  `ArcGISIdentityManager`.\n */\nexport var ArcGISIdentityManager = /*#__PURE__*/function () {\n  function ArcGISIdentityManager(options) {\n    _classCallCheck(this, ArcGISIdentityManager);\n    this.clientId = options.clientId;\n    this._refreshToken = options.refreshToken;\n    this._refreshTokenExpires = options.refreshTokenExpires;\n    this._username = options.username;\n    this.password = options.password;\n    this._token = options.token;\n    this._tokenExpires = options.tokenExpires;\n    this.portal = options.portal ? cleanUrl(options.portal) : \"https://www.arcgis.com/sharing/rest\";\n    this.ssl = options.ssl;\n    this.provider = options.provider || \"arcgis\";\n    this.tokenDuration = options.tokenDuration || 20160;\n    this.redirectUri = options.redirectUri;\n    this.server = options.server;\n    this.referer = options.referer;\n    this.federatedServers = {};\n    this.trustedDomains = [];\n    // if a non-federated server was passed explicitly, it should be trusted.\n    if (options.server) {\n      // if the url includes more than '/arcgis/', trim the rest\n      var root = this.getServerRootUrl(options.server);\n      this.federatedServers[root] = {\n        token: options.token,\n        expires: options.tokenExpires\n      };\n    }\n    this._pendingTokenRequests = {};\n  }\n  /**\n   * The current ArcGIS Online or ArcGIS Enterprise `token`.\n   */\n  _createClass(ArcGISIdentityManager, [{\n    key: \"token\",\n    get: function get() {\n      return this._token;\n    }\n    /**\n     * The expiration time of the current `token`.\n     */\n  }, {\n    key: \"tokenExpires\",\n    get: function get() {\n      return this._tokenExpires;\n    }\n    /**\n     * The current token to ArcGIS Online or ArcGIS Enterprise.\n     */\n  }, {\n    key: \"refreshToken\",\n    get: function get() {\n      return this._refreshToken;\n    }\n    /**\n     * The expiration time of the current `refreshToken`.\n     */\n  }, {\n    key: \"refreshTokenExpires\",\n    get: function get() {\n      return this._refreshTokenExpires;\n    }\n    /**\n     * The currently authenticated user.\n     */\n  }, {\n    key: \"username\",\n    get: function get() {\n      if (this._username) {\n        return this._username;\n      }\n      if (this._user && this._user.username) {\n        return this._user.username;\n      }\n    }\n    /**\n     * Returns `true` if these credentials can be refreshed and `false` if it cannot.\n     */\n  }, {\n    key: \"canRefresh\",\n    get: function get() {\n      if (this.username && this.password) {\n        return true;\n      }\n      if (this.clientId && this.refreshToken && this.redirectUri) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Begins a new browser-based OAuth 2.0 sign in. If `options.popup` is `true` the authentication window will open in a new tab/window. Otherwise, the user will be redirected to the authorization page in their current tab/window and the function will return `undefined`.\n     *\n     * If `popup` is `true` (the default) this method will return a `Promise` that resolves to an `ArcGISIdentityManager` instance and you must call {@linkcode ArcGISIdentityManager.completeOAuth2()} on the page defined in the `redirectUri`. Otherwise it will return undefined and the {@linkcode ArcGISIdentityManager.completeOAuth2()} method will return a `Promise` that resolves to an `ArcGISIdentityManager` instance.\n     *\n     * A {@linkcode ArcGISAccessDeniedError} error will be thrown if the user denies the request on the authorization screen.\n     *\n     * @browserOnly\n     */\n  }, {\n    key: \"toCredential\",\n    value:\n    /**\n     * Returns authentication in a format useable in the [`IdentityManager.registerToken()` method in the ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#registerToken).\n     *\n     * This method can be used with {@linkcode ArcGISIdentityManager.fromCredential} to interop with the ArcGIS API for JavaScript.\n     *\n     * ```js\n     * require([\"esri/id\"], (esriId) => {\n     *   esriId.registerToken(manager.toCredential());\n     * })\n     \n     * ```\n     *\n     * @returns ICredential\n     */\n    function toCredential() {\n      return {\n        expires: this.tokenExpires.getTime(),\n        server: this.server || this.portal,\n        ssl: this.ssl,\n        token: this.token,\n        userId: this.username\n      };\n    }\n    /**\n     * Returns information about the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic.\n     *\n     * ```js\n     * manager.getUser()\n     *   .then(response => {\n     *     console.log(response.role); // \"org_admin\"\n     *   })\n     * ```\n     *\n     * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n     * @returns A Promise that will resolve with the data from the response.\n     */\n  }, {\n    key: \"getUser\",\n    value: function getUser(requestOptions) {\n      var _this = this;\n      if (this._pendingUserRequest) {\n        return this._pendingUserRequest;\n      } else if (this._user) {\n        return Promise.resolve(this._user);\n      } else {\n        var url = \"\".concat(this.portal, \"/community/self\");\n        var options = Object.assign(Object.assign({\n          httpMethod: \"GET\",\n          authentication: this\n        }, requestOptions), {\n          rawResponse: false\n        });\n        this._pendingUserRequest = request(url, options).then(function (response) {\n          _this._user = response;\n          _this._pendingUserRequest = null;\n          return response;\n        });\n        return this._pendingUserRequest;\n      }\n    }\n    /**\n     * Returns information about the currently logged in user's [portal](https://developers.arcgis.com/rest/users-groups-and-items/portal-self.htm). Subsequent calls will *not* result in additional web traffic.\n     *\n     * ```js\n     * manager.getPortal()\n     *   .then(response => {\n     *     console.log(portal.name); // \"City of ...\"\n     *   })\n     * ```\n     *\n     * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n     * @returns A Promise that will resolve with the data from the response.\n     */\n  }, {\n    key: \"getPortal\",\n    value: function getPortal(requestOptions) {\n      var _this2 = this;\n      if (this._pendingPortalRequest) {\n        return this._pendingPortalRequest;\n      } else if (this._portalInfo) {\n        return Promise.resolve(this._portalInfo);\n      } else {\n        var url = \"\".concat(this.portal, \"/portals/self\");\n        var options = Object.assign(Object.assign({\n          httpMethod: \"GET\",\n          authentication: this\n        }, requestOptions), {\n          rawResponse: false\n        });\n        this._pendingPortalRequest = request(url, options).then(function (response) {\n          _this2._portalInfo = response;\n          _this2._pendingPortalRequest = null;\n          return response;\n        });\n        return this._pendingPortalRequest;\n      }\n    }\n    /**\n     * Returns the username for the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic. This is also used internally when a username is required for some requests but is not present in the options.\n     *\n     * ```js\n     * manager.getUsername()\n     *   .then(response => {\n     *     console.log(response); // \"casey_jones\"\n     *   })\n     * ```\n     */\n  }, {\n    key: \"getUsername\",\n    value: function getUsername() {\n      if (this.username) {\n        return Promise.resolve(this.username);\n      } else {\n        return this.getUser().then(function (user) {\n          return user.username;\n        });\n      }\n    }\n    /**\n     * Gets an appropriate token for the given URL. If `portal` is ArcGIS Online and\n     * the request is to an ArcGIS Online domain `token` will be used. If the request\n     * is to the current `portal` the current `token` will also be used. However if\n     * the request is to an unknown server we will validate the server with a request\n     * to our current `portal`.\n     */\n  }, {\n    key: \"getToken\",\n    value: function getToken(url, requestOptions) {\n      if (canUseOnlineToken(this.portal, url)) {\n        return this.getFreshToken(requestOptions);\n      } else if (new RegExp(this.portal, \"i\").test(url)) {\n        return this.getFreshToken(requestOptions);\n      } else {\n        return this.getTokenForServer(url, requestOptions);\n      }\n    }\n    /**\n     * Get application access information for the current user\n     * see `validateAppAccess` function for details\n     *\n     * @param clientId application client id\n     */\n  }, {\n    key: \"validateAppAccess\",\n    value: function validateAppAccess(clientId) {\n      return this.getToken(this.portal).then(function (token) {\n        return _validateAppAccess(token, clientId);\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        clientId: this.clientId,\n        refreshToken: this.refreshToken,\n        refreshTokenExpires: this.refreshTokenExpires || undefined,\n        username: this.username,\n        password: this.password,\n        token: this.token,\n        tokenExpires: this.tokenExpires || undefined,\n        portal: this.portal,\n        ssl: this.ssl,\n        tokenDuration: this.tokenDuration,\n        redirectUri: this.redirectUri,\n        server: this.server\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return JSON.stringify(this);\n    }\n    /**\n     * For a \"Host\" app that embeds other platform apps via iframes, after authenticating the user\n     * and creating a ArcGISIdentityManager, the app can then enable \"post message\" style authentication by calling\n     * this method.\n     *\n     * Internally this adds an event listener on window for the `message` event\n     *\n     * @param validChildOrigins Array of origins that are allowed to request authentication from the host app\n     */\n  }, {\n    key: \"enablePostMessageAuth\",\n    value: function enablePostMessageAuth(validChildOrigins, win) {\n      /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n      if (!win && window) {\n        win = window;\n      }\n      this._hostHandler = this.createPostMessageHandler(validChildOrigins);\n      win.addEventListener(\"message\", this._hostHandler, false);\n    }\n    /**\n     * For a \"Host\" app that has embedded other platform apps via iframes, when the host needs\n     * to transition routes, it should call `ArcGISIdentityManager.disablePostMessageAuth()` to remove\n     * the event listener and prevent memory leaks\n     */\n  }, {\n    key: \"disablePostMessageAuth\",\n    value: function disablePostMessageAuth(win) {\n      /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n      if (!win && window) {\n        win = window;\n      }\n      win.removeEventListener(\"message\", this._hostHandler, false);\n    }\n    /**\n     * Manually refreshes the current `token` and `tokenExpires`.\n     */\n  }, {\n    key: \"refreshCredentials\",\n    value: function refreshCredentials(requestOptions) {\n      // make sure subsequent calls to getUser() don't returned cached metadata\n      this._user = null;\n      if (this.username && this.password) {\n        return this.refreshWithUsernameAndPassword(requestOptions);\n      }\n      if (this.clientId && this.refreshToken) {\n        return this.refreshWithRefreshToken();\n      }\n      return Promise.reject(new ArcGISTokenRequestError(\"Unable to refresh token. No refresh token or password present.\", ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED));\n    }\n    /**\n     * Determines the root of the ArcGIS Server or Portal for a given URL.\n     *\n     * @param url the URl to determine the root url for.\n     */\n  }, {\n    key: \"getServerRootUrl\",\n    value: function getServerRootUrl(url) {\n      var _cleanUrl$split = cleanUrl(url).split(/\\/rest(\\/admin)?\\/services(?:\\/|#|\\?|$)/),\n        _cleanUrl$split2 = _slicedToArray(_cleanUrl$split, 1),\n        root = _cleanUrl$split2[0];\n      var _root$match = root.match(/(https?:\\/\\/)(.+)/),\n        _root$match2 = _slicedToArray(_root$match, 3),\n        match = _root$match2[0],\n        protocol = _root$match2[1],\n        domainAndPath = _root$match2[2];\n      var _domainAndPath$split = domainAndPath.split(\"/\"),\n        _domainAndPath$split2 = _toArray(_domainAndPath$split),\n        domain = _domainAndPath$split2[0],\n        path = _domainAndPath$split2.slice(1);\n      // only the domain is lowercased because in some cases an org id might be\n      // in the path which cannot be lowercased.\n      return \"\".concat(protocol).concat(domain.toLowerCase(), \"/\").concat(path.join(\"/\"));\n    }\n    /**\n     * Returns the proper [`credentials`] option for `fetch` for a given domain.\n     * See [trusted server](https://enterprise.arcgis.com/en/portal/latest/administer/windows/configure-security.htm#ESRI_SECTION1_70CC159B3540440AB325BE5D89DBE94A).\n     * Used internally by underlying request methods to add support for specific security considerations.\n     *\n     * @param url The url of the request\n     * @returns \"include\" or \"same-origin\"\n     */\n  }, {\n    key: \"getDomainCredentials\",\n    value: function getDomainCredentials(url) {\n      if (!this.trustedDomains || !this.trustedDomains.length) {\n        return \"same-origin\";\n      }\n      return this.trustedDomains.some(function (domainWithProtocol) {\n        return url.startsWith(domainWithProtocol);\n      }) ? \"include\" : \"same-origin\";\n    }\n    /**\n     * Convenience method for {@linkcode ArcGISIdentityManager.destroy} for this instance of `ArcGISIdentityManager`\n     */\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      return ArcGISIdentityManager.destroy(this);\n    }\n    /**\n     * Return a function that closes over the validOrigins array and\n     * can be used as an event handler for the `message` event\n     *\n     * @param validOrigins Array of valid origins\n     */\n  }, {\n    key: \"createPostMessageHandler\",\n    value: function createPostMessageHandler(validOrigins) {\n      var _this3 = this;\n      // return a function that closes over the validOrigins and\n      // has access to the credential\n      return function (event) {\n        // Verify that the origin is valid\n        // Note: do not use regex's here. validOrigins is an array so we're checking that the event's origin\n        // is in the array via exact match. More info about avoiding postMessage xss issues here\n        // https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html#tipsbypasses-in-postmessage-vulnerabilities\n        var isValidOrigin = validOrigins.indexOf(event.origin) > -1;\n        // JSAPI handles this slightly differently - instead of checking a list, it will respond if\n        // event.origin === window.location.origin || event.origin.endsWith('.arcgis.com')\n        // For Hub, and to enable cross domain debugging with port's in urls, we are opting to\n        // use a list of valid origins\n        // Ensure the message type is something we want to handle\n        var isValidType = event.data.type === \"arcgis:auth:requestCredential\";\n        // Ensure we don't pass an expired session forward\n        var isTokenValid = _this3.tokenExpires.getTime() > Date.now();\n        if (isValidOrigin && isValidType) {\n          var msg = {};\n          if (isTokenValid) {\n            var credential = _this3.toJSON();\n            msg = {\n              type: \"arcgis:auth:credential\",\n              credential: credential\n            };\n          } else {\n            msg = {\n              type: \"arcgis:auth:error\",\n              error: {\n                name: \"tokenExpiredError\",\n                message: \"Token was expired, and not returned to the child application\"\n              }\n            };\n          }\n          event.source.postMessage(msg, event.origin);\n        }\n      };\n    }\n    /**\n     * Validates that a given URL is properly federated with our current `portal`.\n     * Attempts to use the internal `federatedServers` cache first.\n     */\n  }, {\n    key: \"getTokenForServer\",\n    value: function getTokenForServer(url, requestOptions) {\n      var _this4 = this;\n      // requests to /rest/services/ and /rest/admin/services/ are both valid\n      // Federated servers may have inconsistent casing, so lowerCase it\n      var root = this.getServerRootUrl(url);\n      var existingToken = this.federatedServers[root];\n      if (existingToken && existingToken.expires && existingToken.expires.getTime() > Date.now()) {\n        return Promise.resolve(existingToken.token);\n      }\n      if (this._pendingTokenRequests[root]) {\n        return this._pendingTokenRequests[root];\n      }\n      this._pendingTokenRequests[root] = this.fetchAuthorizedDomains().then(function () {\n        return request(\"\".concat(root, \"/rest/info\"), {\n          credentials: _this4.getDomainCredentials(url)\n        }).then(function (serverInfo) {\n          if (serverInfo.owningSystemUrl) {\n            /**\n             * if this server is not owned by this portal\n             * bail out with an error since we know we wont\n             * be able to generate a token\n             */\n            if (!isFederated(serverInfo.owningSystemUrl, _this4.portal)) {\n              throw new ArcGISTokenRequestError(\"\".concat(url, \" is not federated with \").concat(_this4.portal, \".\"), ArcGISTokenRequestErrorCodes.NOT_FEDERATED);\n            } else {\n              /**\n               * if the server is federated, use the relevant token endpoint.\n               */\n              return request(\"\".concat(serverInfo.owningSystemUrl, \"/sharing/rest/info\"), requestOptions);\n            }\n          } else if (serverInfo.authInfo && _this4.federatedServers[root] !== undefined) {\n            /**\n             * if its a stand-alone instance of ArcGIS Server that doesn't advertise\n             * federation, but the root server url is recognized, use its built in token endpoint.\n             */\n            return Promise.resolve({\n              authInfo: serverInfo.authInfo\n            });\n          } else {\n            throw new ArcGISTokenRequestError(\"\".concat(url, \" is not federated with any portal and is not explicitly trusted.\"), ArcGISTokenRequestErrorCodes.NOT_FEDERATED);\n          }\n        }).then(function (serverInfo) {\n          // an expired token cant be used to generate a new token so refresh our credentials before trying to generate a server token\n          if (_this4.token && _this4.tokenExpires.getTime() < Date.now()) {\n            // If we are authenticated to a single server just refresh with username and password and use the new credentials as the credentials for this server.\n            if (_this4.server) {\n              return _this4.refreshCredentials().then(function () {\n                return {\n                  token: _this4.token,\n                  expires: _this4.tokenExpires\n                };\n              });\n            }\n            // Otherwise refresh the credentials for the portal and generate a URL for the specific server.\n            return _this4.refreshCredentials().then(function () {\n              return _this4.generateTokenForServer(serverInfo.authInfo.tokenServicesUrl, root);\n            });\n          } else {\n            return _this4.generateTokenForServer(serverInfo.authInfo.tokenServicesUrl, root);\n          }\n        }).then(function (response) {\n          _this4.federatedServers[root] = response;\n          delete _this4._pendingTokenRequests[root];\n          return response.token;\n        });\n      });\n      return this._pendingTokenRequests[root];\n    }\n    /**\n     * Generates a token for a given `serverUrl` using a given `tokenServicesUrl`.\n     */\n  }, {\n    key: \"generateTokenForServer\",\n    value: function generateTokenForServer(tokenServicesUrl, serverUrl) {\n      return request(tokenServicesUrl, {\n        params: {\n          token: this.token,\n          serverUrl: serverUrl,\n          expiration: this.tokenDuration\n        }\n      }).then(function (response) {\n        return {\n          token: response.token,\n          expires: new Date(response.expires - 1000 * 60 * 5)\n        };\n      }).catch(function (e) {\n        throw new ArcGISTokenRequestError(e.message, ArcGISTokenRequestErrorCodes.GENERATE_TOKEN_FOR_SERVER_FAILED, e.response, e.url, e.options);\n      });\n    }\n    /**\n     * Returns an unexpired token for the current `portal`.\n     */\n  }, {\n    key: \"getFreshToken\",\n    value: function getFreshToken(requestOptions) {\n      var _this5 = this;\n      if (this.token && !this.tokenExpires) {\n        return Promise.resolve(this.token);\n      }\n      if (this.token && this.tokenExpires && this.tokenExpires.getTime() > Date.now()) {\n        return Promise.resolve(this.token);\n      }\n      if (!this._pendingTokenRequests[this.portal]) {\n        this._pendingTokenRequests[this.portal] = this.refreshCredentials(requestOptions).then(function () {\n          _this5._pendingTokenRequests[_this5.portal] = null;\n          return _this5.token;\n        });\n      }\n      return this._pendingTokenRequests[this.portal];\n    }\n    /**\n     * Refreshes the current `token` and `tokenExpires` with `username` and\n     * `password`.\n     */\n  }, {\n    key: \"refreshWithUsernameAndPassword\",\n    value: function refreshWithUsernameAndPassword(requestOptions) {\n      var _this6 = this;\n      var params = {\n        username: this.username,\n        password: this.password,\n        expiration: this.tokenDuration,\n        client: \"referer\",\n        referer: this.referer ? this.referer : typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && window.location && window.location.origin ? window.location.origin : /* istanbul ignore next */\n        NODEJS_DEFAULT_REFERER_HEADER\n      };\n      return (this.server ? request(\"\".concat(this.getServerRootUrl(this.server), \"/rest/info\")).then(function (response) {\n        return request(response.authInfo.tokenServicesUrl, Object.assign({\n          params: params\n        }, requestOptions));\n      }) : request(\"\".concat(this.portal, \"/generateToken\"), Object.assign({\n        params: params\n      }, requestOptions))).then(function (response) {\n        _this6.updateToken(response.token, new Date(response.expires));\n        return _this6;\n      }).catch(function (e) {\n        throw new ArcGISTokenRequestError(e.message, ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED, e.response, e.url, e.options);\n      });\n    }\n    /**\n     * Refreshes the current `token` and `tokenExpires` with `refreshToken`.\n     */\n  }, {\n    key: \"refreshWithRefreshToken\",\n    value: function refreshWithRefreshToken(requestOptions) {\n      var _this7 = this;\n      // If our refresh token expires sometime in the next 24 hours then refresh the refresh token\n      var ONE_DAY_IN_MILLISECONDS = 1000 * 60 * 60 * 24;\n      if (this.refreshToken && this.refreshTokenExpires && this.refreshTokenExpires.getTime() - ONE_DAY_IN_MILLISECONDS < Date.now()) {\n        return this.exchangeRefreshToken(requestOptions);\n      }\n      var options = Object.assign({\n        params: {\n          client_id: this.clientId,\n          refresh_token: this.refreshToken,\n          grant_type: \"refresh_token\"\n        }\n      }, requestOptions);\n      return fetchToken(\"\".concat(this.portal, \"/oauth2/token\"), options).then(function (response) {\n        return _this7.updateToken(response.token, response.expires);\n      }).catch(function (e) {\n        throw new ArcGISTokenRequestError(e.message, ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED, e.response, e.url, e.options);\n      });\n    }\n    /**\n     * Update the stored {@linkcode ArcGISIdentityManager.token} and {@linkcode ArcGISIdentityManager.tokenExpires} properties. This method is used internally when refreshing tokens.\n     * You may need to call this if you want update the token with a new token from an external source.\n     *\n     * @param newToken The new token to use for this instance of `ArcGISIdentityManager`.\n     * @param newTokenExpiration The new expiration date of the token.\n     * @returns\n     */\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(newToken, newTokenExpiration) {\n      this._token = newToken;\n      this._tokenExpires = newTokenExpiration;\n      return this;\n    }\n    /**\n     * Exchanges an unexpired `refreshToken` for a new one, also updates `token` and\n     * `tokenExpires`.\n     */\n  }, {\n    key: \"exchangeRefreshToken\",\n    value: function exchangeRefreshToken(requestOptions) {\n      var _this8 = this;\n      var options = Object.assign({\n        params: {\n          client_id: this.clientId,\n          refresh_token: this.refreshToken,\n          redirect_uri: this.redirectUri,\n          grant_type: \"exchange_refresh_token\"\n        }\n      }, requestOptions);\n      return fetchToken(\"\".concat(this.portal, \"/oauth2/token\"), options).then(function (response) {\n        _this8._token = response.token;\n        _this8._tokenExpires = response.expires;\n        _this8._refreshToken = response.refreshToken;\n        _this8._refreshTokenExpires = response.refreshTokenExpires;\n        return _this8;\n      }).catch(function (e) {\n        throw new ArcGISTokenRequestError(e.message, ArcGISTokenRequestErrorCodes.REFRESH_TOKEN_EXCHANGE_FAILED, e.response, e.url, e.options);\n      });\n    }\n    /**\n     * ensures that the authorizedCrossOriginDomains are obtained from the portal and cached\n     * so we can check them later.\n     *\n     * @returns this\n     */\n  }, {\n    key: \"fetchAuthorizedDomains\",\n    value: function fetchAuthorizedDomains() {\n      var _this9 = this;\n      // if this token is for a specific server or we don't have a portal\n      // don't get the portal info because we cant get the authorizedCrossOriginDomains\n      if (this.server || !this.portal) {\n        return Promise.resolve(this);\n      }\n      return this.getPortal().then(function (portalInfo) {\n        /**\n         * Specific domains can be configured as secure.esri.com or https://secure.esri.com this\n         * normalizes to https://secure.esri.com so we can use startsWith later.\n         */\n        if (portalInfo.authorizedCrossOriginDomains && portalInfo.authorizedCrossOriginDomains.length) {\n          _this9.trustedDomains = portalInfo.authorizedCrossOriginDomains.filter(function (d) {\n            return !d.startsWith(\"http://\");\n          }).map(function (d) {\n            if (d.startsWith(\"https://\")) {\n              return d;\n            } else {\n              return \"https://\".concat(d);\n            }\n          });\n        }\n        return _this9;\n      });\n    }\n  }], [{\n    key: \"beginOAuth2\",\n    value: function beginOAuth2(options, win) {\n      /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n      if (!win && window) {\n        win = window;\n      }\n      var _Object$assign = Object.assign({\n          portal: \"https://www.arcgis.com/sharing/rest\",\n          provider: \"arcgis\",\n          expiration: 20160,\n          popup: true,\n          popupWindowFeatures: \"height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes\",\n          locale: \"\",\n          style: \"\",\n          pkce: true\n        }, options),\n        portal = _Object$assign.portal,\n        provider = _Object$assign.provider,\n        clientId = _Object$assign.clientId,\n        expiration = _Object$assign.expiration,\n        redirectUri = _Object$assign.redirectUri,\n        popup = _Object$assign.popup,\n        popupWindowFeatures = _Object$assign.popupWindowFeatures,\n        locale = _Object$assign.locale,\n        params = _Object$assign.params,\n        style = _Object$assign.style,\n        pkce = _Object$assign.pkce,\n        state = _Object$assign.state;\n      /**\n       * Generate a  random string for the `state` param and store it in local storage. This is used\n       * to validate that all parts of the oAuth process were performed on the same client.\n       */\n      var stateId = state || generateRandomString(win);\n      var stateStorageKey = \"ARCGIS_REST_JS_AUTH_STATE_\".concat(clientId);\n      win.localStorage.setItem(stateStorageKey, stateId);\n      // Start setting up the URL to the authorization screen.\n      var authorizeUrl = \"\".concat(cleanUrl(portal), \"/oauth2/authorize\");\n      var authorizeUrlParams = {\n        client_id: clientId,\n        response_type: pkce ? \"code\" : \"token\",\n        expiration: expiration,\n        redirect_uri: redirectUri,\n        state: JSON.stringify({\n          id: stateId,\n          originalUrl: win.location.href // this is used to reset the URL back the original URL upon return\n        }),\n\n        locale: locale,\n        style: style\n      };\n      // If we are authorizing through a specific social provider update the params and base URL.\n      if (provider !== \"arcgis\") {\n        authorizeUrl = \"\".concat(cleanUrl(portal), \"/oauth2/social/authorize\");\n        authorizeUrlParams.socialLoginProviderName = provider;\n        authorizeUrlParams.autoAccountCreateForSocial = true;\n      }\n      /**\n       * set a value that will be set to a promise which will later resolve when we are ready\n       * to send users to the authorization page.\n       */\n      var setupAuth;\n      if (pkce) {\n        /**\n         * If we are authenticating with PKCE we need to generate the code challenge which is\n         * async so we generate the code challenge and assign the resulting Promise to `setupAuth`\n         */\n        var codeVerifier = generateRandomString(win);\n        var codeVerifierStorageKey = \"ARCGIS_REST_JS_CODE_VERIFIER_\".concat(clientId);\n        win.localStorage.setItem(codeVerifierStorageKey, codeVerifier);\n        setupAuth = generateCodeChallenge(codeVerifier, win).then(function (codeChallenge) {\n          authorizeUrlParams.code_challenge_method = codeChallenge ? \"S256\" : \"plain\";\n          authorizeUrlParams.code_challenge = codeChallenge ? codeChallenge : codeVerifier;\n        });\n      } else {\n        /**\n         * If we aren't authenticating with PKCE we can just assign a resolved promise to `setupAuth`\n         */\n        setupAuth = Promise.resolve();\n      }\n      /**\n       * Once we are done setting up with (for PKCE) we can start the auth process.\n       */\n      return setupAuth.then(function () {\n        // combine the authorize URL and params\n        authorizeUrl = \"\".concat(authorizeUrl, \"?\").concat(encodeQueryString(authorizeUrlParams));\n        // append additional params passed by the user\n        if (params) {\n          authorizeUrl = \"\".concat(authorizeUrl, \"&\").concat(encodeQueryString(params));\n        }\n        if (popup) {\n          // If we are authenticating a popup we need to return a Promise that will resolve to an ArcGISIdentityManager later.\n          return new Promise(function (resolve, reject) {\n            // Add an event listener to listen for when a user calls `ArcGISIdentityManager.completeOAuth2()` in the popup.\n            win.addEventListener(\"arcgis-rest-js-popup-auth-\".concat(clientId), function (e) {\n              if (e.detail.error === \"access_denied\") {\n                var error = new ArcGISAccessDeniedError();\n                reject(error);\n                return error;\n              }\n              if (e.detail.errorMessage) {\n                var _error = new ArcGISAuthError(e.detail.errorMessage, e.detail.error);\n                reject(_error);\n                return _error;\n              }\n              resolve(new ArcGISIdentityManager({\n                clientId: clientId,\n                portal: portal,\n                ssl: e.detail.ssl,\n                token: e.detail.token,\n                tokenExpires: e.detail.expires,\n                username: e.detail.username,\n                refreshToken: e.detail.refreshToken,\n                refreshTokenExpires: e.detail.refreshTokenExpires,\n                redirectUri: redirectUri\n              }));\n            }, {\n              once: true\n            });\n            // open the popup\n            win.open(authorizeUrl, \"oauth-window\", popupWindowFeatures);\n            win.dispatchEvent(new CustomEvent(\"arcgis-rest-js-popup-auth-start\"));\n          });\n        } else {\n          // If we aren't authenticating with a popup just send the user to the authorization page.\n          win.location.href = authorizeUrl;\n          return undefined;\n        }\n      });\n    }\n    /**\n     * Completes a browser-based OAuth 2.0 sign in. If `options.popup` is `true` the user\n     * will be returned to the previous window and the popup will close. Otherwise a new `ArcGISIdentityManager` will be returned. You must pass the same values for `clientId`, `popup`, `portal`, and `pkce` as you used in `beginOAuth2()`.\n     *\n     * A {@linkcode ArcGISAccessDeniedError} error will be thrown if the user denies the request on the authorization screen.\n     * @browserOnly\n     */\n  }, {\n    key: \"completeOAuth2\",\n    value: function completeOAuth2(options, win) {\n      /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n      if (!win && window) {\n        win = window;\n      }\n      // pull out necessary options\n      var _Object$assign2 = Object.assign({\n          portal: \"https://www.arcgis.com/sharing/rest\",\n          popup: true,\n          pkce: true\n        }, options),\n        portal = _Object$assign2.portal,\n        clientId = _Object$assign2.clientId,\n        popup = _Object$assign2.popup,\n        pkce = _Object$assign2.pkce,\n        redirectUri = _Object$assign2.redirectUri;\n      // pull the saved state id out of local storage\n      var stateStorageKey = \"ARCGIS_REST_JS_AUTH_STATE_\".concat(clientId);\n      var stateId = win.localStorage.getItem(stateStorageKey);\n      // get the params provided by the server and compare the server state with the client saved state\n      var params = decodeQueryString(pkce ? win.location.search.replace(/^\\?/, \"\") : win.location.hash.replace(/^#/, \"\"));\n      var state = params && params.state ? JSON.parse(params.state) : undefined;\n      function reportError(errorMessage, error, originalUrl) {\n        win.localStorage.removeItem(stateStorageKey);\n        if (popup && win.opener) {\n          win.opener.dispatchEvent(new CustomEvent(\"arcgis-rest-js-popup-auth-\".concat(clientId), {\n            detail: {\n              error: error,\n              errorMessage: errorMessage\n            }\n          }));\n          win.close();\n          return;\n        }\n        if (originalUrl) {\n          win.history.replaceState(win.history.state, \"\", originalUrl);\n        }\n        if (error === \"access_denied\") {\n          return Promise.reject(new ArcGISAccessDeniedError());\n        }\n        return Promise.reject(new ArcGISAuthError(errorMessage, error));\n      }\n      // create a function to create the final ArcGISIdentityManager from the token info.\n      function createManager(oauthInfo, originalUrl) {\n        win.localStorage.removeItem(stateStorageKey);\n        if (popup && win.opener) {\n          win.opener.dispatchEvent(new CustomEvent(\"arcgis-rest-js-popup-auth-\".concat(clientId), {\n            detail: Object.assign({}, oauthInfo)\n          }));\n          win.close();\n          return;\n        }\n        win.history.replaceState(win.history.state, \"\", originalUrl);\n        return new ArcGISIdentityManager({\n          clientId: clientId,\n          portal: portal,\n          ssl: oauthInfo.ssl,\n          token: oauthInfo.token,\n          tokenExpires: oauthInfo.expires,\n          username: oauthInfo.username,\n          refreshToken: oauthInfo.refreshToken,\n          refreshTokenExpires: oauthInfo.refreshTokenExpires,\n          // At 4.0.0 it was possible (in JS code) to not pass redirectUri and fallback to win.location.href, however this broke support for redirect URIs with query params.\n          // Now similar to 3.x.x you must pass the redirectUri parameter explicitly. See https://github.com/Esri/arcgis-rest-js/issues/995\n          redirectUri: redirectUri || /* istanbul ignore next: TypeScript wont compile if we omit redirectUri */location.href.replace(location.search, \"\")\n        });\n      }\n      if (!stateId || !state) {\n        return reportError(\"No authentication state was found, call `ArcGISIdentityManager.beginOAuth2(...)` to start the authentication process.\", \"no-auth-state\");\n      }\n      if (state.id !== stateId) {\n        return reportError(\"Saved client state did not match server sent state.\", \"mismatched-auth-state\");\n      }\n      if (params.error) {\n        var error = params.error;\n        var errorMessage = params.error_description || \"Unknown error\";\n        return reportError(errorMessage, error, state.originalUrl);\n      }\n      /**\n       * If we are using PKCE the authorization code will be in the query params.\n       * For implicit grants the token will be in the hash.\n       */\n      if (pkce && params.code) {\n        var tokenEndpoint = cleanUrl(\"\".concat(portal, \"/oauth2/token/\"));\n        var codeVerifierStorageKey = \"ARCGIS_REST_JS_CODE_VERIFIER_\".concat(clientId);\n        var codeVerifier = win.localStorage.getItem(codeVerifierStorageKey);\n        win.localStorage.removeItem(codeVerifierStorageKey);\n        // exchange our auth code for a token + refresh token\n        return fetchToken(tokenEndpoint, {\n          httpMethod: \"POST\",\n          params: {\n            client_id: clientId,\n            code_verifier: codeVerifier,\n            grant_type: \"authorization_code\",\n            // using location.href here does not support query params but shipped with 4.0.0. See https://github.com/Esri/arcgis-rest-js/issues/995\n            redirect_uri: redirectUri || location.href.replace(location.search, \"\"),\n            code: params.code\n          }\n        }).then(function (tokenResponse) {\n          return createManager(Object.assign(Object.assign({}, tokenResponse), state), state.originalUrl);\n        }).catch(function (e) {\n          return reportError(e.originalMessage, e.code, state.originalUrl);\n        });\n      }\n      if (!pkce && params.access_token) {\n        return Promise.resolve(createManager(Object.assign({\n          token: params.access_token,\n          expires: new Date(Date.now() + parseInt(params.expires_in, 10) * 1000),\n          ssl: params.ssl === \"true\",\n          username: params.username\n        }, state), state.originalUrl));\n      }\n      return reportError(\"Unknown error\", \"oauth-error\", state.originalUrl);\n    }\n    /**\n     * Request credentials information from the parent application\n     *\n     * When an application is embedded into another application via an IFrame, the embedded app can\n     * use `window.postMessage` to request credentials from the host application. This function wraps\n     * that behavior.\n     *\n     * The ArcGIS API for Javascript has this built into the Identity Manager as of the 4.19 release.\n     *\n     * Note: The parent application will not respond if the embedded app's origin is not:\n     * - the same origin as the parent or *.arcgis.com (JSAPI)\n     * - in the list of valid child origins (REST-JS)\n     *\n     *\n     * @param parentOrigin origin of the parent frame. Passed into the embedded application as `parentOrigin` query param\n     * @browserOnly\n     */\n  }, {\n    key: \"fromParent\",\n    value: function fromParent(parentOrigin, win) {\n      /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n      if (!win && window) {\n        win = window;\n      }\n      // Declare handler outside of promise scope so we can detach it\n      var handler;\n      // return a promise that will resolve when the handler receives\n      // session information from the correct origin\n      return new Promise(function (resolve, reject) {\n        // create an event handler that just wraps the parentMessageHandler\n        handler = function handler(event) {\n          // ensure we only listen to events from the parent\n          if (event.source === win.parent && event.data) {\n            try {\n              return resolve(ArcGISIdentityManager.parentMessageHandler(event));\n            } catch (err) {\n              return reject(err);\n            }\n          }\n        };\n        // add listener\n        win.addEventListener(\"message\", handler, false);\n        win.parent.postMessage({\n          type: \"arcgis:auth:requestCredential\"\n        }, parentOrigin);\n      }).then(function (manager) {\n        win.removeEventListener(\"message\", handler, false);\n        return manager;\n      });\n    }\n    /**\n     * Begins a new server-based OAuth 2.0 sign in. This will redirect the user to\n     * the ArcGIS Online or ArcGIS Enterprise authorization page.\n     *\n     * @nodeOnly\n     */\n  }, {\n    key: \"authorize\",\n    value: function authorize(options, response) {\n      var _Object$assign3 = Object.assign({\n          portal: \"https://arcgis.com/sharing/rest\",\n          expiration: 20160\n        }, options),\n        portal = _Object$assign3.portal,\n        clientId = _Object$assign3.clientId,\n        expiration = _Object$assign3.expiration,\n        redirectUri = _Object$assign3.redirectUri,\n        state = _Object$assign3.state;\n      var queryParams = {\n        client_id: clientId,\n        expiration: expiration,\n        response_type: \"code\",\n        redirect_uri: redirectUri\n      };\n      if (state) {\n        queryParams.state = state;\n      }\n      var url = \"\".concat(portal, \"/oauth2/authorize?\").concat(encodeQueryString(queryParams));\n      response.writeHead(301, {\n        Location: url\n      });\n      response.end();\n    }\n    /**\n     * Completes the server-based OAuth 2.0 sign in process by exchanging the `authorizationCode`\n     * for a `access_token`.\n     *\n     * @nodeOnly\n     */\n  }, {\n    key: \"exchangeAuthorizationCode\",\n    value: function exchangeAuthorizationCode(options, authorizationCode) {\n      var _Object$assign4 = Object.assign({\n          portal: \"https://www.arcgis.com/sharing/rest\"\n        }, options),\n        portal = _Object$assign4.portal,\n        clientId = _Object$assign4.clientId,\n        redirectUri = _Object$assign4.redirectUri;\n      return fetchToken(\"\".concat(portal, \"/oauth2/token\"), {\n        params: {\n          grant_type: \"authorization_code\",\n          client_id: clientId,\n          redirect_uri: redirectUri,\n          code: authorizationCode\n        }\n      }).then(function (response) {\n        return new ArcGISIdentityManager({\n          clientId: clientId,\n          portal: portal,\n          ssl: response.ssl,\n          redirectUri: redirectUri,\n          refreshToken: response.refreshToken,\n          refreshTokenExpires: response.refreshTokenExpires,\n          token: response.token,\n          tokenExpires: response.expires,\n          username: response.username\n        });\n      }).catch(function (e) {\n        throw new ArcGISTokenRequestError(e.message, ArcGISTokenRequestErrorCodes.REFRESH_TOKEN_EXCHANGE_FAILED, e.response, e.url, e.options);\n      });\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(str) {\n      var options = JSON.parse(str);\n      return new ArcGISIdentityManager({\n        clientId: options.clientId,\n        refreshToken: options.refreshToken,\n        refreshTokenExpires: options.refreshTokenExpires ? new Date(options.refreshTokenExpires) : undefined,\n        username: options.username,\n        password: options.password,\n        token: options.token,\n        tokenExpires: options.tokenExpires ? new Date(options.tokenExpires) : undefined,\n        portal: options.portal,\n        ssl: options.ssl,\n        tokenDuration: options.tokenDuration,\n        redirectUri: options.redirectUri,\n        server: options.server\n      });\n    }\n    /**\n     * Translates authentication from the format used in the [`IdentityManager` class in the ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-Credential.html).\n     *\n     * You will need to call both [`IdentityManger.findCredential`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#findCredential) and [`IdentityManger.findServerInfo`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#findServerInfo) to obtain both parameters for this method.\n     *\n     * This method can be used with {@linkcode ArcGISIdentityManager.toCredential} to interop with the ArcGIS API for JavaScript.\n     *\n     * ```js\n     * require([\"esri/id\"], (esriId) => {\n     *   const credential = esriId.findCredential(\"https://www.arcgis.com/sharing/rest\");\n     *   const serverInfo = esriId.findServerInfo(\"https://www.arcgis.com/sharing/rest\");\n     *\n     *   const manager = ArcGISIdentityManager.fromCredential(credential, serverInfo);\n     * });\n     * ```\n     *\n     * @returns ArcGISIdentityManager\n     */\n  }, {\n    key: \"fromCredential\",\n    value: function fromCredential(credential, serverInfo) {\n      // At ArcGIS Online 9.1, credentials no longer include the ssl and expires properties\n      // Here, we provide default values for them to cover this condition\n      var ssl = typeof credential.ssl !== \"undefined\" ? credential.ssl : true;\n      var expires = credential.expires || Date.now() + 7200000; /* 2 hours */\n      if (serverInfo.hasServer) {\n        return new ArcGISIdentityManager({\n          server: credential.server,\n          ssl: ssl,\n          token: credential.token,\n          username: credential.userId,\n          tokenExpires: new Date(expires)\n        });\n      }\n      return new ArcGISIdentityManager({\n        portal: cleanUrl(credential.server.includes(\"sharing/rest\") ? credential.server : credential.server + \"/sharing/rest\"),\n        ssl: ssl,\n        token: credential.token,\n        username: credential.userId,\n        tokenExpires: new Date(expires)\n      });\n    }\n    /**\n     * Handle the response from the parent\n     * @param event DOM Event\n     */\n  }, {\n    key: \"parentMessageHandler\",\n    value: function parentMessageHandler(event) {\n      if (event.data.type === \"arcgis:auth:credential\") {\n        return new ArcGISIdentityManager(event.data.credential);\n      }\n      if (event.data.type === \"arcgis:auth:error\") {\n        var err = new Error(event.data.error.message);\n        err.name = event.data.error.name;\n        throw err;\n      } else {\n        throw new Error(\"Unknown message type.\");\n      }\n    }\n    /**\n     * Revokes all active tokens for a provided {@linkcode ArcGISIdentityManager}. The can be considered the equivalent to signing the user out of your application.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy(manager) {\n      return revokeToken({\n        clientId: manager.clientId,\n        portal: manager.portal,\n        token: manager.refreshToken || manager.token\n      });\n    }\n    /**\n     * Create a  {@linkcode ArcGISIdentityManager} from an existing token. Useful for when you have a users token from a different authentication system and want to get a  {@linkcode ArcGISIdentityManager}.\n     */\n  }, {\n    key: \"fromToken\",\n    value: function fromToken(options) {\n      var manager = new ArcGISIdentityManager(options);\n      return manager.getUser().then(function () {\n        return manager;\n      });\n    }\n    /**\n     * Initialize a {@linkcode ArcGISIdentityManager} with a user's `username` and `password`. **This method is intended ONLY for applications without a user interface such as CLI tools.**.\n     *\n     * If possible you should use {@linkcode ArcGISIdentityManager.beginOAuth2} to authenticate users in a browser or {@linkcode ArcGISIdentityManager.authorize} for authenticating users with a web server.\n     */\n  }, {\n    key: \"signIn\",\n    value: function signIn(options) {\n      var manager = new ArcGISIdentityManager(options);\n      return manager.getUser().then(function () {\n        return manager;\n      });\n    }\n  }]);\n  return ArcGISIdentityManager;\n}();\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager}.\n * @internal\n *\n */ /* istanbul ignore next */\nfunction UserSession(options) {\n  console.log(\"DEPRECATED:, 'UserSession' is deprecated. Use 'ArcGISIdentityManager' instead.\");\n  return new ArcGISIdentityManager(options);\n}\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.beginOAuth2}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.beginOAuth2 = function () {\n  console.warn(\"DEPRECATED:, 'UserSession.beginOAuth2' is deprecated. Use 'ArcGISIdentityManager.beginOAuth2' instead.\");\n  return ArcGISIdentityManager.beginOAuth2.apply(ArcGISIdentityManager, arguments);\n};\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.completeOAuth2}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.completeOAuth2 = function () {\n  console.warn(\"DEPRECATED:, 'UserSession.completeOAuth2()' is deprecated. Use 'ArcGISIdentityManager.completeOAuth2()' instead.\");\n  if (arguments.length <= 1) {\n    console.warn(\"WARNING:, 'UserSession.completeOAuth2()' is now async and returns a promise the resolves to an instance of `ArcGISIdentityManager`.\");\n  }\n  return ArcGISIdentityManager.completeOAuth2.apply(ArcGISIdentityManager, arguments);\n};\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.fromParent}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.fromParent = function () {\n  console.warn(\"DEPRECATED:, 'UserSession.fromParent' is deprecated. Use 'ArcGISIdentityManager.fromParent' instead.\");\n  return ArcGISIdentityManager.fromParent.apply(ArcGISIdentityManager, arguments);\n};\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.authorize}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.authorize = function () {\n  console.warn(\"DEPRECATED:, 'UserSession.authorize' is deprecated. Use 'ArcGISIdentityManager.authorize' instead.\");\n  return ArcGISIdentityManager.authorize.apply(ArcGISIdentityManager, arguments);\n};\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.exchangeAuthorizationCode}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.exchangeAuthorizationCode = function () {\n  console.warn(\"DEPRECATED:, 'UserSession.exchangeAuthorizationCode' is deprecated. Use 'ArcGISIdentityManager.exchangeAuthorizationCode' instead.\");\n  return ArcGISIdentityManager.exchangeAuthorizationCode.apply(ArcGISIdentityManager, arguments);\n};\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.fromCredential}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.fromCredential = function () {\n  console.log(\"DEPRECATED:, 'UserSession.fromCredential' is deprecated. Use 'ArcGISIdentityManager.fromCredential' instead.\");\n  console.warn(\"WARNING:, 'UserSession.fromCredential' now requires a `ServerInfo` object from the JS API as a second parameter.\");\n  return ArcGISIdentityManager.fromCredential.apply(ArcGISIdentityManager, arguments);\n};\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.deserialize}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.deserialize = function () {\n  console.log(\"DEPRECATED:, 'UserSession.deserialize' is deprecated. Use 'ArcGISIdentityManager.deserialize' instead.\");\n  return ArcGISIdentityManager.deserialize.apply(ArcGISIdentityManager, arguments);\n};\nexport { UserSession };","map":{"version":3,"names":["ArcGISAuthError","request","decodeQueryString","encodeQueryString","fetchToken","canUseOnlineToken","isFederated","validateAppAccess","cleanUrl","revokeToken","generateCodeChallenge","generateRandomString","ArcGISAccessDeniedError","ArcGISTokenRequestError","ArcGISTokenRequestErrorCodes","NODEJS_DEFAULT_REFERER_HEADER","ArcGISIdentityManager","options","_classCallCheck","clientId","_refreshToken","refreshToken","_refreshTokenExpires","refreshTokenExpires","_username","username","password","_token","token","_tokenExpires","tokenExpires","portal","ssl","provider","tokenDuration","redirectUri","server","referer","federatedServers","trustedDomains","root","getServerRootUrl","expires","_pendingTokenRequests","_createClass","key","get","_user","value","toCredential","getTime","userId","getUser","requestOptions","_this","_pendingUserRequest","Promise","resolve","url","concat","Object","assign","httpMethod","authentication","rawResponse","then","response","getPortal","_this2","_pendingPortalRequest","_portalInfo","getUsername","user","getToken","getFreshToken","RegExp","test","getTokenForServer","toJSON","undefined","serialize","JSON","stringify","enablePostMessageAuth","validChildOrigins","win","window","_hostHandler","createPostMessageHandler","addEventListener","disablePostMessageAuth","removeEventListener","refreshCredentials","refreshWithUsernameAndPassword","refreshWithRefreshToken","reject","TOKEN_REFRESH_FAILED","_cleanUrl$split","split","_cleanUrl$split2","_slicedToArray","_root$match","match","_root$match2","protocol","domainAndPath","_domainAndPath$split","_domainAndPath$split2","_toArray","domain","path","slice","toLowerCase","join","getDomainCredentials","length","some","domainWithProtocol","startsWith","signOut","destroy","validOrigins","_this3","event","isValidOrigin","indexOf","origin","isValidType","data","type","isTokenValid","Date","now","msg","credential","error","name","message","source","postMessage","_this4","existingToken","fetchAuthorizedDomains","credentials","serverInfo","owningSystemUrl","NOT_FEDERATED","authInfo","generateTokenForServer","tokenServicesUrl","serverUrl","params","expiration","catch","e","GENERATE_TOKEN_FOR_SERVER_FAILED","_this5","_this6","client","document","location","updateToken","_this7","ONE_DAY_IN_MILLISECONDS","exchangeRefreshToken","client_id","refresh_token","grant_type","newToken","newTokenExpiration","_this8","redirect_uri","REFRESH_TOKEN_EXCHANGE_FAILED","_this9","portalInfo","authorizedCrossOriginDomains","filter","d","map","beginOAuth2","_Object$assign","popup","popupWindowFeatures","locale","style","pkce","state","stateId","stateStorageKey","localStorage","setItem","authorizeUrl","authorizeUrlParams","response_type","id","originalUrl","href","socialLoginProviderName","autoAccountCreateForSocial","setupAuth","codeVerifier","codeVerifierStorageKey","codeChallenge","code_challenge_method","code_challenge","detail","errorMessage","once","open","dispatchEvent","CustomEvent","completeOAuth2","_Object$assign2","getItem","search","replace","hash","parse","reportError","removeItem","opener","close","history","replaceState","createManager","oauthInfo","error_description","code","tokenEndpoint","code_verifier","tokenResponse","originalMessage","access_token","parseInt","expires_in","fromParent","parentOrigin","handler","parent","parentMessageHandler","err","manager","authorize","_Object$assign3","queryParams","writeHead","Location","end","exchangeAuthorizationCode","authorizationCode","_Object$assign4","deserialize","str","fromCredential","hasServer","includes","Error","fromToken","signIn","UserSession","console","log","warn","apply","arguments"],"sources":["C:\\code-challenge-react\\node_modules\\@esri\\arcgis-rest-request\\src\\ArcGISIdentityManager.ts"],"sourcesContent":["/* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport * as http from \"http\";\nimport { ArcGISAuthError, request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\nimport { IAuthenticationManager } from \"./utils/IAuthenticationManager.js\";\nimport { ITokenRequestOptions } from \"./utils/ITokenRequestOptions.js\";\nimport { decodeQueryString } from \"./utils/decode-query-string.js\";\nimport { encodeQueryString } from \"./utils/encode-query-string.js\";\nimport { IUser } from \"./types/user.js\";\nimport { fetchToken, IFetchTokenResponse } from \"./fetch-token.js\";\nimport { canUseOnlineToken, isFederated } from \"./federation-utils.js\";\nimport { IAppAccess, validateAppAccess } from \"./validate-app-access.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\nimport { revokeToken } from \"./revoke-token.js\";\nimport { generateCodeChallenge } from \"./utils/generate-code-challenge.js\";\nimport { generateRandomString } from \"./utils/generate-random-string.js\";\nimport { ArcGISAccessDeniedError } from \"./utils/ArcGISAccessDeniedError.js\";\nimport {\n  ArcGISTokenRequestError,\n  ArcGISTokenRequestErrorCodes\n} from \"./utils/ArcGISTokenRequestError.js\";\nimport { NODEJS_DEFAULT_REFERER_HEADER } from \"./index.js\";\n\n/**\n * Options for {@linkcode ArcGISIdentityManager.fromToken}.\n */\nexport interface IFromTokenOptions {\n  /**\n   * The token you want to create the {@linkcode ArcGISIdentityManager} instance with.\n   */\n  token: string;\n  /**\n   * Date when this token will expire.\n   */\n  tokenExpires?: Date;\n  /**\n   * The portal that the token was generated from. Defaults to `https://www.arcgis.com/sharing/rest`. Required if you are not using the default portal.\n   */\n  portal?: string;\n  /**\n   * If the token is for a specific instance of ArcGIS Server, set `portal` to `null` or `undefined` and set `server` the URL of the ArcGIS Server.\n   */\n  server?: string;\n  /**\n   * Optionally set the username. Recommended if available.\n   */\n  username?: string;\n  /**\n   * Optional client ID. Used for refreshing expired tokens.\n   */\n  clientId?: string;\n  /**\n   * Optional set a valid redirect URL for the registered client ID. Used internally to refresh expired tokens.\n   */\n  redirectUri?: string;\n}\n\n/**\n * Options for {@linkcode ArcGISIdentityManager.signIn}.\n */\nexport interface ISignInOptions {\n  username: string;\n  password: string;\n  portal?: string;\n  referer?: string;\n}\n\nexport type AuthenticationProvider =\n  | \"arcgis\"\n  | \"facebook\"\n  | \"google\"\n  | \"github\"\n  | \"apple\";\n\n/**\n * Represents a [credential](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-Credential.html)\n * object used to access a secure ArcGIS resource.\n */\nexport interface ICredential {\n  expires: number;\n  server: string;\n  ssl: boolean;\n  token: string;\n  userId: string;\n}\n\n/**\n * Represents the [`ServerInfo`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-ServerInfo.html) class\n * in the ArcGIS API for JavaScript.\n */\nexport interface IServerInfo {\n  server: string;\n  hasPortal: boolean;\n  hasServer: boolean;\n  owningSystemUrl: string | null;\n}\n\n/**\n * Options for static OAuth 2.0 helper methods on `ArcGISIdentityManager`.\n */\nexport interface IOAuth2Options {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri: string;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * ArcGIS Authentication is used by default. Specifying an alternative will take users directly to the corresponding provider's OAuth page.\n   */\n\n  provider?: AuthenticationProvider;\n\n  /**\n   * The requested validity in minutes for a refresh token/access token. Defaults to 20160 (2 weeks).\n   *\n   * When using PKCE or server-based OAuth this will control the duration of the refresh token. In this scenario, access tokens will always have a 30 minute validity.\n   *\n   * When using implicit auth (`pkce: false`) in {@linkcode ArcGISIdentityManager.beginOAuth2}, this controls the duration of the access token and no refresh token will be granted.\n   */\n  expiration?: number;\n\n  /**\n   * If `true` will use the PKCE oAuth 2.0 extension spec in to authorize the user and obtain a token. A value of `false` will use the deprecated oAuth 2.0 implicit grant type.\n   *\n   * @browserOnly\n   */\n  pkce?: boolean;\n\n  /**\n   * Determines whether to open the authorization window in a new tab/window or in the current window.\n   *\n   * @browserOnly\n   */\n  popup?: boolean;\n\n  /**\n   * The window features passed to [window.open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) when `popup` is true. Defaults to `height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes`\n   *\n   * @browserOnly\n   */\n  popupWindowFeatures?: string;\n\n  /**\n   * The locale assumed to render the login page.\n   *\n   * @browserOnly\n   */\n  locale?: string;\n\n  /**\n   * Sets the color theme of the oAuth 2.0 authorization screen. Will use the system preference or a light theme by default.\n   */\n  style?: \"\" | \"light\" | \"dark\";\n\n  /**\n   * Custom value for oAuth 2.0 state. A random identifier will be generated if this is not passed.\n   */\n  state?: string;\n\n  [key: string]: any;\n}\n\n/**\n * Options for the {@linkcode ArcGISIdentityManager} constructor.\n */\nexport interface IArcGISIdentityManagerOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId?: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri?: string;\n\n  /**\n   * OAuth 2.0 refresh token.\n   */\n  refreshToken?: string;\n\n  /**\n   * Expiration date of the `refreshToken`\n   */\n  refreshTokenExpires?: Date;\n\n  /**\n   * The authenticated user's username. Guaranteed to be unique across ArcGIS Online or your instance of ArcGIS Enterprise.\n   */\n  username?: string;\n\n  /**\n   * Password for this user. Used in CLI apps where users cannot do OAuth 2.0.\n   */\n  password?: string;\n\n  /**\n   * OAuth 2.0 access token.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  tokenExpires?: Date;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * This value is set to true automatically if the ArcGIS Organization requires that requests be made over https.\n   */\n  ssl?: boolean;\n\n  /**\n   * ArcGIS Authentication is used by default. Specifying an alternative will take users directly to the corresponding provider's OAuth page.\n   */\n  provider?: AuthenticationProvider;\n\n  /**\n   * Duration of requested token validity in minutes. Used when requesting tokens with `username` and `password` or when validating the identity of unknown servers. Defaults to two weeks.\n   */\n  tokenDuration?: number;\n\n  /**\n   * An unfederated ArcGIS Server instance known to recognize credentials supplied manually.\n   *\n   * ```js\n   * {\n   *   server: \"https://sampleserver6.arcgisonline.com/arcgis\",\n   *   token: \"SOSlV3v..\",\n   *   tokenExpires: new Date(1545415669763)\n   * }\n   * ```\n   */\n  server?: string;\n\n  /**\n   * The referer to use when getting the token with `.signIn()`\n   */\n  referer?: string;\n}\n\n/**\n * Used to authenticate both ArcGIS Online and ArcGIS Enterprise users. `ArcGISIdentityManager` includes helper methods for [OAuth 2.0](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/oauth-2.0/) in both browser and server applications.\n *\n * **It is not recommended to construct `ArcGISIdentityManager` directly**. Instead there are several static methods used for specific workflows. The 2 primary workflows relate to oAuth 2.0:\n *\n * * {@linkcode ArcGISIdentityManager.beginOAuth2} and {@linkcode ArcGISIdentityManager.completeOAuth2()} for oAuth 2.0 in browser-only environment.\n * * {@linkcode ArcGISIdentityManager.authorize} and {@linkcode ArcGISIdentityManager.exchangeAuthorizationCode} for oAuth 2.0 for server-enabled application.\n *\n * Other more specialized helpers for less common workflows also exist:\n *\n * * {@linkcode ArcGISIdentityManager.fromToken} for when you have an existing token from another source and would like create an `ArcGISIdentityManager` instance.\n * * {@linkcode ArcGISIdentityManager.fromCredential} for creating  an `ArcGISIdentityManager` instance from a `Credentials` object in the ArcGIS JS API `IdentityManager`\n * * {@linkcode ArcGISIdentityManager.signIn} for authenticating directly with a user's username and password for environments with a user interface for oAuth 2.0.\n *\n * Once a manager is created there are additional utilities:\n *\n * * {@linkcode ArcGISIdentityManager.serialize} can be used to create a JSON object representing an instance of `ArcGISIdentityManager`\n * * {@linkcode ArcGISIdentityManager.deserialize} will create a new `ArcGISIdentityManager` from a JSON object created with {@linkcode ArcGISIdentityManager.serialize}\n * * {@linkcode ArcGISIdentityManager.destroy} or {@linkcode ArcGISIdentityManager.signOut} will invalidate any tokens in use by the  `ArcGISIdentityManager`.\n */\nexport class ArcGISIdentityManager implements IAuthenticationManager {\n  /**\n   * The current ArcGIS Online or ArcGIS Enterprise `token`.\n   */\n  get token() {\n    return this._token;\n  }\n\n  /**\n   * The expiration time of the current `token`.\n   */\n  get tokenExpires() {\n    return this._tokenExpires;\n  }\n\n  /**\n   * The current token to ArcGIS Online or ArcGIS Enterprise.\n   */\n  get refreshToken() {\n    return this._refreshToken;\n  }\n\n  /**\n   * The expiration time of the current `refreshToken`.\n   */\n  get refreshTokenExpires() {\n    return this._refreshTokenExpires;\n  }\n\n  /**\n   * The currently authenticated user.\n   */\n  get username() {\n    if (this._username) {\n      return this._username;\n    }\n\n    if (this._user && this._user.username) {\n      return this._user.username;\n    }\n  }\n\n  /**\n   * Returns `true` if these credentials can be refreshed and `false` if it cannot.\n   */\n  get canRefresh() {\n    if (this.username && this.password) {\n      return true;\n    }\n\n    if (this.clientId && this.refreshToken && this.redirectUri) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Begins a new browser-based OAuth 2.0 sign in. If `options.popup` is `true` the authentication window will open in a new tab/window. Otherwise, the user will be redirected to the authorization page in their current tab/window and the function will return `undefined`.\n   *\n   * If `popup` is `true` (the default) this method will return a `Promise` that resolves to an `ArcGISIdentityManager` instance and you must call {@linkcode ArcGISIdentityManager.completeOAuth2()} on the page defined in the `redirectUri`. Otherwise it will return undefined and the {@linkcode ArcGISIdentityManager.completeOAuth2()} method will return a `Promise` that resolves to an `ArcGISIdentityManager` instance.\n   *\n   * A {@linkcode ArcGISAccessDeniedError} error will be thrown if the user denies the request on the authorization screen.\n   *\n   * @browserOnly\n   */\n  public static beginOAuth2(\n    options: IOAuth2Options,\n    win?: any\n  ): Promise<ArcGISIdentityManager> | undefined {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n\n    const {\n      portal,\n      provider,\n      clientId,\n      expiration,\n      redirectUri,\n      popup,\n      popupWindowFeatures,\n      locale,\n      params,\n      style,\n      pkce,\n      state\n    }: IOAuth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\",\n        provider: \"arcgis\",\n        expiration: 20160,\n        popup: true,\n        popupWindowFeatures:\n          \"height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes\",\n        locale: \"\",\n        style: \"\",\n        pkce: true\n      },\n      ...options\n    };\n\n    /**\n     * Generate a  random string for the `state` param and store it in local storage. This is used\n     * to validate that all parts of the oAuth process were performed on the same client.\n     */\n    const stateId = state || generateRandomString(win);\n    const stateStorageKey = `ARCGIS_REST_JS_AUTH_STATE_${clientId}`;\n\n    win.localStorage.setItem(stateStorageKey, stateId);\n\n    // Start setting up the URL to the authorization screen.\n    let authorizeUrl = `${cleanUrl(portal)}/oauth2/authorize`;\n    const authorizeUrlParams: any = {\n      client_id: clientId,\n      response_type: pkce ? \"code\" : \"token\",\n      expiration: expiration,\n      redirect_uri: redirectUri,\n      state: JSON.stringify({\n        id: stateId,\n        originalUrl: win.location.href // this is used to reset the URL back the original URL upon return\n      }),\n      locale: locale,\n      style: style\n    };\n\n    // If we are authorizing through a specific social provider update the params and base URL.\n    if (provider !== \"arcgis\") {\n      authorizeUrl = `${cleanUrl(portal)}/oauth2/social/authorize`;\n      authorizeUrlParams.socialLoginProviderName = provider;\n      authorizeUrlParams.autoAccountCreateForSocial = true;\n    }\n\n    /**\n     * set a value that will be set to a promise which will later resolve when we are ready\n     * to send users to the authorization page.\n     */\n    let setupAuth;\n\n    if (pkce) {\n      /**\n       * If we are authenticating with PKCE we need to generate the code challenge which is\n       * async so we generate the code challenge and assign the resulting Promise to `setupAuth`\n       */\n      const codeVerifier = generateRandomString(win);\n      const codeVerifierStorageKey = `ARCGIS_REST_JS_CODE_VERIFIER_${clientId}`;\n\n      win.localStorage.setItem(codeVerifierStorageKey, codeVerifier);\n\n      setupAuth = generateCodeChallenge(codeVerifier, win).then(function (\n        codeChallenge\n      ) {\n        authorizeUrlParams.code_challenge_method = codeChallenge\n          ? \"S256\"\n          : \"plain\";\n\n        authorizeUrlParams.code_challenge = codeChallenge\n          ? codeChallenge\n          : codeVerifier;\n      });\n    } else {\n      /**\n       * If we aren't authenticating with PKCE we can just assign a resolved promise to `setupAuth`\n       */\n      setupAuth = Promise.resolve();\n    }\n\n    /**\n     * Once we are done setting up with (for PKCE) we can start the auth process.\n     */\n    return setupAuth.then(() => {\n      // combine the authorize URL and params\n      authorizeUrl = `${authorizeUrl}?${encodeQueryString(authorizeUrlParams)}`;\n\n      // append additional params passed by the user\n      if (params) {\n        authorizeUrl = `${authorizeUrl}&${encodeQueryString(params)}`;\n      }\n\n      if (popup) {\n        // If we are authenticating a popup we need to return a Promise that will resolve to an ArcGISIdentityManager later.\n        return new Promise((resolve, reject) => {\n          // Add an event listener to listen for when a user calls `ArcGISIdentityManager.completeOAuth2()` in the popup.\n          win.addEventListener(\n            `arcgis-rest-js-popup-auth-${clientId}`,\n            (e: CustomEvent<any>) => {\n              if (e.detail.error === \"access_denied\") {\n                const error = new ArcGISAccessDeniedError();\n                reject(error);\n                return error;\n              }\n\n              if (e.detail.errorMessage) {\n                const error = new ArcGISAuthError(\n                  e.detail.errorMessage,\n                  e.detail.error\n                );\n                reject(error);\n                return error;\n              }\n\n              resolve(\n                new ArcGISIdentityManager({\n                  clientId,\n                  portal,\n                  ssl: e.detail.ssl,\n                  token: e.detail.token,\n                  tokenExpires: e.detail.expires,\n                  username: e.detail.username,\n                  refreshToken: e.detail.refreshToken,\n                  refreshTokenExpires: e.detail.refreshTokenExpires,\n                  redirectUri\n                })\n              );\n            },\n            {\n              once: true\n            }\n          );\n\n          // open the popup\n          win.open(authorizeUrl, \"oauth-window\", popupWindowFeatures);\n\n          win.dispatchEvent(new CustomEvent(\"arcgis-rest-js-popup-auth-start\"));\n        });\n      } else {\n        // If we aren't authenticating with a popup just send the user to the authorization page.\n        win.location.href = authorizeUrl;\n        return undefined;\n      }\n    });\n  }\n\n  /**\n   * Completes a browser-based OAuth 2.0 sign in. If `options.popup` is `true` the user\n   * will be returned to the previous window and the popup will close. Otherwise a new `ArcGISIdentityManager` will be returned. You must pass the same values for `clientId`, `popup`, `portal`, and `pkce` as you used in `beginOAuth2()`.\n   *\n   * A {@linkcode ArcGISAccessDeniedError} error will be thrown if the user denies the request on the authorization screen.\n   * @browserOnly\n   */\n  public static completeOAuth2(options: IOAuth2Options, win?: any) {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n\n    // pull out necessary options\n    const { portal, clientId, popup, pkce, redirectUri }: IOAuth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\",\n        popup: true,\n        pkce: true\n      },\n      ...options\n    };\n\n    // pull the saved state id out of local storage\n    const stateStorageKey = `ARCGIS_REST_JS_AUTH_STATE_${clientId}`;\n    const stateId = win.localStorage.getItem(stateStorageKey);\n\n    // get the params provided by the server and compare the server state with the client saved state\n    const params = decodeQueryString(\n      pkce\n        ? win.location.search.replace(/^\\?/, \"\")\n        : win.location.hash.replace(/^#/, \"\")\n    );\n\n    const state = params && params.state ? JSON.parse(params.state) : undefined;\n\n    function reportError(\n      errorMessage: string,\n      error: string,\n      originalUrl?: string\n    ) {\n      win.localStorage.removeItem(stateStorageKey);\n\n      if (popup && win.opener) {\n        win.opener.dispatchEvent(\n          new CustomEvent(`arcgis-rest-js-popup-auth-${clientId}`, {\n            detail: {\n              error,\n              errorMessage\n            }\n          })\n        );\n\n        win.close();\n\n        return;\n      }\n\n      if (originalUrl) {\n        win.history.replaceState(win.history.state, \"\", originalUrl);\n      }\n\n      if (error === \"access_denied\") {\n        return Promise.reject(new ArcGISAccessDeniedError());\n      }\n\n      return Promise.reject(new ArcGISAuthError(errorMessage, error));\n    }\n\n    // create a function to create the final ArcGISIdentityManager from the token info.\n    function createManager(\n      oauthInfo: IFetchTokenResponse,\n      originalUrl: string\n    ) {\n      win.localStorage.removeItem(stateStorageKey);\n\n      if (popup && win.opener) {\n        win.opener.dispatchEvent(\n          new CustomEvent(`arcgis-rest-js-popup-auth-${clientId}`, {\n            detail: {\n              ...oauthInfo\n            }\n          })\n        );\n\n        win.close();\n\n        return;\n      }\n\n      win.history.replaceState(win.history.state, \"\", originalUrl);\n\n      return new ArcGISIdentityManager({\n        clientId,\n        portal,\n        ssl: oauthInfo.ssl,\n        token: oauthInfo.token,\n        tokenExpires: oauthInfo.expires,\n        username: oauthInfo.username,\n        refreshToken: oauthInfo.refreshToken,\n        refreshTokenExpires: oauthInfo.refreshTokenExpires,\n        // At 4.0.0 it was possible (in JS code) to not pass redirectUri and fallback to win.location.href, however this broke support for redirect URIs with query params.\n        // Now similar to 3.x.x you must pass the redirectUri parameter explicitly. See https://github.com/Esri/arcgis-rest-js/issues/995\n        redirectUri:\n          redirectUri ||\n          /* istanbul ignore next: TypeScript wont compile if we omit redirectUri */ location.href.replace(\n            location.search,\n            \"\"\n          )\n      });\n    }\n\n    if (!stateId || !state) {\n      return reportError(\n        \"No authentication state was found, call `ArcGISIdentityManager.beginOAuth2(...)` to start the authentication process.\",\n        \"no-auth-state\"\n      );\n    }\n\n    if (state.id !== stateId) {\n      return reportError(\n        \"Saved client state did not match server sent state.\",\n        \"mismatched-auth-state\"\n      );\n    }\n\n    if (params.error) {\n      const error = params.error;\n      const errorMessage = params.error_description || \"Unknown error\";\n\n      return reportError(errorMessage, error, state.originalUrl);\n    }\n    /**\n     * If we are using PKCE the authorization code will be in the query params.\n     * For implicit grants the token will be in the hash.\n     */\n    if (pkce && params.code) {\n      const tokenEndpoint = cleanUrl(`${portal}/oauth2/token/`);\n\n      const codeVerifierStorageKey = `ARCGIS_REST_JS_CODE_VERIFIER_${clientId}`;\n      const codeVerifier = win.localStorage.getItem(codeVerifierStorageKey);\n      win.localStorage.removeItem(codeVerifierStorageKey);\n\n      // exchange our auth code for a token + refresh token\n      return fetchToken(tokenEndpoint, {\n        httpMethod: \"POST\",\n        params: {\n          client_id: clientId,\n          code_verifier: codeVerifier,\n          grant_type: \"authorization_code\",\n          // using location.href here does not support query params but shipped with 4.0.0. See https://github.com/Esri/arcgis-rest-js/issues/995\n          redirect_uri:\n            redirectUri || location.href.replace(location.search, \"\"),\n          code: params.code\n        }\n      })\n        .then((tokenResponse) => {\n          return createManager(\n            { ...tokenResponse, ...state },\n            state.originalUrl\n          );\n        })\n        .catch((e) => {\n          return reportError(e.originalMessage, e.code, state.originalUrl);\n        });\n    }\n\n    if (!pkce && params.access_token) {\n      return Promise.resolve(\n        createManager(\n          {\n            token: params.access_token,\n            expires: new Date(\n              Date.now() + parseInt(params.expires_in, 10) * 1000\n            ),\n            ssl: params.ssl === \"true\",\n            username: params.username,\n            ...state\n          },\n          state.originalUrl\n        )\n      );\n    }\n\n    return reportError(\"Unknown error\", \"oauth-error\", state.originalUrl);\n  }\n\n  /**\n   * Request credentials information from the parent application\n   *\n   * When an application is embedded into another application via an IFrame, the embedded app can\n   * use `window.postMessage` to request credentials from the host application. This function wraps\n   * that behavior.\n   *\n   * The ArcGIS API for Javascript has this built into the Identity Manager as of the 4.19 release.\n   *\n   * Note: The parent application will not respond if the embedded app's origin is not:\n   * - the same origin as the parent or *.arcgis.com (JSAPI)\n   * - in the list of valid child origins (REST-JS)\n   *\n   *\n   * @param parentOrigin origin of the parent frame. Passed into the embedded application as `parentOrigin` query param\n   * @browserOnly\n   */\n  public static fromParent(parentOrigin: string, win?: any): Promise<any> {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n    // Declare handler outside of promise scope so we can detach it\n    let handler: (event: any) => void;\n    // return a promise that will resolve when the handler receives\n    // session information from the correct origin\n    return new Promise((resolve, reject) => {\n      // create an event handler that just wraps the parentMessageHandler\n      handler = (event: any) => {\n        // ensure we only listen to events from the parent\n        if (event.source === win.parent && event.data) {\n          try {\n            return resolve(ArcGISIdentityManager.parentMessageHandler(event));\n          } catch (err) {\n            return reject(err);\n          }\n        }\n      };\n      // add listener\n      win.addEventListener(\"message\", handler, false);\n      win.parent.postMessage(\n        { type: \"arcgis:auth:requestCredential\" },\n        parentOrigin\n      );\n    }).then((manager) => {\n      win.removeEventListener(\"message\", handler, false);\n      return manager;\n    });\n  }\n\n  /**\n   * Begins a new server-based OAuth 2.0 sign in. This will redirect the user to\n   * the ArcGIS Online or ArcGIS Enterprise authorization page.\n   *\n   * @nodeOnly\n   */\n  public static authorize(\n    options: IOAuth2Options,\n    response: http.ServerResponse\n  ) {\n    const { portal, clientId, expiration, redirectUri, state }: IOAuth2Options =\n      {\n        ...{ portal: \"https://arcgis.com/sharing/rest\", expiration: 20160 },\n        ...options\n      };\n\n    const queryParams: any = {\n      client_id: clientId,\n      expiration,\n      response_type: \"code\",\n      redirect_uri: redirectUri\n    };\n\n    if (state) {\n      queryParams.state = state;\n    }\n\n    const url = `${portal}/oauth2/authorize?${encodeQueryString(queryParams)}`;\n\n    response.writeHead(301, {\n      Location: url\n    });\n\n    response.end();\n  }\n\n  /**\n   * Completes the server-based OAuth 2.0 sign in process by exchanging the `authorizationCode`\n   * for a `access_token`.\n   *\n   * @nodeOnly\n   */\n  public static exchangeAuthorizationCode(\n    options: IOAuth2Options,\n    authorizationCode: string\n  ): Promise<ArcGISIdentityManager> {\n    const { portal, clientId, redirectUri }: IOAuth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\"\n      },\n      ...options\n    };\n\n    return fetchToken(`${portal}/oauth2/token`, {\n      params: {\n        grant_type: \"authorization_code\",\n        client_id: clientId,\n        redirect_uri: redirectUri,\n        code: authorizationCode\n      }\n    })\n      .then((response) => {\n        return new ArcGISIdentityManager({\n          clientId,\n          portal,\n          ssl: response.ssl,\n          redirectUri,\n          refreshToken: response.refreshToken,\n          refreshTokenExpires: response.refreshTokenExpires,\n          token: response.token,\n          tokenExpires: response.expires,\n          username: response.username\n        });\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.REFRESH_TOKEN_EXCHANGE_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  public static deserialize(str: string) {\n    const options = JSON.parse(str);\n    return new ArcGISIdentityManager({\n      clientId: options.clientId,\n      refreshToken: options.refreshToken,\n      refreshTokenExpires: options.refreshTokenExpires\n        ? new Date(options.refreshTokenExpires)\n        : undefined,\n      username: options.username,\n      password: options.password,\n      token: options.token,\n      tokenExpires: options.tokenExpires\n        ? new Date(options.tokenExpires)\n        : undefined,\n      portal: options.portal,\n      ssl: options.ssl,\n      tokenDuration: options.tokenDuration,\n      redirectUri: options.redirectUri,\n      server: options.server\n    });\n  }\n\n  /**\n   * Translates authentication from the format used in the [`IdentityManager` class in the ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-Credential.html).\n   *\n   * You will need to call both [`IdentityManger.findCredential`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#findCredential) and [`IdentityManger.findServerInfo`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#findServerInfo) to obtain both parameters for this method.\n   *\n   * This method can be used with {@linkcode ArcGISIdentityManager.toCredential} to interop with the ArcGIS API for JavaScript.\n   *\n   * ```js\n   * require([\"esri/id\"], (esriId) => {\n   *   const credential = esriId.findCredential(\"https://www.arcgis.com/sharing/rest\");\n   *   const serverInfo = esriId.findServerInfo(\"https://www.arcgis.com/sharing/rest\");\n   *\n   *   const manager = ArcGISIdentityManager.fromCredential(credential, serverInfo);\n   * });\n   * ```\n   *\n   * @returns ArcGISIdentityManager\n   */\n  public static fromCredential(\n    credential: ICredential,\n    serverInfo: IServerInfo\n  ) {\n    // At ArcGIS Online 9.1, credentials no longer include the ssl and expires properties\n    // Here, we provide default values for them to cover this condition\n    const ssl = typeof credential.ssl !== \"undefined\" ? credential.ssl : true;\n    const expires = credential.expires || Date.now() + 7200000; /* 2 hours */\n\n    if (serverInfo.hasServer) {\n      return new ArcGISIdentityManager({\n        server: credential.server,\n        ssl,\n        token: credential.token,\n        username: credential.userId,\n        tokenExpires: new Date(expires)\n      });\n    }\n    return new ArcGISIdentityManager({\n      portal: cleanUrl(\n        credential.server.includes(\"sharing/rest\")\n          ? credential.server\n          : credential.server + `/sharing/rest`\n      ),\n      ssl,\n      token: credential.token,\n      username: credential.userId,\n      tokenExpires: new Date(expires)\n    });\n  }\n\n  /**\n   * Handle the response from the parent\n   * @param event DOM Event\n   */\n  private static parentMessageHandler(event: any): ArcGISIdentityManager {\n    if (event.data.type === \"arcgis:auth:credential\") {\n      return new ArcGISIdentityManager(event.data.credential);\n    }\n    if (event.data.type === \"arcgis:auth:error\") {\n      const err = new Error(event.data.error.message);\n      err.name = event.data.error.name;\n      throw err;\n    } else {\n      throw new Error(\"Unknown message type.\");\n    }\n  }\n\n  /**\n   * Revokes all active tokens for a provided {@linkcode ArcGISIdentityManager}. The can be considered the equivalent to signing the user out of your application.\n   */\n  public static destroy(manager: ArcGISIdentityManager) {\n    return revokeToken({\n      clientId: manager.clientId,\n      portal: manager.portal,\n      token: manager.refreshToken || manager.token\n    });\n  }\n\n  /**\n   * Create a  {@linkcode ArcGISIdentityManager} from an existing token. Useful for when you have a users token from a different authentication system and want to get a  {@linkcode ArcGISIdentityManager}.\n   */\n  public static fromToken(\n    options: IFromTokenOptions\n  ): Promise<ArcGISIdentityManager> {\n    const manager = new ArcGISIdentityManager(options);\n\n    return manager.getUser().then(() => {\n      return manager;\n    });\n  }\n\n  /**\n   * Initialize a {@linkcode ArcGISIdentityManager} with a user's `username` and `password`. **This method is intended ONLY for applications without a user interface such as CLI tools.**.\n   *\n   * If possible you should use {@linkcode ArcGISIdentityManager.beginOAuth2} to authenticate users in a browser or {@linkcode ArcGISIdentityManager.authorize} for authenticating users with a web server.\n   */\n  public static signIn(options: ISignInOptions) {\n    const manager = new ArcGISIdentityManager(options);\n\n    return manager.getUser().then(() => {\n      return manager;\n    });\n  }\n\n  /**\n   * Client ID being used for authentication if provided in the `constructor`.\n   */\n  public readonly clientId: string;\n\n  /**\n   * The currently authenticated user's password if provided in the `constructor`.\n   */\n  public readonly password: string;\n\n  /**\n   * The current portal the user is authenticated with.\n   */\n  public readonly portal: string;\n\n  /**\n   * This value is set to true automatically if the ArcGIS Organization requires that requests be made over https.\n   */\n  public readonly ssl: boolean;\n\n  /**\n   * The authentication provider to use.\n   */\n  public readonly provider: AuthenticationProvider;\n\n  /**\n   * Determines how long new tokens requested are valid.\n   */\n  public readonly tokenDuration: number;\n\n  /**\n   * A valid redirect URI for this application if provided in the `constructor`.\n   */\n  public readonly redirectUri: string;\n\n  /**\n   * An unfederated ArcGIS Server instance known to recognize credentials supplied manually.\n   *\n   * ```js\n   * {\n   *   server: \"https://sampleserver6.arcgisonline.com/arcgis\",\n   *   token: \"SOSlV3v..\",\n   *   tokenExpires: new Date(1545415669763)\n   * }\n   * ```\n   */\n  public readonly server: string;\n\n  /**\n   * The referer to use when getting the token with `.signIn()`\n   */\n  public readonly referer: string;\n\n  /**\n   * Hydrated by a call to [getUser()](#getUser-summary).\n   */\n  private _user: IUser;\n\n  /**\n   * Hydrated by a call to [getPortal()](#getPortal-summary).\n   */\n  private _portalInfo: any;\n\n  private _token: string;\n  private _tokenExpires: Date;\n  private _refreshToken: string;\n  private _refreshTokenExpires: Date;\n  private _pendingUserRequest: Promise<IUser>;\n  private _pendingPortalRequest: Promise<any>;\n\n  /**\n   * Internal object to keep track of pending token requests. Used to prevent\n   *  duplicate token requests.\n   */\n  private _pendingTokenRequests: {\n    [key: string]: Promise<string>;\n  };\n\n  private _username: string;\n\n  /**\n   * Internal list of tokens to 3rd party servers (federated servers) that have\n   *  been created via `generateToken`. The object key is the root URL of the server.\n   */\n  private federatedServers: {\n    [key: string]: {\n      token: string;\n      expires: Date;\n    };\n  };\n\n  /**\n   * Internal list of 3rd party domains that should receive all cookies (credentials: \"include\").\n   * Used to for PKI and IWA workflows in high security environments.\n   */\n  private trustedDomains: string[];\n\n  private _hostHandler: any;\n\n  constructor(options: IArcGISIdentityManagerOptions) {\n    this.clientId = options.clientId;\n    this._refreshToken = options.refreshToken;\n    this._refreshTokenExpires = options.refreshTokenExpires;\n    this._username = options.username;\n    this.password = options.password;\n    this._token = options.token;\n    this._tokenExpires = options.tokenExpires;\n    this.portal = options.portal\n      ? cleanUrl(options.portal)\n      : \"https://www.arcgis.com/sharing/rest\";\n    this.ssl = options.ssl;\n    this.provider = options.provider || \"arcgis\";\n    this.tokenDuration = options.tokenDuration || 20160;\n    this.redirectUri = options.redirectUri;\n    this.server = options.server;\n    this.referer = options.referer;\n\n    this.federatedServers = {};\n    this.trustedDomains = [];\n\n    // if a non-federated server was passed explicitly, it should be trusted.\n    if (options.server) {\n      // if the url includes more than '/arcgis/', trim the rest\n      const root = this.getServerRootUrl(options.server);\n\n      this.federatedServers[root] = {\n        token: options.token,\n        expires: options.tokenExpires\n      };\n    }\n    this._pendingTokenRequests = {};\n  }\n\n  /**\n   * Returns authentication in a format useable in the [`IdentityManager.registerToken()` method in the ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#registerToken).\n   * \n   * This method can be used with {@linkcode ArcGISIdentityManager.fromCredential} to interop with the ArcGIS API for JavaScript.\n   *\n   * ```js\n   * require([\"esri/id\"], (esriId) => {\n   *   esriId.registerToken(manager.toCredential());\n   * })\n   \n   * ```\n   *\n   * @returns ICredential\n   */\n  public toCredential(): ICredential {\n    return {\n      expires: this.tokenExpires.getTime(),\n      server: this.server || this.portal,\n      ssl: this.ssl,\n      token: this.token,\n      userId: this.username\n    };\n  }\n\n  /**\n   * Returns information about the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic.\n   *\n   * ```js\n   * manager.getUser()\n   *   .then(response => {\n   *     console.log(response.role); // \"org_admin\"\n   *   })\n   * ```\n   *\n   * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n   * @returns A Promise that will resolve with the data from the response.\n   */\n  public getUser(requestOptions?: IRequestOptions): Promise<IUser> {\n    if (this._pendingUserRequest) {\n      return this._pendingUserRequest;\n    } else if (this._user) {\n      return Promise.resolve(this._user);\n    } else {\n      const url = `${this.portal}/community/self`;\n\n      const options = {\n        httpMethod: \"GET\",\n        authentication: this,\n        ...requestOptions,\n        rawResponse: false\n      } as IRequestOptions;\n\n      this._pendingUserRequest = request(url, options).then((response) => {\n        this._user = response;\n        this._pendingUserRequest = null;\n        return response;\n      });\n\n      return this._pendingUserRequest;\n    }\n  }\n\n  /**\n   * Returns information about the currently logged in user's [portal](https://developers.arcgis.com/rest/users-groups-and-items/portal-self.htm). Subsequent calls will *not* result in additional web traffic.\n   *\n   * ```js\n   * manager.getPortal()\n   *   .then(response => {\n   *     console.log(portal.name); // \"City of ...\"\n   *   })\n   * ```\n   *\n   * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n   * @returns A Promise that will resolve with the data from the response.\n   */\n  public getPortal(requestOptions?: IRequestOptions): Promise<any> {\n    if (this._pendingPortalRequest) {\n      return this._pendingPortalRequest;\n    } else if (this._portalInfo) {\n      return Promise.resolve(this._portalInfo);\n    } else {\n      const url = `${this.portal}/portals/self`;\n\n      const options = {\n        httpMethod: \"GET\",\n        authentication: this,\n        ...requestOptions,\n        rawResponse: false\n      } as IRequestOptions;\n\n      this._pendingPortalRequest = request(url, options).then((response) => {\n        this._portalInfo = response;\n        this._pendingPortalRequest = null;\n        return response;\n      });\n\n      return this._pendingPortalRequest;\n    }\n  }\n\n  /**\n   * Returns the username for the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic. This is also used internally when a username is required for some requests but is not present in the options.\n   *\n   * ```js\n   * manager.getUsername()\n   *   .then(response => {\n   *     console.log(response); // \"casey_jones\"\n   *   })\n   * ```\n   */\n  public getUsername() {\n    if (this.username) {\n      return Promise.resolve(this.username);\n    } else {\n      return this.getUser().then((user) => {\n        return user.username;\n      });\n    }\n  }\n\n  /**\n   * Gets an appropriate token for the given URL. If `portal` is ArcGIS Online and\n   * the request is to an ArcGIS Online domain `token` will be used. If the request\n   * is to the current `portal` the current `token` will also be used. However if\n   * the request is to an unknown server we will validate the server with a request\n   * to our current `portal`.\n   */\n  public getToken(url: string, requestOptions?: ITokenRequestOptions) {\n    if (canUseOnlineToken(this.portal, url)) {\n      return this.getFreshToken(requestOptions);\n    } else if (new RegExp(this.portal, \"i\").test(url)) {\n      return this.getFreshToken(requestOptions);\n    } else {\n      return this.getTokenForServer(url, requestOptions);\n    }\n  }\n\n  /**\n   * Get application access information for the current user\n   * see `validateAppAccess` function for details\n   *\n   * @param clientId application client id\n   */\n  public validateAppAccess(clientId: string): Promise<IAppAccess> {\n    return this.getToken(this.portal).then((token) => {\n      return validateAppAccess(token, clientId);\n    });\n  }\n\n  public toJSON(): IArcGISIdentityManagerOptions {\n    return {\n      clientId: this.clientId,\n      refreshToken: this.refreshToken,\n      refreshTokenExpires: this.refreshTokenExpires || undefined,\n      username: this.username,\n      password: this.password,\n      token: this.token,\n      tokenExpires: this.tokenExpires || undefined,\n      portal: this.portal,\n      ssl: this.ssl,\n      tokenDuration: this.tokenDuration,\n      redirectUri: this.redirectUri,\n      server: this.server\n    };\n  }\n\n  public serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * For a \"Host\" app that embeds other platform apps via iframes, after authenticating the user\n   * and creating a ArcGISIdentityManager, the app can then enable \"post message\" style authentication by calling\n   * this method.\n   *\n   * Internally this adds an event listener on window for the `message` event\n   *\n   * @param validChildOrigins Array of origins that are allowed to request authentication from the host app\n   */\n  public enablePostMessageAuth(validChildOrigins: string[], win?: any): any {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n    this._hostHandler = this.createPostMessageHandler(validChildOrigins);\n    win.addEventListener(\"message\", this._hostHandler, false);\n  }\n\n  /**\n   * For a \"Host\" app that has embedded other platform apps via iframes, when the host needs\n   * to transition routes, it should call `ArcGISIdentityManager.disablePostMessageAuth()` to remove\n   * the event listener and prevent memory leaks\n   */\n  public disablePostMessageAuth(win?: any) {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n    win.removeEventListener(\"message\", this._hostHandler, false);\n  }\n\n  /**\n   * Manually refreshes the current `token` and `tokenExpires`.\n   */\n  public refreshCredentials(requestOptions?: ITokenRequestOptions) {\n    // make sure subsequent calls to getUser() don't returned cached metadata\n    this._user = null;\n\n    if (this.username && this.password) {\n      return this.refreshWithUsernameAndPassword(requestOptions);\n    }\n\n    if (this.clientId && this.refreshToken) {\n      return this.refreshWithRefreshToken();\n    }\n\n    return Promise.reject(\n      new ArcGISTokenRequestError(\n        \"Unable to refresh token. No refresh token or password present.\",\n        ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED\n      )\n    );\n  }\n\n  /**\n   * Determines the root of the ArcGIS Server or Portal for a given URL.\n   *\n   * @param url the URl to determine the root url for.\n   */\n  public getServerRootUrl(url: string) {\n    const [root] = cleanUrl(url).split(\n      /\\/rest(\\/admin)?\\/services(?:\\/|#|\\?|$)/\n    );\n    const [match, protocol, domainAndPath] = root.match(/(https?:\\/\\/)(.+)/);\n    const [domain, ...path] = domainAndPath.split(\"/\");\n\n    // only the domain is lowercased because in some cases an org id might be\n    // in the path which cannot be lowercased.\n    return `${protocol}${domain.toLowerCase()}/${path.join(\"/\")}`;\n  }\n\n  /**\n   * Returns the proper [`credentials`] option for `fetch` for a given domain.\n   * See [trusted server](https://enterprise.arcgis.com/en/portal/latest/administer/windows/configure-security.htm#ESRI_SECTION1_70CC159B3540440AB325BE5D89DBE94A).\n   * Used internally by underlying request methods to add support for specific security considerations.\n   *\n   * @param url The url of the request\n   * @returns \"include\" or \"same-origin\"\n   */\n  public getDomainCredentials(url: string): RequestCredentials {\n    if (!this.trustedDomains || !this.trustedDomains.length) {\n      return \"same-origin\";\n    }\n\n    return this.trustedDomains.some((domainWithProtocol) => {\n      return url.startsWith(domainWithProtocol);\n    })\n      ? \"include\"\n      : \"same-origin\";\n  }\n\n  /**\n   * Convenience method for {@linkcode ArcGISIdentityManager.destroy} for this instance of `ArcGISIdentityManager`\n   */\n  public signOut() {\n    return ArcGISIdentityManager.destroy(this);\n  }\n\n  /**\n   * Return a function that closes over the validOrigins array and\n   * can be used as an event handler for the `message` event\n   *\n   * @param validOrigins Array of valid origins\n   */\n  private createPostMessageHandler(\n    validOrigins: string[]\n  ): (event: any) => void {\n    // return a function that closes over the validOrigins and\n    // has access to the credential\n    return (event: any) => {\n      // Verify that the origin is valid\n      // Note: do not use regex's here. validOrigins is an array so we're checking that the event's origin\n      // is in the array via exact match. More info about avoiding postMessage xss issues here\n      // https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html#tipsbypasses-in-postmessage-vulnerabilities\n      const isValidOrigin = validOrigins.indexOf(event.origin) > -1;\n      // JSAPI handles this slightly differently - instead of checking a list, it will respond if\n      // event.origin === window.location.origin || event.origin.endsWith('.arcgis.com')\n      // For Hub, and to enable cross domain debugging with port's in urls, we are opting to\n      // use a list of valid origins\n\n      // Ensure the message type is something we want to handle\n      const isValidType = event.data.type === \"arcgis:auth:requestCredential\";\n      // Ensure we don't pass an expired session forward\n      const isTokenValid = this.tokenExpires.getTime() > Date.now();\n\n      if (isValidOrigin && isValidType) {\n        let msg = {};\n        if (isTokenValid) {\n          const credential = this.toJSON();\n          msg = {\n            type: \"arcgis:auth:credential\",\n            credential\n          };\n        } else {\n          msg = {\n            type: \"arcgis:auth:error\",\n            error: {\n              name: \"tokenExpiredError\",\n              message:\n                \"Token was expired, and not returned to the child application\"\n            }\n          };\n        }\n\n        event.source.postMessage(msg, event.origin);\n      }\n    };\n  }\n\n  /**\n   * Validates that a given URL is properly federated with our current `portal`.\n   * Attempts to use the internal `federatedServers` cache first.\n   */\n  private getTokenForServer(\n    url: string,\n    requestOptions?: ITokenRequestOptions\n  ) {\n    // requests to /rest/services/ and /rest/admin/services/ are both valid\n    // Federated servers may have inconsistent casing, so lowerCase it\n    const root = this.getServerRootUrl(url);\n    const existingToken = this.federatedServers[root];\n\n    if (\n      existingToken &&\n      existingToken.expires &&\n      existingToken.expires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(existingToken.token);\n    }\n\n    if (this._pendingTokenRequests[root]) {\n      return this._pendingTokenRequests[root];\n    }\n\n    this._pendingTokenRequests[root] = this.fetchAuthorizedDomains().then(\n      () => {\n        return request(`${root}/rest/info`, {\n          credentials: this.getDomainCredentials(url)\n        })\n          .then((serverInfo) => {\n            if (serverInfo.owningSystemUrl) {\n              /**\n               * if this server is not owned by this portal\n               * bail out with an error since we know we wont\n               * be able to generate a token\n               */\n              if (!isFederated(serverInfo.owningSystemUrl, this.portal)) {\n                throw new ArcGISTokenRequestError(\n                  `${url} is not federated with ${this.portal}.`,\n                  ArcGISTokenRequestErrorCodes.NOT_FEDERATED\n                );\n              } else {\n                /**\n                 * if the server is federated, use the relevant token endpoint.\n                 */\n                return request(\n                  `${serverInfo.owningSystemUrl}/sharing/rest/info`,\n                  requestOptions\n                );\n              }\n            } else if (\n              serverInfo.authInfo &&\n              this.federatedServers[root] !== undefined\n            ) {\n              /**\n               * if its a stand-alone instance of ArcGIS Server that doesn't advertise\n               * federation, but the root server url is recognized, use its built in token endpoint.\n               */\n              return Promise.resolve({\n                authInfo: serverInfo.authInfo\n              });\n            } else {\n              throw new ArcGISTokenRequestError(\n                `${url} is not federated with any portal and is not explicitly trusted.`,\n                ArcGISTokenRequestErrorCodes.NOT_FEDERATED\n              );\n            }\n          })\n          .then((serverInfo: any) => {\n            // an expired token cant be used to generate a new token so refresh our credentials before trying to generate a server token\n            if (this.token && this.tokenExpires.getTime() < Date.now()) {\n              // If we are authenticated to a single server just refresh with username and password and use the new credentials as the credentials for this server.\n              if (this.server) {\n                return this.refreshCredentials().then(() => {\n                  return {\n                    token: this.token,\n                    expires: this.tokenExpires\n                  };\n                });\n              }\n\n              // Otherwise refresh the credentials for the portal and generate a URL for the specific server.\n              return this.refreshCredentials().then(() => {\n                return this.generateTokenForServer(\n                  serverInfo.authInfo.tokenServicesUrl,\n                  root\n                );\n              });\n            } else {\n              return this.generateTokenForServer(\n                serverInfo.authInfo.tokenServicesUrl,\n                root\n              );\n            }\n          })\n          .then((response) => {\n            this.federatedServers[root] = response;\n            delete this._pendingTokenRequests[root];\n            return response.token;\n          });\n      }\n    );\n\n    return this._pendingTokenRequests[root];\n  }\n\n  /**\n   * Generates a token for a given `serverUrl` using a given `tokenServicesUrl`.\n   */\n  private generateTokenForServer(tokenServicesUrl: string, serverUrl: string) {\n    return request(tokenServicesUrl, {\n      params: {\n        token: this.token,\n        serverUrl,\n        expiration: this.tokenDuration\n      }\n    })\n      .then((response) => {\n        return {\n          token: response.token,\n          expires: new Date(response.expires - 1000 * 60 * 5)\n        };\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.GENERATE_TOKEN_FOR_SERVER_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Returns an unexpired token for the current `portal`.\n   */\n  private getFreshToken(requestOptions?: ITokenRequestOptions) {\n    if (this.token && !this.tokenExpires) {\n      return Promise.resolve(this.token);\n    }\n\n    if (\n      this.token &&\n      this.tokenExpires &&\n      this.tokenExpires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(this.token);\n    }\n\n    if (!this._pendingTokenRequests[this.portal]) {\n      this._pendingTokenRequests[this.portal] = this.refreshCredentials(\n        requestOptions\n      ).then(() => {\n        this._pendingTokenRequests[this.portal] = null;\n        return this.token;\n      });\n    }\n\n    return this._pendingTokenRequests[this.portal];\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `username` and\n   * `password`.\n   */\n  private refreshWithUsernameAndPassword(\n    requestOptions?: ITokenRequestOptions\n  ) {\n    const params = {\n      username: this.username,\n      password: this.password,\n      expiration: this.tokenDuration,\n      client: \"referer\",\n      referer: this.referer\n        ? this.referer\n        : typeof window !== \"undefined\" &&\n          typeof window.document !== \"undefined\" &&\n          window.location &&\n          window.location.origin\n        ? window.location.origin\n        : /* istanbul ignore next */\n          NODEJS_DEFAULT_REFERER_HEADER\n    };\n\n    return (\n      this.server\n        ? request(`${this.getServerRootUrl(this.server)}/rest/info`).then(\n            (response) => {\n              return request(response.authInfo.tokenServicesUrl, {\n                params,\n                ...requestOptions\n              });\n            }\n          )\n        : request(`${this.portal}/generateToken`, {\n            params,\n            ...requestOptions\n          })\n    )\n      .then((response: any) => {\n        this.updateToken(response.token, new Date(response.expires));\n        return this;\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `refreshToken`.\n   */\n  private refreshWithRefreshToken(requestOptions?: ITokenRequestOptions) {\n    // If our refresh token expires sometime in the next 24 hours then refresh the refresh token\n    const ONE_DAY_IN_MILLISECONDS = 1000 * 60 * 60 * 24;\n\n    if (\n      this.refreshToken &&\n      this.refreshTokenExpires &&\n      this.refreshTokenExpires.getTime() - ONE_DAY_IN_MILLISECONDS < Date.now()\n    ) {\n      return this.exchangeRefreshToken(requestOptions);\n    }\n\n    const options: ITokenRequestOptions = {\n      params: {\n        client_id: this.clientId,\n        refresh_token: this.refreshToken,\n        grant_type: \"refresh_token\"\n      },\n      ...requestOptions\n    };\n\n    return fetchToken(`${this.portal}/oauth2/token`, options)\n      .then((response) => {\n        return this.updateToken(response.token, response.expires);\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Update the stored {@linkcode ArcGISIdentityManager.token} and {@linkcode ArcGISIdentityManager.tokenExpires} properties. This method is used internally when refreshing tokens.\n   * You may need to call this if you want update the token with a new token from an external source.\n   *\n   * @param newToken The new token to use for this instance of `ArcGISIdentityManager`.\n   * @param newTokenExpiration The new expiration date of the token.\n   * @returns\n   */\n  updateToken(newToken: string, newTokenExpiration: Date) {\n    this._token = newToken;\n    this._tokenExpires = newTokenExpiration;\n\n    return this;\n  }\n\n  /**\n   * Exchanges an unexpired `refreshToken` for a new one, also updates `token` and\n   * `tokenExpires`.\n   */\n  exchangeRefreshToken(requestOptions?: ITokenRequestOptions) {\n    const options: ITokenRequestOptions = {\n      params: {\n        client_id: this.clientId,\n        refresh_token: this.refreshToken,\n        redirect_uri: this.redirectUri,\n        grant_type: \"exchange_refresh_token\"\n      },\n      ...requestOptions\n    };\n\n    return fetchToken(`${this.portal}/oauth2/token`, options)\n      .then((response) => {\n        this._token = response.token;\n        this._tokenExpires = response.expires;\n        this._refreshToken = response.refreshToken;\n        this._refreshTokenExpires = response.refreshTokenExpires;\n        return this;\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.REFRESH_TOKEN_EXCHANGE_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * ensures that the authorizedCrossOriginDomains are obtained from the portal and cached\n   * so we can check them later.\n   *\n   * @returns this\n   */\n  private fetchAuthorizedDomains() {\n    // if this token is for a specific server or we don't have a portal\n    // don't get the portal info because we cant get the authorizedCrossOriginDomains\n    if (this.server || !this.portal) {\n      return Promise.resolve(this);\n    }\n\n    return this.getPortal().then((portalInfo) => {\n      /**\n       * Specific domains can be configured as secure.esri.com or https://secure.esri.com this\n       * normalizes to https://secure.esri.com so we can use startsWith later.\n       */\n      if (\n        portalInfo.authorizedCrossOriginDomains &&\n        portalInfo.authorizedCrossOriginDomains.length\n      ) {\n        this.trustedDomains = portalInfo.authorizedCrossOriginDomains\n          .filter((d: string) => !d.startsWith(\"http://\"))\n          .map((d: string) => {\n            if (d.startsWith(\"https://\")) {\n              return d;\n            } else {\n              return `https://${d}`;\n            }\n          });\n      }\n      return this;\n    });\n  }\n}\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager}.\n * @internal\n *\n */ /* istanbul ignore next */\nfunction UserSession(options: IArcGISIdentityManagerOptions) {\n  console.log(\n    \"DEPRECATED:, 'UserSession' is deprecated. Use 'ArcGISIdentityManager' instead.\"\n  );\n\n  return new ArcGISIdentityManager(options);\n}\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.beginOAuth2}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.beginOAuth2 = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.beginOAuth2>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.beginOAuth2' is deprecated. Use 'ArcGISIdentityManager.beginOAuth2' instead.\"\n  );\n\n  return ArcGISIdentityManager.beginOAuth2(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.completeOAuth2}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.completeOAuth2 = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.completeOAuth2>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.completeOAuth2()' is deprecated. Use 'ArcGISIdentityManager.completeOAuth2()' instead.\"\n  );\n  if (args.length <= 1) {\n    console.warn(\n      \"WARNING:, 'UserSession.completeOAuth2()' is now async and returns a promise the resolves to an instance of `ArcGISIdentityManager`.\"\n    );\n  }\n\n  return ArcGISIdentityManager.completeOAuth2(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.fromParent}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.fromParent = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.fromParent>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.fromParent' is deprecated. Use 'ArcGISIdentityManager.fromParent' instead.\"\n  );\n\n  return ArcGISIdentityManager.fromParent(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.authorize}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.authorize = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.authorize>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.authorize' is deprecated. Use 'ArcGISIdentityManager.authorize' instead.\"\n  );\n\n  return ArcGISIdentityManager.authorize(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.exchangeAuthorizationCode}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.exchangeAuthorizationCode = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.exchangeAuthorizationCode>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.exchangeAuthorizationCode' is deprecated. Use 'ArcGISIdentityManager.exchangeAuthorizationCode' instead.\"\n  );\n\n  return ArcGISIdentityManager.exchangeAuthorizationCode(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.fromCredential}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.fromCredential = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.fromCredential>\n) {\n  console.log(\n    \"DEPRECATED:, 'UserSession.fromCredential' is deprecated. Use 'ArcGISIdentityManager.fromCredential' instead.\"\n  );\n\n  console.warn(\n    \"WARNING:, 'UserSession.fromCredential' now requires a `ServerInfo` object from the JS API as a second parameter.\"\n  );\n\n  return ArcGISIdentityManager.fromCredential(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.deserialize}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.deserialize = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.deserialize>\n) {\n  console.log(\n    \"DEPRECATED:, 'UserSession.deserialize' is deprecated. Use 'ArcGISIdentityManager.deserialize' instead.\"\n  );\n\n  return ArcGISIdentityManager.deserialize(...args);\n};\n\nexport { UserSession };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}