{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { MARKER_TEXTURE_SIZE as e, MARKER_SYMBOL_SIZE as r, MARKER_TIP_THICKNESS_FACTOR as o } from \"../views/3d/support/engineContent/marker.js\";\nimport { addLinearDepth as i, addCalculateLinearDepth as a } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { ShaderOutput as t } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as n } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { RibbonVertexPosition as s } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { OutputDepth as l } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { MarkerSizing as c } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";\nimport { multipassTerrainTest as d } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { symbolAlphaCutoff as p } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as v } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { RgbaFloatEncoding as m } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { addProjViewLocalOrigin as g, addViewNormal as h } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as w } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as y } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as S } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as b } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as x } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { TransparencyPassType as P } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nimport { VertexAttribute as z } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { LineMarkerSpace as L, LineMarkerAnchor as j } from \"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";\nfunction C(C) {\n  const M = new b(),\n    D = C.hasMultipassTerrain && (C.output === t.Color || C.output === t.Alpha),\n    k = C.space === L.World;\n  C.hasTip && k && M.extensions.add(\"GL_OES_standard_derivatives\"), M.include(s, C), M.include(c, C), C.output === t.Depth && M.include(l, C);\n  const {\n    vertex: N,\n    fragment: T\n  } = M;\n  return T.include(m), g(N, C), M.attributes.add(z.POSITION, \"vec3\"), M.attributes.add(z.UV0, \"vec2\"), M.attributes.add(z.AUXPOS1, \"vec3\"), M.varyings.add(\"vColor\", \"vec4\"), M.varyings.add(\"vpos\", \"vec3\"), M.varyings.add(\"vUV\", \"vec2\"), M.varyings.add(\"vSize\", \"float\"), i(M), D && M.varyings.add(\"depth\", \"float\"), C.hasTip && M.varyings.add(\"vLineWidth\", \"float\"), N.uniforms.add([new f(\"nearFar\", (e, r) => r.camera.nearFar), new u(\"viewport\", (e, r) => r.camera.fullViewport)]), N.code.add(y`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), N.code.add(y`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`), k ? (M.attributes.add(z.NORMAL, \"vec3\"), h(N), N.constants.add(\"tiltThreshold\", \"float\", .7), N.code.add(y`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)) : N.code.add(y`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`), N.code.add(y`\n      #define vecN ${k ? \"vec3\" : \"vec2\"}\n\n      vecN normalizedSegment(vecN pos, vecN prev) {\n        vecN segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${k ? \"vec3(0.0, 0.0, 0.0)\" : \"vec2(0.0, 0.0)\"};\n      }\n\n      vecN displace(vecN pos, vecN prev, float displacementLen) {\n        vecN segment = normalizedSegment(pos, prev);\n\n        vecN displacementDirU = perpendicular(segment);\n        vecN displacementDirV = segment;\n\n        ${C.anchor === j.Tip ? \"pos -= 0.5 * displacementLen * displacementDirV;\" : \"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `), C.space === L.Screen && (N.uniforms.add(new S(\"inverseProjectionMatrix\", (e, r) => r.camera.inverseProjectionMatrix)), N.code.add(y`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`), N.code.add(y`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`), N.uniforms.add(new w(\"perScreenPixelRatio\", (e, r) => r.camera.perScreenPixelRatio)), N.code.add(y`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${C.hasCap ? \"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += perpendicular(diff) / 2.0;\\n                }\\n              \" : \"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)), N.uniforms.add(new w(\"pixelRatio\", (e, r) => r.camera.pixelRatio)), a(M), N.code.add(y`void main(void) {\nif (uv0.y == 0.0) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n}\nelse {\nfloat lineWidth = getLineWidth();\nfloat screenMarkerSize = getScreenMarkerSize();\nvec4 pos  = view * vec4(position.xyz, 1.0);\nvec4 prev = view * vec4(auxpos1.xyz, 1.0);\nclip(pos, prev);`), k ? (C.hideOnShortSegments && N.code.add(y`if (areWorldMarkersHidden(pos, prev)) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\nreturn;\n}`), N.code.add(y`pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\nvec4 displacedPosScreen = projectAndScale(pos);`)) : (N.code.add(y`vec4 posScreen = projectAndScale(pos);\nvec4 prevScreen = projectAndScale(prev);\nvec4 displacedPosScreen = posScreen;\ndisplacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);`), C.space === L.Screen && N.code.add(y`vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\nvec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\nvec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\npos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`)), N.code.add(y`\n        ${D ? \"depth = pos.z;\" : \"\"}\n        linearDepth = calculateLinearDepth(nearFar,pos.z);\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1]\n        vUV = (uv0 + 1.0) / 2.0;\n\n        ${k ? \"\" : \"vUV *= displacedPosScreen.w;\"}\n\n        ${C.hasTip ? \"vLineWidth = lineWidth;\" : \"\"}\n\n        vSize = screenMarkerSize;\n        vColor = getColor();\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `), D && M.include(d, C), M.include(n, C), T.uniforms.add([new u(\"intrinsicColor\", e => e.color), new x(\"tex\", e => e.texture)]), T.include(v), M.constants.add(\"texelSize\", \"float\", 1 / e), T.code.add(y`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`), C.hasTip && (M.constants.add(\"relativeMarkerSize\", \"float\", r / e), M.constants.add(\"relativeTipLineWidth\", \"float\", o), T.code.add(y`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${k ? \"halfTipLineWidth *= fwidth(samplePos.y);\" : \"\"}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `)), M.constants.add(\"symbolAlphaCutoff\", \"float\", p), T.code.add(y`\n  void main() {\n    discardBySlice(vpos);\n    ${D ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    ${k ? \"vec2 samplePos = vUV;\" : \"vec2 samplePos = vUV * gl_FragCoord.w;\"}\n\n    ${C.hasTip ? \"finalColor.a *= max(markerAlpha(samplePos), tipAlpha(samplePos));\" : \"finalColor.a *= markerAlpha(samplePos);\"}\n\n    ${C.output === t.ObjectAndLayerIdColor ? y`finalColor.a = 1.0;` : \"\"}\n\n    if (finalColor.a < symbolAlphaCutoff) {\n      discard;\n    }\n\n    ${C.output === t.Alpha ? y`gl_FragColor = vec4(finalColor.a);` : \"\"}\n    ${C.output === t.Color ? y`gl_FragColor = highlightSlice(finalColor, vpos);` : \"\"}\n    ${C.output === t.Color && C.transparencyPassType === P.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n    ${C.output === t.Highlight ? y`gl_FragColor = vec4(1.0);` : \"\"}\n    ${C.output === t.Depth ? y`outputDepth(linearDepth);` : \"\"}\n  }\n  `), M;\n}\nconst M = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: C\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { M as L, C as b };","map":{"version":3,"names":["MARKER_TEXTURE_SIZE","e","MARKER_SYMBOL_SIZE","r","MARKER_TIP_THICKNESS_FACTOR","o","addLinearDepth","i","addCalculateLinearDepth","a","ShaderOutput","t","SliceDraw","n","RibbonVertexPosition","s","OutputDepth","l","MarkerSizing","c","multipassTerrainTest","d","symbolAlphaCutoff","p","ColorConversion","v","RgbaFloatEncoding","m","addProjViewLocalOrigin","g","addViewNormal","h","Float2PassUniform","f","Float4PassUniform","u","FloatPassUniform","w","glsl","y","Matrix4PassUniform","S","ShaderBuilder","b","Texture2DPassUniform","x","TransparencyPassType","P","VertexAttribute","z","LineMarkerSpace","L","LineMarkerAnchor","j","C","M","D","hasMultipassTerrain","output","Color","Alpha","k","space","World","hasTip","extensions","add","include","Depth","vertex","N","fragment","T","attributes","POSITION","UV0","AUXPOS1","varyings","uniforms","camera","nearFar","fullViewport","code","NORMAL","constants","anchor","Tip","Screen","inverseProjectionMatrix","perScreenPixelRatio","hasCap","pixelRatio","hideOnShortSegments","color","texture","ObjectAndLayerIdColor","transparencyPassType","Highlight","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/LineMarker.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{MARKER_TEXTURE_SIZE as e,MARKER_SYMBOL_SIZE as r,MARKER_TIP_THICKNESS_FACTOR as o}from\"../views/3d/support/engineContent/marker.js\";import{addLinearDepth as i,addCalculateLinearDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as t}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as n}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as s}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as l}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{MarkerSizing as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";import{multipassTerrainTest as d}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as p}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as v}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{RgbaFloatEncoding as m}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{addProjViewLocalOrigin as g,addViewNormal as h}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as w}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as y}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as S}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as b}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as x}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{TransparencyPassType as P}from\"../views/3d/webgl-engine/lib/TransparencyPassType.js\";import{VertexAttribute as z}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{LineMarkerSpace as L,LineMarkerAnchor as j}from\"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";function C(C){const M=new b,D=C.hasMultipassTerrain&&(C.output===t.Color||C.output===t.Alpha),k=C.space===L.World;C.hasTip&&k&&M.extensions.add(\"GL_OES_standard_derivatives\"),M.include(s,C),M.include(c,C),C.output===t.Depth&&M.include(l,C);const{vertex:N,fragment:T}=M;return T.include(m),g(N,C),M.attributes.add(z.POSITION,\"vec3\"),M.attributes.add(z.UV0,\"vec2\"),M.attributes.add(z.AUXPOS1,\"vec3\"),M.varyings.add(\"vColor\",\"vec4\"),M.varyings.add(\"vpos\",\"vec3\"),M.varyings.add(\"vUV\",\"vec2\"),M.varyings.add(\"vSize\",\"float\"),i(M),D&&M.varyings.add(\"depth\",\"float\"),C.hasTip&&M.varyings.add(\"vLineWidth\",\"float\"),N.uniforms.add([new f(\"nearFar\",((e,r)=>r.camera.nearFar)),new u(\"viewport\",((e,r)=>r.camera.fullViewport))]),N.code.add(y`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),N.code.add(y`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`),k?(M.attributes.add(z.NORMAL,\"vec3\"),h(N),N.constants.add(\"tiltThreshold\",\"float\",.7),N.code.add(y`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)):N.code.add(y`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`),N.code.add(y`\n      #define vecN ${k?\"vec3\":\"vec2\"}\n\n      vecN normalizedSegment(vecN pos, vecN prev) {\n        vecN segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${k?\"vec3(0.0, 0.0, 0.0)\":\"vec2(0.0, 0.0)\"};\n      }\n\n      vecN displace(vecN pos, vecN prev, float displacementLen) {\n        vecN segment = normalizedSegment(pos, prev);\n\n        vecN displacementDirU = perpendicular(segment);\n        vecN displacementDirV = segment;\n\n        ${C.anchor===j.Tip?\"pos -= 0.5 * displacementLen * displacementDirV;\":\"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `),C.space===L.Screen&&(N.uniforms.add(new S(\"inverseProjectionMatrix\",((e,r)=>r.camera.inverseProjectionMatrix))),N.code.add(y`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`),N.code.add(y`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`),N.uniforms.add(new w(\"perScreenPixelRatio\",((e,r)=>r.camera.perScreenPixelRatio))),N.code.add(y`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${C.hasCap?\"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += perpendicular(diff) / 2.0;\\n                }\\n              \":\"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)),N.uniforms.add(new w(\"pixelRatio\",((e,r)=>r.camera.pixelRatio))),a(M),N.code.add(y`void main(void) {\nif (uv0.y == 0.0) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n}\nelse {\nfloat lineWidth = getLineWidth();\nfloat screenMarkerSize = getScreenMarkerSize();\nvec4 pos  = view * vec4(position.xyz, 1.0);\nvec4 prev = view * vec4(auxpos1.xyz, 1.0);\nclip(pos, prev);`),k?(C.hideOnShortSegments&&N.code.add(y`if (areWorldMarkersHidden(pos, prev)) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\nreturn;\n}`),N.code.add(y`pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\nvec4 displacedPosScreen = projectAndScale(pos);`)):(N.code.add(y`vec4 posScreen = projectAndScale(pos);\nvec4 prevScreen = projectAndScale(prev);\nvec4 displacedPosScreen = posScreen;\ndisplacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);`),C.space===L.Screen&&N.code.add(y`vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\nvec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\nvec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\npos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`)),N.code.add(y`\n        ${D?\"depth = pos.z;\":\"\"}\n        linearDepth = calculateLinearDepth(nearFar,pos.z);\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1]\n        vUV = (uv0 + 1.0) / 2.0;\n\n        ${k?\"\":\"vUV *= displacedPosScreen.w;\"}\n\n        ${C.hasTip?\"vLineWidth = lineWidth;\":\"\"}\n\n        vSize = screenMarkerSize;\n        vColor = getColor();\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `),D&&M.include(d,C),M.include(n,C),T.uniforms.add([new u(\"intrinsicColor\",(e=>e.color)),new x(\"tex\",(e=>e.texture))]),T.include(v),M.constants.add(\"texelSize\",\"float\",1/e),T.code.add(y`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`),C.hasTip&&(M.constants.add(\"relativeMarkerSize\",\"float\",r/e),M.constants.add(\"relativeTipLineWidth\",\"float\",o),T.code.add(y`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${k?\"halfTipLineWidth *= fwidth(samplePos.y);\":\"\"}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `)),M.constants.add(\"symbolAlphaCutoff\",\"float\",p),T.code.add(y`\n  void main() {\n    discardBySlice(vpos);\n    ${D?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    ${k?\"vec2 samplePos = vUV;\":\"vec2 samplePos = vUV * gl_FragCoord.w;\"}\n\n    ${C.hasTip?\"finalColor.a *= max(markerAlpha(samplePos), tipAlpha(samplePos));\":\"finalColor.a *= markerAlpha(samplePos);\"}\n\n    ${C.output===t.ObjectAndLayerIdColor?y`finalColor.a = 1.0;`:\"\"}\n\n    if (finalColor.a < symbolAlphaCutoff) {\n      discard;\n    }\n\n    ${C.output===t.Alpha?y`gl_FragColor = vec4(finalColor.a);`:\"\"}\n    ${C.output===t.Color?y`gl_FragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${C.output===t.Color&&C.transparencyPassType===P.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n    ${C.output===t.Highlight?y`gl_FragColor = vec4(1.0);`:\"\"}\n    ${C.output===t.Depth?y`outputDepth(linearDepth);`:\"\"}\n  }\n  `),M}const M=Object.freeze(Object.defineProperty({__proto__:null,build:C},Symbol.toStringTag,{value:\"Module\"}));export{M as L,C as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}