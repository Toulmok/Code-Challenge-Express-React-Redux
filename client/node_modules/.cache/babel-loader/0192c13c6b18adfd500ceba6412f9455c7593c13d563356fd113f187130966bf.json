{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { p as e } from \"./mat4.js\";\nimport { c as t } from \"./mat4f64.js\";\nimport { f as a } from \"./vec3f64.js\";\nimport { rayLeighScaleHeight as r, atmosphereHeight as i } from \"../views/3d/environment/atmosphereUtils.js\";\nimport { TextureCoordinateAttribute as o, TextureCoordinateAttributeType as s } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { ReadLinearDepth as n } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { Gamma as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";\nimport { addMainLightDirection as c } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";\nimport { Float2PassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { Float4PassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as g } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as u } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { VertexAttribute as y } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nconst x = a(parseFloat(Number(5802e-9).toFixed(6)), parseFloat(Number(13558e-9).toFixed(6)), parseFloat(Number(331e-7).toFixed(6))),\n  b = 3,\n  D = a(b * parseFloat(Number(65e-8).toFixed(6)), b * parseFloat(Number(1881e-9).toFixed(6)), b * parseFloat(Number(85e-9).toFixed(6))),\n  P = 3996e-9,\n  w = a(parseFloat(Number(x[0] + D[0]).toFixed(6)), parseFloat(Number(x[1] + D[1]).toFixed(6)), parseFloat(Number(x[2] + D[2]).toFixed(6)));\nfunction F(t) {\n  const a = new u();\n  a.attributes.add(y.POSITION, \"vec2\"), a.include(o, {\n    textureCoordinateType: s.Default\n  }), a.varyings.add(\"worldRay\", \"vec3\"), a.varyings.add(\"eyeDir\", \"vec3\");\n  const {\n    vertex: b,\n    fragment: D\n  } = a;\n  return b.uniforms.add([new f(\"inverseProjectionMatrix\", (e, t) => t.camera.inverseProjectionMatrix), new f(\"inverseViewMatrix\", (t, a) => e(S, a.camera.viewMatrix))]), b.code.add(g`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`), D.uniforms.add([new d(\"radii\", e => e.radii), new m(\"cameraPosition\", (e, t) => t.camera.eye), new h(\"heightParameters\", e => e.heightParameters), new p(\"innerFadeDistance\", e => e.innerFadeDistance), new p(\"altitudeFade\", e => e.altitudeFade), new v(\"depthTex\", e => e.depthTex), new p(\"hazeStrength\", e => e.hazeStrength)]), D.constants.add(\"betaRayleigh\", \"vec3\", x), D.constants.add(\"betaCombined\", \"vec3\", w), D.constants.add(\"betaMie\", \"float\", P), D.constants.add(\"scaleHeight\", \"float\", r * i), c(D), a.include(l), t.haze && (D.include(n), D.uniforms.add(new d(\"nearFar\", (e, t) => t.camera.nearFar))), D.code.add(g`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`), D.code.add(g`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`), D.code.add(g`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`), D.code.add(g`\n    const int STEPS = 6;\n\n    float getGlow(float dist, float radius, float intensity) {\n      return pow(radius / max(dist, 1e-6), intensity);\n    }\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze ? g`if (terrainDepth != -1.0) { end = terrainDepth; }` : \"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze ? g`` : \" mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * \"} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze ? \"\" : g`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.0596831 * mumu;\n\n      ${t.haze ? g`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;` : g`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.1193662 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie += getGlow(1.0 - mu, 5e-5, 3.0) * smoothstep(0.01, 0.1, length(scattering));\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n      if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n        return fragColor;\n      }\n\n      float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n      vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n      float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n      if (relDist > 1.0) {\n        return surfaceColor;\n      }\n\n      return mix(gl_FragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze ? g`\n          vec4 depthSample = texture2D(depthTex, vuv0).rgba;\n          if (depthSample != vec4(0)) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n            cameraSpaceRay *= -linearDepthFromTexture(depthTex, vuv0, nearFar);\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }` : g`\n          float depthSample = texture2D(depthTex, vuv0).r;\n          if (depthSample != 1.0) {\n            gl_FragColor = vec4(0);\n            return;\n          }`}\n\n      ${t.haze ? g`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != vec4(0)){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);\n            }\n            float alpha = 1.0 - fadeOut;` : g`\n            vec3 col = getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);;\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n      col = tonemapACES(col);\n      gl_FragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze ? \"\" : g`\n          if (depthSample == 1.0) {\n            gl_FragColor = applyUndergroundAtmosphere(rayDir, mainLightDirection, gl_FragColor);\n          }`}\n    }\n  `), a;\n}\nconst S = t(),\n  z = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    betaRayleigh: x,\n    build: F\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { z as C, F as a, x as b };","map":{"version":3,"names":["p","e","c","t","f","a","rayLeighScaleHeight","r","atmosphereHeight","i","TextureCoordinateAttribute","o","TextureCoordinateAttributeType","s","ReadLinearDepth","n","Gamma","l","addMainLightDirection","Float2PassUniform","d","Float3PassUniform","m","Float4PassUniform","h","FloatPassUniform","glsl","g","Matrix4PassUniform","ShaderBuilder","u","Texture2DPassUniform","v","VertexAttribute","y","x","parseFloat","Number","toFixed","b","D","P","w","F","attributes","add","POSITION","include","textureCoordinateType","Default","varyings","vertex","fragment","uniforms","camera","inverseProjectionMatrix","S","viewMatrix","code","radii","eye","heightParameters","innerFadeDistance","altitudeFade","depthTex","hazeStrength","constants","haze","nearFar","z","Object","freeze","defineProperty","__proto__","betaRayleigh","build","Symbol","toStringTag","value","C"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/ChapmanAtmosphere.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{p as e}from\"./mat4.js\";import{c as t}from\"./mat4f64.js\";import{f as a}from\"./vec3f64.js\";import{rayLeighScaleHeight as r,atmosphereHeight as i}from\"../views/3d/environment/atmosphereUtils.js\";import{TextureCoordinateAttribute as o,TextureCoordinateAttributeType as s}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{ReadLinearDepth as n}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{Gamma as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";import{addMainLightDirection as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{Float2PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float3PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{Float4PassUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as g}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as u}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as y}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";const x=a(parseFloat(Number(5802e-9).toFixed(6)),parseFloat(Number(13558e-9).toFixed(6)),parseFloat(Number(331e-7).toFixed(6))),b=3,D=a(b*parseFloat(Number(65e-8).toFixed(6)),b*parseFloat(Number(1881e-9).toFixed(6)),b*parseFloat(Number(85e-9).toFixed(6))),P=3996e-9,w=a(parseFloat(Number(x[0]+D[0]).toFixed(6)),parseFloat(Number(x[1]+D[1]).toFixed(6)),parseFloat(Number(x[2]+D[2]).toFixed(6)));function F(t){const a=new u;a.attributes.add(y.POSITION,\"vec2\"),a.include(o,{textureCoordinateType:s.Default}),a.varyings.add(\"worldRay\",\"vec3\"),a.varyings.add(\"eyeDir\",\"vec3\");const{vertex:b,fragment:D}=a;return b.uniforms.add([new f(\"inverseProjectionMatrix\",((e,t)=>t.camera.inverseProjectionMatrix)),new f(\"inverseViewMatrix\",((t,a)=>e(S,a.camera.viewMatrix)))]),b.code.add(g`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`),D.uniforms.add([new d(\"radii\",(e=>e.radii)),new m(\"cameraPosition\",((e,t)=>t.camera.eye)),new h(\"heightParameters\",(e=>e.heightParameters)),new p(\"innerFadeDistance\",(e=>e.innerFadeDistance)),new p(\"altitudeFade\",(e=>e.altitudeFade)),new v(\"depthTex\",(e=>e.depthTex)),new p(\"hazeStrength\",(e=>e.hazeStrength))]),D.constants.add(\"betaRayleigh\",\"vec3\",x),D.constants.add(\"betaCombined\",\"vec3\",w),D.constants.add(\"betaMie\",\"float\",P),D.constants.add(\"scaleHeight\",\"float\",r*i),c(D),a.include(l),t.haze&&(D.include(n),D.uniforms.add(new d(\"nearFar\",((e,t)=>t.camera.nearFar)))),D.code.add(g`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`),D.code.add(g`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`),D.code.add(g`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`),D.code.add(g`\n    const int STEPS = 6;\n\n    float getGlow(float dist, float radius, float intensity) {\n      return pow(radius / max(dist, 1e-6), intensity);\n    }\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze?g`if (terrainDepth != -1.0) { end = terrainDepth; }`:\"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze?g``:\" mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * \"} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze?\"\":g`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.0596831 * mumu;\n\n      ${t.haze?g`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;`:g`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.1193662 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie += getGlow(1.0 - mu, 5e-5, 3.0) * smoothstep(0.01, 0.1, length(scattering));\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n      if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n        return fragColor;\n      }\n\n      float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n      vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n      float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n      if (relDist > 1.0) {\n        return surfaceColor;\n      }\n\n      return mix(gl_FragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze?g`\n          vec4 depthSample = texture2D(depthTex, vuv0).rgba;\n          if (depthSample != vec4(0)) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n            cameraSpaceRay *= -linearDepthFromTexture(depthTex, vuv0, nearFar);\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }`:g`\n          float depthSample = texture2D(depthTex, vuv0).r;\n          if (depthSample != 1.0) {\n            gl_FragColor = vec4(0);\n            return;\n          }`}\n\n      ${t.haze?g`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != vec4(0)){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);\n            }\n            float alpha = 1.0 - fadeOut;`:g`\n            vec3 col = getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);;\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n      col = tonemapACES(col);\n      gl_FragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze?\"\":g`\n          if (depthSample == 1.0) {\n            gl_FragColor = applyUndergroundAtmosphere(rayDir, mainLightDirection, gl_FragColor);\n          }`}\n    }\n  `),a}const S=t(),z=Object.freeze(Object.defineProperty({__proto__:null,betaRayleigh:x,build:F},Symbol.toStringTag,{value:\"Module\"}));export{z as C,F as a,x as b};\n"],"mappings":"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E;AAC/kB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACa,CAAC,CAACkB,IAAI,CAACb,GAAG,CAAClB,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACa,CAAC,CAACkB,IAAI,CAACb,GAAG,CAAClB,CAAE;AACjB;AACA,EAAE,CAAC,EAACa,CAAC,CAACkB,IAAI,CAACb,GAAG,CAAClB,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQxB,CAAC,CAACgE,IAAI,GAACxC,CAAE,mDAAkD,GAAC,EAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0BxB,CAAC,CAACgE,IAAI,GAACxC,CAAE,EAAC,GAAC,2EAA4E;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYxB,CAAC,CAACgE,IAAI,GAAC,EAAE,GAACxC,CAAE,kEAAkE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQxB,CAAC,CAACgE,IAAI,GAACxC,CAAE,oEAAmE,GAACA,CAAE;AACvF;AACA;AACA;AACA;AACA;AACA,8GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQxB,CAAC,CAACgE,IAAI,GAACxC,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAACA,CAAE;AACf;AACA;AACA;AACA;AACA,YAAa;AACb;AACA,QAAQxB,CAAC,CAACgE,IAAI,GAACxC,CAAE;AACjB;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAACA,CAAE;AAC5C;AACA,8FAA+F;AAC/F;AACA;AACA,QAAQxB,CAAC,CAACgE,IAAI,GAAC,EAAE,GAACxC,CAAE;AACpB;AACA;AACA,YAAa;AACb;AACA,GAAG,CAAC,EAACtB,CAAC;AAAA;AAAC,MAAMmD,CAAC,GAACrD,CAAC,EAAE;EAACkE,CAAC,GAACC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;IAACC,SAAS,EAAC,IAAI;IAACC,YAAY,EAACvC,CAAC;IAACwC,KAAK,EAAChC;EAAC,CAAC,EAACiC,MAAM,CAACC,WAAW,EAAC;IAACC,KAAK,EAAC;EAAQ,CAAC,CAAC,CAAC;AAAC,SAAOT,CAAC,IAAIU,CAAC,EAACpC,CAAC,IAAItC,CAAC,EAAC8B,CAAC,IAAII,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}