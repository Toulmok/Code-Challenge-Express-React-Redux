{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { neverReached as n } from \"../../../../../../core/compilerUtils.js\";\nimport { EvaluateAmbientLighting as i } from \"./EvaluateAmbientLighting.glsl.js\";\nimport { EvaluateAmbientOcclusion as e } from \"./EvaluateAmbientOcclusion.glsl.js\";\nimport { addMainLightDirection as o, addMainLightIntensity as t, MainLighting as a } from \"./MainLighting.glsl.js\";\nimport { PhysicallyBasedRendering as r } from \"./PhysicallyBasedRendering.glsl.js\";\nimport { PBRMode as l } from \"./PhysicallyBasedRenderingParameters.glsl.js\";\nimport { PiUtils as c } from \"./PiUtils.glsl.js\";\nimport { BooleanPassUniform as d } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { FloatPassUniform as s } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as m } from \"../../shaderModules/interfaces.js\";\nimport { ambientBoost as g } from \"../../../lighting/SceneLighting.js\";\nfunction h(n) {\n  n.constants.add(\"ambientBoostFactor\", \"float\", g);\n}\nfunction u(n) {\n  n.uniforms.add(new s(\"lightingGlobalFactor\", (n, i) => i.lighting.globalFactor));\n}\nfunction p(g, p) {\n  const v = g.fragment;\n  switch (g.include(e, p), p.pbrMode !== l.Disabled && g.include(r, p), g.include(i, p), g.include(c), v.code.add(m`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${p.pbrMode === l.Disabled ? \"\" : \"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `), h(v), u(v), o(v), v.code.add(m`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${p.spherical ? m`normalize(vPosWorld)` : m`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `), t(v), v.code.add(m`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}`), p.pbrMode) {\n    case l.Disabled:\n    case l.WaterOnIntegratedMesh:\n    case l.Water:\n      g.include(a, p), v.code.add(m`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`);\n      break;\n    case l.Normal:\n    case l.Schematic:\n      v.code.add(m`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v.code.add(m`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p.useFillLights ? v.uniforms.add(new d(\"hasFillLights\", (n, i) => i.enableFillLights)) : v.constants.add(\"hasFillLights\", \"bool\", !1), v.code.add(m`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v.uniforms.add([new s(\"lightingSpecularStrength\", (n, i) => i.lighting.mainLight.specularStrength), new s(\"lightingEnvironmentStrength\", (n, i) => i.lighting.mainLight.environmentStrength)]), v.code.add(m`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v.code.add(m`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${p.pbrMode === l.Schematic ? m`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : m`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `);\n      break;\n    case l.Terrain:\n    case l.TerrainWithWater:\n      g.include(a, p), v.code.add(m`const float roughnessTerrain = 0.5;\nconst float specularityTerrain = 0.5;\nconst vec3 fresnelReflectionTerrain = vec3(0.04);\nvec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {\nvec3 viewDirection = -vd;\nvec3 h = normalize(viewDirection + mainLightDirection);\nfloat NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);\nfloat NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);\nfloat NdotH = clamp(dot(n, h), 0.0, 1.0);\nfloat NdotNG = clamp(dot(n, nup), -1.0, 1.0);\nvec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));\nfloat lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];\nvec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;\nvec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));\nvec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;\nvec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;\nvec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;\nvec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;\nvec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;\nvec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);\nvec3 specularColor = f0 * dfg.x + f90 * dfg.y;\nvec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;\nvec3 outColorLinear = outDiffColor + specularComponent;\nvec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));\nreturn outColor;\n}`);\n      break;\n    default:\n      n(p.pbrMode);\n    case l.COUNT:\n  }\n}\nexport { p as EvaluateSceneLighting, h as addAmbientBoostFactor, u as addLightingGlobalFactor };","map":{"version":3,"names":["neverReached","n","EvaluateAmbientLighting","i","EvaluateAmbientOcclusion","e","addMainLightDirection","o","addMainLightIntensity","t","MainLighting","a","PhysicallyBasedRendering","r","PBRMode","l","PiUtils","c","BooleanPassUniform","d","FloatPassUniform","s","glsl","m","ambientBoost","g","h","constants","add","u","uniforms","lighting","globalFactor","p","v","fragment","include","pbrMode","Disabled","code","spherical","WaterOnIntegratedMesh","Water","Normal","Schematic","useFillLights","enableFillLights","mainLight","specularStrength","environmentStrength","Terrain","TerrainWithWater","COUNT","EvaluateSceneLighting","addAmbientBoostFactor","addLightingGlobalFactor"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{neverReached as n}from\"../../../../../../core/compilerUtils.js\";import{EvaluateAmbientLighting as i}from\"./EvaluateAmbientLighting.glsl.js\";import{EvaluateAmbientOcclusion as e}from\"./EvaluateAmbientOcclusion.glsl.js\";import{addMainLightDirection as o,addMainLightIntensity as t,MainLighting as a}from\"./MainLighting.glsl.js\";import{PhysicallyBasedRendering as r}from\"./PhysicallyBasedRendering.glsl.js\";import{PBRMode as l}from\"./PhysicallyBasedRenderingParameters.glsl.js\";import{PiUtils as c}from\"./PiUtils.glsl.js\";import{BooleanPassUniform as d}from\"../../shaderModules/BooleanPassUniform.js\";import{FloatPassUniform as s}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as m}from\"../../shaderModules/interfaces.js\";import{ambientBoost as g}from\"../../../lighting/SceneLighting.js\";function h(n){n.constants.add(\"ambientBoostFactor\",\"float\",g)}function u(n){n.uniforms.add(new s(\"lightingGlobalFactor\",((n,i)=>i.lighting.globalFactor)))}function p(g,p){const v=g.fragment;switch(g.include(e,p),p.pbrMode!==l.Disabled&&g.include(r,p),g.include(i,p),g.include(c),v.code.add(m`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${p.pbrMode===l.Disabled?\"\":\"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `),h(v),u(v),o(v),v.code.add(m`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${p.spherical?m`normalize(vPosWorld)`:m`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `),t(v),v.code.add(m`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}`),p.pbrMode){case l.Disabled:case l.WaterOnIntegratedMesh:case l.Water:g.include(a,p),v.code.add(m`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`);break;case l.Normal:case l.Schematic:v.code.add(m`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),v.code.add(m`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),p.useFillLights?v.uniforms.add(new d(\"hasFillLights\",((n,i)=>i.enableFillLights))):v.constants.add(\"hasFillLights\",\"bool\",!1),v.code.add(m`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),v.uniforms.add([new s(\"lightingSpecularStrength\",((n,i)=>i.lighting.mainLight.specularStrength)),new s(\"lightingEnvironmentStrength\",((n,i)=>i.lighting.mainLight.environmentStrength))]),v.code.add(m`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`),v.code.add(m`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${p.pbrMode===l.Schematic?m`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`:m`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `);break;case l.Terrain:case l.TerrainWithWater:g.include(a,p),v.code.add(m`const float roughnessTerrain = 0.5;\nconst float specularityTerrain = 0.5;\nconst vec3 fresnelReflectionTerrain = vec3(0.04);\nvec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {\nvec3 viewDirection = -vd;\nvec3 h = normalize(viewDirection + mainLightDirection);\nfloat NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);\nfloat NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);\nfloat NdotH = clamp(dot(n, h), 0.0, 1.0);\nfloat NdotNG = clamp(dot(n, nup), -1.0, 1.0);\nvec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));\nfloat lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];\nvec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;\nvec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));\nvec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;\nvec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;\nvec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;\nvec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;\nvec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;\nvec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);\nvec3 specularColor = f0 * dfg.x + f90 * dfg.y;\nvec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;\nvec3 outColorLinear = outDiffColor + specularComponent;\nvec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));\nreturn outColor;\n}`);break;default:n(p.pbrMode);case l.COUNT:}}export{p as EvaluateSceneLighting,h as addAmbientBoostFactor,u as addLightingGlobalFactor};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,YAAY,IAAIC,CAAC,QAAK,yCAAyC;AAAC,SAAOC,uBAAuB,IAAIC,CAAC,QAAK,mCAAmC;AAAC,SAAOC,wBAAwB,IAAIC,CAAC,QAAK,oCAAoC;AAAC,SAAOC,qBAAqB,IAAIC,CAAC,EAACC,qBAAqB,IAAIC,CAAC,EAACC,YAAY,IAAIC,CAAC,QAAK,wBAAwB;AAAC,SAAOC,wBAAwB,IAAIC,CAAC,QAAK,oCAAoC;AAAC,SAAOC,OAAO,IAAIC,CAAC,QAAK,8CAA8C;AAAC,SAAOC,OAAO,IAAIC,CAAC,QAAK,mBAAmB;AAAC,SAAOC,kBAAkB,IAAIC,CAAC,QAAK,2CAA2C;AAAC,SAAOC,gBAAgB,IAAIC,CAAC,QAAK,yCAAyC;AAAC,SAAOC,IAAI,IAAIC,CAAC,QAAK,mCAAmC;AAAC,SAAOC,YAAY,IAAIC,CAAC,QAAK,oCAAoC;AAAC,SAASC,CAACA,CAACzB,CAAC,EAAC;EAACA,CAAC,CAAC0B,SAAS,CAACC,GAAG,CAAC,oBAAoB,EAAC,OAAO,EAACH,CAAC,CAAC;AAAA;AAAC,SAASI,CAACA,CAAC5B,CAAC,EAAC;EAACA,CAAC,CAAC6B,QAAQ,CAACF,GAAG,CAAC,IAAIP,CAAC,CAAC,sBAAsB,EAAE,CAACpB,CAAC,EAACE,CAAC,KAAGA,CAAC,CAAC4B,QAAQ,CAACC,YAAY,CAAE,CAAC;AAAA;AAAC,SAASC,CAACA,CAACR,CAAC,EAACQ,CAAC,EAAC;EAAC,MAAMC,CAAC,GAACT,CAAC,CAACU,QAAQ;EAAC,QAAOV,CAAC,CAACW,OAAO,CAAC/B,CAAC,EAAC4B,CAAC,CAAC,EAACA,CAAC,CAACI,OAAO,KAAGtB,CAAC,CAACuB,QAAQ,IAAEb,CAAC,CAACW,OAAO,CAACvB,CAAC,EAACoB,CAAC,CAAC,EAACR,CAAC,CAACW,OAAO,CAACjC,CAAC,EAAC8B,CAAC,CAAC,EAACR,CAAC,CAACW,OAAO,CAACnB,CAAC,CAAC,EAACiB,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACvkC;AACA;AACA,MAAMU,CAAC,CAACI,OAAO,KAAGtB,CAAC,CAACuB,QAAQ,GAAC,EAAE,GAAC,4CAA6C;AAC7E,GAAG,CAAC,EAACZ,CAAC,CAACQ,CAAC,CAAC,EAACL,CAAC,CAACK,CAAC,CAAC,EAAC3B,CAAC,CAAC2B,CAAC,CAAC,EAACA,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACjC;AACA,yBAAyBU,CAAC,CAACO,SAAS,GAACjB,CAAE,sBAAqB,GAACA,CAAE,qBAAqB;AACpF;AACA;AACA,GAAG,CAAC,EAACd,CAAC,CAACyB,CAAC,CAAC,EAACA,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACvB;AACA;AACA,EAAE,CAAC,EAACU,CAAC,CAACI,OAAO;IAAE,KAAKtB,CAAC,CAACuB,QAAQ;IAAC,KAAKvB,CAAC,CAAC0B,qBAAqB;IAAC,KAAK1B,CAAC,CAAC2B,KAAK;MAACjB,CAAC,CAACW,OAAO,CAACzB,CAAC,EAACsB,CAAC,CAAC,EAACC,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC;MAAC;IAAM,KAAKR,CAAC,CAAC4B,MAAM;IAAC,KAAK5B,CAAC,CAAC6B,SAAS;MAACV,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,CAAC,EAACW,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACvE;AACA,gGAAgG,CAAC,EAACU,CAAC,CAACY,aAAa,GAACX,CAAC,CAACJ,QAAQ,CAACF,GAAG,CAAC,IAAIT,CAAC,CAAC,eAAe,EAAE,CAAClB,CAAC,EAACE,CAAC,KAAGA,CAAC,CAAC2C,gBAAgB,CAAE,CAAC,GAACZ,CAAC,CAACP,SAAS,CAACC,GAAG,CAAC,eAAe,EAAC,MAAM,EAAC,CAAC,CAAC,CAAC,EAACM,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AAC7O;AACA;AACA;AACA;AACA;AACA;AACA,yJAAyJ,CAAC,EAACW,CAAC,CAACJ,QAAQ,CAACF,GAAG,CAAC,CAAC,IAAIP,CAAC,CAAC,0BAA0B,EAAE,CAACpB,CAAC,EAACE,CAAC,KAAGA,CAAC,CAAC4B,QAAQ,CAACgB,SAAS,CAACC,gBAAgB,CAAE,EAAC,IAAI3B,CAAC,CAAC,6BAA6B,EAAE,CAACpB,CAAC,EAACE,CAAC,KAAGA,CAAC,CAAC4B,QAAQ,CAACgB,SAAS,CAACE,mBAAmB,CAAE,CAAC,CAAC,EAACf,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AAClW;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,CAAC,EAACW,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AACnH;AACA;AACA;AACA;AACA,UAAUU,CAAC,CAACI,OAAO,KAAGtB,CAAC,CAAC6B,SAAS,GAACrB,CAAE,oHAAmH,GAACA,CAAE,+FAA+F;AACzP;AACA;AACA,KAAK,CAAC;MAAC;IAAM,KAAKR,CAAC,CAACmC,OAAO;IAAC,KAAKnC,CAAC,CAACoC,gBAAgB;MAAC1B,CAAC,CAACW,OAAO,CAACzB,CAAC,EAACsB,CAAC,CAAC,EAACC,CAAC,CAACK,IAAI,CAACX,GAAG,CAACL,CAAE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC;MAAC;IAAM;MAAQtB,CAAC,CAACgC,CAAC,CAACI,OAAO,CAAC;IAAC,KAAKtB,CAAC,CAACqC,KAAK;EAAC;AAAC;AAAC,SAAOnB,CAAC,IAAIoB,qBAAqB,EAAC3B,CAAC,IAAI4B,qBAAqB,EAACzB,CAAC,IAAI0B,uBAAuB"},"metadata":{},"sourceType":"module","externalDependencies":[]}