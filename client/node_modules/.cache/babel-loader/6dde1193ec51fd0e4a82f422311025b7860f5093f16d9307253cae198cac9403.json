{"ast":null,"code":"import _classCallCheck from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\nimport { encodeFormData } from \"./utils/encode-form-data.js\";\nimport { encodeQueryString } from \"./utils/encode-query-string.js\";\nimport { requiresFormData } from \"./utils/process-params.js\";\nimport { ArcGISRequestError } from \"./utils/ArcGISRequestError.js\";\nimport { warn } from \"./utils/warn.js\";\nimport { getFetch } from \"@esri/arcgis-rest-fetch\";\nexport var NODEJS_DEFAULT_REFERER_HEADER = \"@esri/arcgis-rest-js\";\n/**\n * Sets the default options that will be passed in **all requests across all `@esri/arcgis-rest-js` modules**.\n *\n * ```js\n * import { setDefaultRequestOptions } from \"@esri/arcgis-rest-request\";\n *\n * setDefaultRequestOptions({\n *   authentication: ArcGISIdentityManager // all requests will use this session by default\n * })\n * ```\n *\n * You should **never** set a default `authentication` when you are in a server side environment where you may be handling requests for many different authenticated users.\n *\n * @param options The default options to pass with every request. Existing default will be overwritten.\n * @param hideWarnings Silence warnings about setting default `authentication` in shared environments.\n */\nexport function setDefaultRequestOptions(options, hideWarnings) {\n  if (options.authentication && !hideWarnings) {\n    warn(\"You should not set `authentication` as a default in a shared environment such as a web server which will process multiple users requests. You can call `setDefaultRequestOptions` with `true` as a second argument to disable this warning.\");\n  }\n  globalThis.DEFAULT_ARCGIS_REQUEST_OPTIONS = options;\n}\nexport function getDefaultRequestOptions() {\n  return globalThis.DEFAULT_ARCGIS_REQUEST_OPTIONS || {\n    httpMethod: \"POST\",\n    params: {\n      f: \"json\"\n    }\n  };\n}\n/**\n * This error is thrown when a request encounters an invalid token error. Requests that use {@linkcode ArcGISIdentityManager} or\n * {@linkcode ApplicationCredentialsManager} in the `authentication` option the authentication manager will automatically try to generate\n * a fresh token using either {@linkcode ArcGISIdentityManager.refreshCredentials} or\n * {@linkcode ApplicationCredentialsManager.refreshCredentials}. If the request with the new token fails you will receive an `ArcGISAuthError`\n * if refreshing the token fails you will receive an instance of {@linkcode ArcGISTokenRequestError}.\n *\n * ```js\n * request(someUrl, {\n *   authentication: identityManager,\n *   // some additional options...\n * }).catch(e => {\n *   if(e.name === \"ArcGISAuthError\") {\n *     console.log(\"Request with a new token failed you might want to have the user authorize again.\")\n *   }\n *\n *   if(e.name === \"ArcGISTokenRequestError\") {\n *     console.log(\"There was an error refreshing the token you might want to have the user authorize again.\")\n *   }\n * })\n * ```\n */\nexport var ArcGISAuthError = /*#__PURE__*/function (_ArcGISRequestError) {\n  _inherits(ArcGISAuthError, _ArcGISRequestError);\n  var _super = _createSuper(ArcGISAuthError);\n  /**\n   * Create a new `ArcGISAuthError`  object.\n   *\n   * @param message - The error message from the API\n   * @param code - The error code from the API\n   * @param response - The original response from the API that caused the error\n   * @param url - The original url of the request\n   * @param options - The original options of the request\n   */\n  function ArcGISAuthError() {\n    var _this;\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"AUTHENTICATION_ERROR\";\n    var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"AUTHENTICATION_ERROR_CODE\";\n    var response = arguments.length > 2 ? arguments[2] : undefined;\n    var url = arguments.length > 3 ? arguments[3] : undefined;\n    var options = arguments.length > 4 ? arguments[4] : undefined;\n    _classCallCheck(this, ArcGISAuthError);\n    _this = _super.call(this, message, code, response, url, options);\n    _this.name = \"ArcGISAuthError\";\n    _this.message = code === \"AUTHENTICATION_ERROR_CODE\" ? message : \"\".concat(code, \": \").concat(message);\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    var actualProto = (this instanceof ArcGISAuthError ? this.constructor : void 0).prototype;\n    Object.setPrototypeOf(_assertThisInitialized(_this), actualProto);\n    return _this;\n  }\n  _createClass(ArcGISAuthError, [{\n    key: \"retry\",\n    value: function retry(getSession) {\n      var _this2 = this;\n      var retryLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var tries = 0;\n      var retryRequest = function retryRequest(resolve, reject) {\n        tries = tries + 1;\n        getSession(_this2.url, _this2.options).then(function (session) {\n          var newOptions = Object.assign(Object.assign({}, _this2.options), {\n            authentication: session\n          });\n          return internalRequest(_this2.url, newOptions);\n        }).then(function (response) {\n          resolve(response);\n        }).catch(function (e) {\n          if (e.name === \"ArcGISAuthError\" && tries < retryLimit) {\n            retryRequest(resolve, reject);\n          } else if (e.name === _this2.name && e.message === _this2.message && tries >= retryLimit) {\n            reject(_this2);\n          } else {\n            reject(e);\n          }\n        });\n      };\n      return new Promise(function (resolve, reject) {\n        retryRequest(resolve, reject);\n      });\n    }\n  }]);\n  return ArcGISAuthError;\n}(ArcGISRequestError);\n/**\n * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.\n *\n * @param data The response JSON to check for errors.\n * @param url The url of the original request\n * @param params The parameters of the original request\n * @param options The options of the original request\n * @returns The data that was passed in the `data` parameter\n */\nexport function checkForErrors(response, url, params, options, originalAuthError) {\n  // this is an error message from billing.arcgis.com backend\n  if (response.code >= 400) {\n    var message = response.message,\n      code = response.code;\n    throw new ArcGISRequestError(message, code, response, url, options);\n  }\n  // error from ArcGIS Online or an ArcGIS Portal or server instance.\n  if (response.error) {\n    var _response$error = response.error,\n      _message = _response$error.message,\n      _code = _response$error.code,\n      messageCode = _response$error.messageCode;\n    var errorCode = messageCode || _code || \"UNKNOWN_ERROR_CODE\";\n    if (_code === 498 || _code === 499) {\n      if (originalAuthError) {\n        throw originalAuthError;\n      } else {\n        throw new ArcGISAuthError(_message, errorCode, response, url, options);\n      }\n    }\n    throw new ArcGISRequestError(_message, errorCode, response, url, options);\n  }\n  // error from a status check\n  if (response.status === \"failed\" || response.status === \"failure\") {\n    var _message2;\n    var _code2 = \"UNKNOWN_ERROR_CODE\";\n    try {\n      _message2 = JSON.parse(response.statusMessage).message;\n      _code2 = JSON.parse(response.statusMessage).code;\n    } catch (e) {\n      _message2 = response.statusMessage || response.message;\n    }\n    throw new ArcGISRequestError(_message2, _code2, response, url, options);\n  }\n  return response;\n}\n/**\n * This is the internal implementation of `request` without the automatic retry behavior to prevent\n * infinite loops when a server continues to return invalid token errors.\n *\n * @param url - The URL of the ArcGIS REST API endpoint.\n * @param requestOptions - Options for the request, including parameters relevant to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n * @internal\n */\nexport function internalRequest(url, requestOptions) {\n  var defaults = getDefaultRequestOptions();\n  var options = Object.assign(Object.assign(Object.assign({\n    httpMethod: \"POST\"\n  }, defaults), requestOptions), {\n    params: Object.assign(Object.assign({}, defaults.params), requestOptions.params),\n    headers: Object.assign(Object.assign({}, defaults.headers), requestOptions.headers)\n  });\n  var httpMethod = options.httpMethod,\n    rawResponse = options.rawResponse;\n  var params = Object.assign({\n    f: \"json\"\n  }, options.params);\n  var originalAuthError = null;\n  var fetchOptions = {\n    method: httpMethod,\n    signal: options.signal,\n    /* ensures behavior mimics XMLHttpRequest.\n    needed to support sending IWA cookies */\n    credentials: options.credentials || \"same-origin\"\n  };\n  // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header\n  // and that request needs to send cookies cross domain\n  // so we need to set the credentials to \"include\"\n  if (options.headers && options.headers[\"X-Esri-Auth-Client-Id\"] && url.indexOf(\"/oauth2/platformSelf\") > -1) {\n    fetchOptions.credentials = \"include\";\n  }\n  var authentication;\n  // Check to see if this is a raw token as a string and create a IAuthenticationManager like object for it.\n  // Otherwise this just assumes that options.authentication is an IAuthenticationManager.\n  if (typeof options.authentication === \"string\") {\n    var rawToken = options.authentication;\n    authentication = {\n      portal: \"https://www.arcgis.com/sharing/rest\",\n      getToken: function getToken() {\n        return Promise.resolve(rawToken);\n      }\n    };\n    /* istanbul ignore else - we don't need to test NOT warning people */\n    if (!options.authentication.startsWith(\"AAPK\") &&\n    // doesn't look like an API Key\n    !options.suppressWarnings &&\n    // user doesn't want to suppress warnings for this request\n    !globalThis.ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING // we havn't shown the user this warning yet\n    ) {\n      warn(\"Using an oAuth 2.0 access token directly in the token option is discouraged. Consider using ArcGISIdentityManager or Application session. See https://esriurl.com/arcgis-rest-js-direct-token-warning for more information.\");\n      globalThis.ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING = true;\n    }\n  } else {\n    authentication = options.authentication;\n  }\n  // for errors in GET requests we want the URL passed to the error to be the URL before\n  // query params are applied.\n  var originalUrl = url;\n  return (authentication ? authentication.getToken(url).catch(function (err) {\n    /**\n     * append original request url and requestOptions\n     * to the error thrown by getToken()\n     * to assist with retrying\n     */\n    err.url = url;\n    err.options = options;\n    /**\n     * if an attempt is made to talk to an unfederated server\n     * first try the request anonymously. if a 'token required'\n     * error is thrown, throw the UNFEDERATED error then.\n     */\n    originalAuthError = err;\n    return Promise.resolve(\"\");\n  }) : Promise.resolve(\"\")).then(function (token) {\n    if (token.length) {\n      params.token = token;\n    }\n    if (authentication && authentication.getDomainCredentials) {\n      fetchOptions.credentials = authentication.getDomainCredentials(url);\n    }\n    // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.\n    var requestHeaders = {};\n    if (fetchOptions.method === \"GET\") {\n      // Prevents token from being passed in query params when hideToken option is used.\n      /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */\n      if (params.token && options.hideToken &&\n      // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\n      typeof window === \"undefined\") {\n        requestHeaders[\"X-Esri-Authorization\"] = \"Bearer \".concat(params.token);\n        delete params.token;\n      }\n      // encode the parameters into the query string\n      var queryParams = encodeQueryString(params);\n      // dont append a '?' unless parameters are actually present\n      var urlWithQueryString = queryParams === \"\" ? url : url + \"?\" + encodeQueryString(params);\n      if (\n      // This would exceed the maximum length for URLs specified by the consumer and requires POST\n      options.maxUrlLength && urlWithQueryString.length > options.maxUrlLength ||\n      // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)\n      params.token && options.hideToken) {\n        // the consumer specified a maximum length for URLs\n        // and this would exceed it, so use post instead\n        fetchOptions.method = \"POST\";\n        // If the token was already added as a Auth header, add the token back to body with other params instead of header\n        if (token.length && options.hideToken) {\n          params.token = token;\n          // Remove existing header that was added before url query length was checked\n          delete requestHeaders[\"X-Esri-Authorization\"];\n        }\n      } else {\n        // just use GET\n        url = urlWithQueryString;\n      }\n    }\n    /* updateResources currently requires FormData even when the input parameters dont warrant it.\n    https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm\n    see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */\n    var forceFormData = new RegExp(\"/items/.+/updateResources\").test(url);\n    if (fetchOptions.method === \"POST\") {\n      fetchOptions.body = encodeFormData(params, forceFormData);\n    }\n    // Mixin headers from request options\n    fetchOptions.headers = Object.assign(Object.assign({}, requestHeaders), options.headers);\n    // This should have the same conditional for Node JS as ArcGISIdentityManager.refreshWithUsernameAndPassword()\n    // to ensure that generated tokens have the same referer when used in Node with a username and password.\n    /* istanbul ignore next - karma reports coverage on browser tests only */\n    if ((typeof window === \"undefined\" || window && typeof window.document === \"undefined\") && !fetchOptions.headers.referer) {\n      fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;\n    }\n    /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */\n    if (!requiresFormData(params) && !forceFormData) {\n      fetchOptions.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n    }\n    /**\n     * Check for a global fetch first and use it if available. This allows us to use the default\n     * configuration of fetch-mock in tests.\n     */\n    /* istanbul ignore next coverage is based on browser code and we don't test for the absence of global fetch so we can skip the else here. */\n    return globalThis.fetch ? globalThis.fetch(url, fetchOptions) : getFetch().then(function (_ref) {\n      var fetch = _ref.fetch;\n      return fetch(url, fetchOptions);\n    });\n  }).then(function (response) {\n    if (!response.ok) {\n      // server responded w/ an actual error (404, 500, etc)\n      var status = response.status,\n        statusText = response.statusText;\n      throw new ArcGISRequestError(statusText, \"HTTP \".concat(status), response, url, options);\n    }\n    if (rawResponse) {\n      return response;\n    }\n    switch (params.f) {\n      case \"json\":\n        return response.json();\n      case \"geojson\":\n        return response.json();\n      case \"html\":\n        return response.text();\n      case \"text\":\n        return response.text();\n      /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */\n      default:\n        return response.blob();\n    }\n  }).then(function (data) {\n    if ((params.f === \"json\" || params.f === \"geojson\") && !rawResponse) {\n      var response = checkForErrors(data, originalUrl, params, options, originalAuthError);\n      if (originalAuthError) {\n        /* If the request was made to an unfederated service that\n        didn't require authentication, add the base url and a dummy token\n        to the list of trusted servers to avoid another federation check\n        in the event of a repeat request */\n        var truncatedUrl = url.toLowerCase().split(/\\/rest(\\/admin)?\\/services\\//)[0];\n        options.authentication.federatedServers[truncatedUrl] = {\n          token: [],\n          // default to 24 hours\n          expires: new Date(Date.now() + 86400 * 1000)\n        };\n        originalAuthError = null;\n      }\n      return response;\n    } else {\n      return data;\n    }\n  });\n}\n/**\n * Generic method for making HTTP requests to ArcGIS REST API endpoints.\n *\n * ```js\n * import { request } from '@esri/arcgis-rest-request';\n *\n * request('https://www.arcgis.com/sharing/rest')\n *   .then(response) // response.currentVersion === 5.2\n *\n * request('https://www.arcgis.com/sharing/rest', {\n *   httpMethod: \"GET\"\n * })\n *\n * request('https://www.arcgis.com/sharing/rest/search', {\n *   params: { q: 'parks' }\n * })\n *   .then(response) // response.total => 78379\n * ```\n *\n * @param url - The URL of the ArcGIS REST API endpoint.\n * @param requestOptions - Options for the request, including parameters relevant to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n */\nexport function request(url) {\n  var requestOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    params: {\n      f: \"json\"\n    }\n  };\n  return internalRequest(url, requestOptions).catch(function (e) {\n    if (e instanceof ArcGISAuthError && requestOptions.authentication && typeof requestOptions.authentication !== \"string\" && requestOptions.authentication.canRefresh && requestOptions.authentication.refreshCredentials) {\n      return e.retry(function () {\n        return requestOptions.authentication.refreshCredentials();\n      }, 1);\n    } else {\n      return Promise.reject(e);\n    }\n  });\n}","map":{"version":3,"names":["encodeFormData","encodeQueryString","requiresFormData","ArcGISRequestError","warn","getFetch","NODEJS_DEFAULT_REFERER_HEADER","setDefaultRequestOptions","options","hideWarnings","authentication","globalThis","DEFAULT_ARCGIS_REQUEST_OPTIONS","getDefaultRequestOptions","httpMethod","params","f","ArcGISAuthError","_ArcGISRequestError","_inherits","_super","_createSuper","_this","message","arguments","length","undefined","code","response","url","_classCallCheck","call","name","concat","actualProto","constructor","prototype","Object","setPrototypeOf","_assertThisInitialized","_createClass","key","value","retry","getSession","_this2","retryLimit","tries","retryRequest","resolve","reject","then","session","newOptions","assign","internalRequest","catch","e","Promise","checkForErrors","originalAuthError","error","_response$error","messageCode","errorCode","status","JSON","parse","statusMessage","requestOptions","defaults","headers","rawResponse","fetchOptions","method","signal","credentials","indexOf","rawToken","portal","getToken","startsWith","suppressWarnings","ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING","originalUrl","err","token","getDomainCredentials","requestHeaders","hideToken","window","queryParams","urlWithQueryString","maxUrlLength","forceFormData","RegExp","test","body","document","referer","fetch","_ref","ok","statusText","json","text","blob","data","truncatedUrl","toLowerCase","split","federatedServers","expires","Date","now","request","canRefresh","refreshCredentials"],"sources":["C:\\code-challenge-react\\node_modules\\@esri\\arcgis-rest-request\\src\\request.ts"],"sourcesContent":["/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { encodeFormData } from \"./utils/encode-form-data.js\";\nimport { encodeQueryString } from \"./utils/encode-query-string.js\";\nimport { requiresFormData } from \"./utils/process-params.js\";\nimport { ArcGISRequestError } from \"./utils/ArcGISRequestError.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\nimport { IParams } from \"./utils/IParams.js\";\nimport { warn } from \"./utils/warn.js\";\nimport { IRetryAuthError } from \"./utils/retryAuthError.js\";\nimport { getFetch } from \"@esri/arcgis-rest-fetch\";\nimport { IAuthenticationManager } from \"./index.js\";\n\nexport const NODEJS_DEFAULT_REFERER_HEADER = `@esri/arcgis-rest-js`;\n\n/**\n * Sets the default options that will be passed in **all requests across all `@esri/arcgis-rest-js` modules**.\n *\n * ```js\n * import { setDefaultRequestOptions } from \"@esri/arcgis-rest-request\";\n *\n * setDefaultRequestOptions({\n *   authentication: ArcGISIdentityManager // all requests will use this session by default\n * })\n * ```\n *\n * You should **never** set a default `authentication` when you are in a server side environment where you may be handling requests for many different authenticated users.\n *\n * @param options The default options to pass with every request. Existing default will be overwritten.\n * @param hideWarnings Silence warnings about setting default `authentication` in shared environments.\n */\nexport function setDefaultRequestOptions(\n  options: IRequestOptions,\n  hideWarnings?: boolean\n) {\n  if (options.authentication && !hideWarnings) {\n    warn(\n      \"You should not set `authentication` as a default in a shared environment such as a web server which will process multiple users requests. You can call `setDefaultRequestOptions` with `true` as a second argument to disable this warning.\"\n    );\n  }\n  (globalThis as any).DEFAULT_ARCGIS_REQUEST_OPTIONS = options;\n}\n\nexport function getDefaultRequestOptions() {\n  return (\n    (globalThis as any).DEFAULT_ARCGIS_REQUEST_OPTIONS || {\n      httpMethod: \"POST\",\n      params: {\n        f: \"json\"\n      }\n    }\n  );\n}\n\n/**\n * This error is thrown when a request encounters an invalid token error. Requests that use {@linkcode ArcGISIdentityManager} or\n * {@linkcode ApplicationCredentialsManager} in the `authentication` option the authentication manager will automatically try to generate\n * a fresh token using either {@linkcode ArcGISIdentityManager.refreshCredentials} or\n * {@linkcode ApplicationCredentialsManager.refreshCredentials}. If the request with the new token fails you will receive an `ArcGISAuthError`\n * if refreshing the token fails you will receive an instance of {@linkcode ArcGISTokenRequestError}.\n *\n * ```js\n * request(someUrl, {\n *   authentication: identityManager,\n *   // some additional options...\n * }).catch(e => {\n *   if(e.name === \"ArcGISAuthError\") {\n *     console.log(\"Request with a new token failed you might want to have the user authorize again.\")\n *   }\n *\n *   if(e.name === \"ArcGISTokenRequestError\") {\n *     console.log(\"There was an error refreshing the token you might want to have the user authorize again.\")\n *   }\n * })\n * ```\n */\nexport class ArcGISAuthError extends ArcGISRequestError {\n  /**\n   * Create a new `ArcGISAuthError`  object.\n   *\n   * @param message - The error message from the API\n   * @param code - The error code from the API\n   * @param response - The original response from the API that caused the error\n   * @param url - The original url of the request\n   * @param options - The original options of the request\n   */\n  constructor(\n    message = \"AUTHENTICATION_ERROR\",\n    code: string | number = \"AUTHENTICATION_ERROR_CODE\",\n    response?: any,\n    url?: string,\n    options?: IRequestOptions\n  ) {\n    super(message, code, response, url, options);\n    this.name = \"ArcGISAuthError\";\n    this.message =\n      code === \"AUTHENTICATION_ERROR_CODE\" ? message : `${code}: ${message}`;\n\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n  }\n\n  public retry(getSession: IRetryAuthError, retryLimit = 1) {\n    let tries = 0;\n\n    const retryRequest = (resolve: any, reject: any) => {\n      tries = tries + 1;\n\n      getSession(this.url, this.options)\n        .then((session) => {\n          const newOptions = {\n            ...this.options,\n            ...{ authentication: session }\n          };\n\n          return internalRequest(this.url, newOptions);\n        })\n        .then((response) => {\n          resolve(response);\n        })\n        .catch((e) => {\n          if (e.name === \"ArcGISAuthError\" && tries < retryLimit) {\n            retryRequest(resolve, reject);\n          } else if (\n            e.name === this.name &&\n            e.message === this.message &&\n            tries >= retryLimit\n          ) {\n            reject(this);\n          } else {\n            reject(e);\n          }\n        });\n    };\n\n    return new Promise((resolve, reject) => {\n      retryRequest(resolve, reject);\n    });\n  }\n}\n\n/**\n * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.\n *\n * @param data The response JSON to check for errors.\n * @param url The url of the original request\n * @param params The parameters of the original request\n * @param options The options of the original request\n * @returns The data that was passed in the `data` parameter\n */\nexport function checkForErrors(\n  response: any,\n  url?: string,\n  params?: IParams,\n  options?: IRequestOptions,\n  originalAuthError?: ArcGISAuthError\n): any {\n  // this is an error message from billing.arcgis.com backend\n  if (response.code >= 400) {\n    const { message, code } = response;\n    throw new ArcGISRequestError(message, code, response, url, options);\n  }\n\n  // error from ArcGIS Online or an ArcGIS Portal or server instance.\n  if (response.error) {\n    const { message, code, messageCode } = response.error;\n    const errorCode = messageCode || code || \"UNKNOWN_ERROR_CODE\";\n\n    if (code === 498 || code === 499) {\n      if (originalAuthError) {\n        throw originalAuthError;\n      } else {\n        throw new ArcGISAuthError(message, errorCode, response, url, options);\n      }\n    }\n\n    throw new ArcGISRequestError(message, errorCode, response, url, options);\n  }\n\n  // error from a status check\n  if (response.status === \"failed\" || response.status === \"failure\") {\n    let message: string;\n    let code = \"UNKNOWN_ERROR_CODE\";\n\n    try {\n      message = JSON.parse(response.statusMessage).message;\n      code = JSON.parse(response.statusMessage).code;\n    } catch (e) {\n      message = response.statusMessage || response.message;\n    }\n\n    throw new ArcGISRequestError(message, code, response, url, options);\n  }\n\n  return response;\n}\n\n/**\n * This is the internal implementation of `request` without the automatic retry behavior to prevent\n * infinite loops when a server continues to return invalid token errors.\n *\n * @param url - The URL of the ArcGIS REST API endpoint.\n * @param requestOptions - Options for the request, including parameters relevant to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n * @internal\n */\nexport function internalRequest(\n  url: string,\n  requestOptions: IRequestOptions\n): Promise<any> {\n  const defaults = getDefaultRequestOptions();\n  const options: IRequestOptions = {\n    ...{ httpMethod: \"POST\" },\n    ...defaults,\n    ...requestOptions,\n    ...{\n      params: {\n        ...defaults.params,\n        ...requestOptions.params\n      },\n      headers: {\n        ...defaults.headers,\n        ...requestOptions.headers\n      }\n    }\n  };\n\n  const { httpMethod, rawResponse } = options;\n\n  const params: IParams = {\n    ...{ f: \"json\" },\n    ...options.params\n  };\n\n  let originalAuthError: ArcGISAuthError = null;\n\n  const fetchOptions: RequestInit = {\n    method: httpMethod,\n    signal: options.signal,\n    /* ensures behavior mimics XMLHttpRequest.\n    needed to support sending IWA cookies */\n    credentials: options.credentials || \"same-origin\"\n  };\n\n  // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header\n  // and that request needs to send cookies cross domain\n  // so we need to set the credentials to \"include\"\n  if (\n    options.headers &&\n    options.headers[\"X-Esri-Auth-Client-Id\"] &&\n    url.indexOf(\"/oauth2/platformSelf\") > -1\n  ) {\n    fetchOptions.credentials = \"include\";\n  }\n\n  let authentication: IAuthenticationManager;\n\n  // Check to see if this is a raw token as a string and create a IAuthenticationManager like object for it.\n  // Otherwise this just assumes that options.authentication is an IAuthenticationManager.\n  if (typeof options.authentication === \"string\") {\n    const rawToken = options.authentication;\n\n    authentication = {\n      portal: \"https://www.arcgis.com/sharing/rest\",\n      getToken: () => {\n        return Promise.resolve(rawToken);\n      }\n    };\n\n    /* istanbul ignore else - we don't need to test NOT warning people */\n    if (\n      !options.authentication.startsWith(\"AAPK\") && // doesn't look like an API Key\n      !options.suppressWarnings && // user doesn't want to suppress warnings for this request\n      !(globalThis as any).ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING // we havn't shown the user this warning yet\n    ) {\n      warn(\n        `Using an oAuth 2.0 access token directly in the token option is discouraged. Consider using ArcGISIdentityManager or Application session. See https://esriurl.com/arcgis-rest-js-direct-token-warning for more information.`\n      );\n\n      (globalThis as any).ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING = true;\n    }\n  } else {\n    authentication = options.authentication;\n  }\n\n  // for errors in GET requests we want the URL passed to the error to be the URL before\n  // query params are applied.\n  const originalUrl = url;\n\n  return (\n    authentication\n      ? authentication.getToken(url).catch((err) => {\n          /**\n           * append original request url and requestOptions\n           * to the error thrown by getToken()\n           * to assist with retrying\n           */\n          err.url = url;\n          err.options = options;\n          /**\n           * if an attempt is made to talk to an unfederated server\n           * first try the request anonymously. if a 'token required'\n           * error is thrown, throw the UNFEDERATED error then.\n           */\n          originalAuthError = err;\n          return Promise.resolve(\"\");\n        })\n      : Promise.resolve(\"\")\n  )\n    .then((token) => {\n      if (token.length) {\n        params.token = token;\n      }\n\n      if (authentication && authentication.getDomainCredentials) {\n        fetchOptions.credentials = authentication.getDomainCredentials(url);\n      }\n\n      // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.\n      const requestHeaders: {\n        [key: string]: any;\n      } = {};\n\n      if (fetchOptions.method === \"GET\") {\n        // Prevents token from being passed in query params when hideToken option is used.\n        /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */\n        if (\n          params.token &&\n          options.hideToken &&\n          // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\n          typeof window === \"undefined\"\n        ) {\n          requestHeaders[\"X-Esri-Authorization\"] = `Bearer ${params.token}`;\n          delete params.token;\n        }\n        // encode the parameters into the query string\n        const queryParams = encodeQueryString(params);\n        // dont append a '?' unless parameters are actually present\n        const urlWithQueryString =\n          queryParams === \"\" ? url : url + \"?\" + encodeQueryString(params);\n\n        if (\n          // This would exceed the maximum length for URLs specified by the consumer and requires POST\n          (options.maxUrlLength &&\n            urlWithQueryString.length > options.maxUrlLength) ||\n          // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)\n          (params.token && options.hideToken)\n        ) {\n          // the consumer specified a maximum length for URLs\n          // and this would exceed it, so use post instead\n          fetchOptions.method = \"POST\";\n\n          // If the token was already added as a Auth header, add the token back to body with other params instead of header\n          if (token.length && options.hideToken) {\n            params.token = token;\n            // Remove existing header that was added before url query length was checked\n            delete requestHeaders[\"X-Esri-Authorization\"];\n          }\n        } else {\n          // just use GET\n          url = urlWithQueryString;\n        }\n      }\n\n      /* updateResources currently requires FormData even when the input parameters dont warrant it.\n  https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm\n      see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */\n      const forceFormData = new RegExp(\"/items/.+/updateResources\").test(url);\n\n      if (fetchOptions.method === \"POST\") {\n        fetchOptions.body = encodeFormData(params, forceFormData) as any;\n      }\n\n      // Mixin headers from request options\n      fetchOptions.headers = {\n        ...requestHeaders,\n        ...options.headers\n      };\n\n      // This should have the same conditional for Node JS as ArcGISIdentityManager.refreshWithUsernameAndPassword()\n      // to ensure that generated tokens have the same referer when used in Node with a username and password.\n      /* istanbul ignore next - karma reports coverage on browser tests only */\n      if (\n        (typeof window === \"undefined\" ||\n          (window && typeof window.document === \"undefined\")) &&\n        !fetchOptions.headers.referer\n      ) {\n        fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;\n      }\n\n      /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */\n      if (!requiresFormData(params) && !forceFormData) {\n        fetchOptions.headers[\"Content-Type\"] =\n          \"application/x-www-form-urlencoded\";\n      }\n\n      /**\n       * Check for a global fetch first and use it if available. This allows us to use the default\n       * configuration of fetch-mock in tests.\n       */\n\n      /* istanbul ignore next coverage is based on browser code and we don't test for the absence of global fetch so we can skip the else here. */\n      return globalThis.fetch\n        ? globalThis.fetch(url, fetchOptions)\n        : getFetch().then(({ fetch }) => {\n            return fetch(url, fetchOptions);\n          });\n    })\n    .then((response: any) => {\n      if (!response.ok) {\n        // server responded w/ an actual error (404, 500, etc)\n        const { status, statusText } = response;\n        throw new ArcGISRequestError(\n          statusText,\n          `HTTP ${status}`,\n          response,\n          url,\n          options\n        );\n      }\n      if (rawResponse) {\n        return response;\n      }\n      switch (params.f) {\n        case \"json\":\n          return response.json();\n        case \"geojson\":\n          return response.json();\n        case \"html\":\n          return response.text();\n        case \"text\":\n          return response.text();\n        /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */\n        default:\n          return response.blob();\n      }\n    })\n    .then((data) => {\n      if ((params.f === \"json\" || params.f === \"geojson\") && !rawResponse) {\n        const response = checkForErrors(\n          data,\n          originalUrl,\n          params,\n          options,\n          originalAuthError\n        );\n\n        if (originalAuthError) {\n          /* If the request was made to an unfederated service that\n          didn't require authentication, add the base url and a dummy token\n          to the list of trusted servers to avoid another federation check\n          in the event of a repeat request */\n          const truncatedUrl: string = url\n            .toLowerCase()\n            .split(/\\/rest(\\/admin)?\\/services\\//)[0];\n\n          (options.authentication as any).federatedServers[truncatedUrl] = {\n            token: [],\n            // default to 24 hours\n            expires: new Date(Date.now() + 86400 * 1000)\n          };\n          originalAuthError = null;\n        }\n        return response;\n      } else {\n        return data;\n      }\n    });\n}\n\n/**\n * Generic method for making HTTP requests to ArcGIS REST API endpoints.\n *\n * ```js\n * import { request } from '@esri/arcgis-rest-request';\n *\n * request('https://www.arcgis.com/sharing/rest')\n *   .then(response) // response.currentVersion === 5.2\n *\n * request('https://www.arcgis.com/sharing/rest', {\n *   httpMethod: \"GET\"\n * })\n *\n * request('https://www.arcgis.com/sharing/rest/search', {\n *   params: { q: 'parks' }\n * })\n *   .then(response) // response.total => 78379\n * ```\n *\n * @param url - The URL of the ArcGIS REST API endpoint.\n * @param requestOptions - Options for the request, including parameters relevant to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n */\nexport function request(\n  url: string,\n  requestOptions: IRequestOptions = { params: { f: \"json\" } }\n): Promise<any> {\n  return internalRequest(url, requestOptions).catch((e) => {\n    if (\n      e instanceof ArcGISAuthError &&\n      requestOptions.authentication &&\n      typeof requestOptions.authentication !== \"string\" &&\n      requestOptions.authentication.canRefresh &&\n      requestOptions.authentication.refreshCredentials\n    ) {\n      return e.retry(() => {\n        return (requestOptions.authentication as any).refreshCredentials();\n      }, 1);\n    } else {\n      return Promise.reject(e);\n    }\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}