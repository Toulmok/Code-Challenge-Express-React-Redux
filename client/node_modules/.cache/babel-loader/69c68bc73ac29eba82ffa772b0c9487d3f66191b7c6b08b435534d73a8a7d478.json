{"ast":null,"code":"import _taggedTemplateLiteral from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nimport _toConsumableArray from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createClass from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _templateObject;\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { c as e } from \"../../../../../../chunks/vec3f64.js\";\nimport { RgbaFloatEncoding as a } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { textureSize as s } from \"../util/WebGL2Utils.js\";\nimport { Float4PassUniform as o } from \"../../shaderModules/Float4PassUniform.js\";\nimport { IntegerPassUniform as t } from \"../../shaderModules/IntegerPassUniform.js\";\nimport { NoParameters as i, glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4sDrawUniform as d } from \"../../shaderModules/Matrix4sDrawUniform.js\";\nimport { Matrix4sPassUniform as l } from \"../../shaderModules/Matrix4sPassUniform.js\";\nimport { createTexture2DPassSizeUniforms as p } from \"../../shaderModules/Texture2DPassUniform.js\";\nimport { TextureSizeUniformType as c } from \"../../shaderModules/TextureSizeUniformType.js\";\nvar n = /*#__PURE__*/function (_i) {\n  _inherits(n, _i);\n  var _super = _createSuper(n);\n  function n() {\n    var _this;\n    _classCallCheck(this, n);\n    _this = _super.apply(this, arguments), _this.origin = e();\n    return _this;\n  }\n  return _createClass(n);\n}(i);\nfunction h(e, a) {\n  a.receiveShadows && (e.fragment.uniforms.add(new l(\"shadowMapMatrix\", function (e, a) {\n    return a.shadowMap.getShadowMapMatrices(e.origin);\n  }, 4)), f(e, a));\n}\nfunction v(e, a) {\n  a.receiveShadows && (e.fragment.uniforms.add(new d(\"shadowMapMatrix\", function (e, a) {\n    return a.shadowMap.getShadowMapMatrices(e.origin);\n  }, 4)), f(e, a));\n}\nfunction f(e, i) {\n  var d = e.fragment;\n  d.include(a), d.uniforms.add([].concat(_toConsumableArray(p(\"shadowMapTex\", function (e, a) {\n    return a.shadowMap.depthTexture;\n  }, i.hasWebGL2Context ? c.None : c.Size)), [new t(\"numCascades\", function (e, a) {\n    return a.shadowMap.numCascades;\n  }), new o(\"cascadeDistances\", function (e, a) {\n    return a.shadowMap.cascadeDistances;\n  })])), d.code.add(r(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    int chooseCascade(float depth, out mat4 mat) {\\n      vec4 distance = cascadeDistances;\\n\\n      // choose correct cascade\\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\\n\\n      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\\n\\n      return i;\\n    }\\n\\n    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\\n      vec4 lv = mat * vec4(_vpos, 1.0);\\n      lv.xy /= lv.w;\\n      return 0.5 * lv.xyz + vec3(0.5);\\n    }\\n\\n    vec2 cascadeCoordinates(int i, vec3 lvpos) {\\n      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\\n    }\\n\\n    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\\n      return rgba2float(texture2D(_depthTex, uv));\\n    }\\n\\n    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\\n      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\\n    }\\n\\n    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {\\n      float halfPixelSize = 0.5 / textureSize;\\n\\n      // filter, offset by half pixels\\n      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);\\n\\n      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\\n      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\\n      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\\n      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\\n\\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\\n    }\\n\\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\\n      mat4 mat;\\n      int i = chooseCascade(_linearDepth, mat);\\n\\n      if (i >= numCascades) { return 0.0; }\\n\\n      vec3 lvpos = lightSpacePosition(_vpos, mat);\\n\\n      // vertex completely outside? -> no shadow\\n      if (lvpos.z >= 1.0) { return 0.0; }\\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\\n\\n      // calc coord in cascade texture\\n      vec2 uv = cascadeCoordinates(i, lvpos);\\n\\n      vec2 textureSize = \", \";\\n\\n      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);\\n    }\\n  \"])), s(i, \"shadowMapTex\")));\n}\nexport { n as ReadShadowMapBindParameters, v as ReadShadowMapDraw, h as ReadShadowMapPass };","map":{"version":3,"names":["c","e","RgbaFloatEncoding","a","textureSize","s","Float4PassUniform","o","IntegerPassUniform","t","NoParameters","i","glsl","r","Matrix4sDrawUniform","d","Matrix4sPassUniform","l","createTexture2DPassSizeUniforms","p","TextureSizeUniformType","n","_i","_inherits","_super","_createSuper","_this","_classCallCheck","apply","arguments","origin","_createClass","h","receiveShadows","fragment","uniforms","add","shadowMap","getShadowMapMatrices","f","v","include","concat","_toConsumableArray","depthTexture","hasWebGL2Context","None","Size","numCascades","cascadeDistances","code","_templateObject","_taggedTemplateLiteral","ReadShadowMapBindParameters","ReadShadowMapDraw","ReadShadowMapPass"],"sources":["C:/code-challenge-react/client/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{c as e}from\"../../../../../../chunks/vec3f64.js\";import{RgbaFloatEncoding as a}from\"../util/RgbaFloatEncoding.glsl.js\";import{textureSize as s}from\"../util/WebGL2Utils.js\";import{Float4PassUniform as o}from\"../../shaderModules/Float4PassUniform.js\";import{IntegerPassUniform as t}from\"../../shaderModules/IntegerPassUniform.js\";import{NoParameters as i,glsl as r}from\"../../shaderModules/interfaces.js\";import{Matrix4sDrawUniform as d}from\"../../shaderModules/Matrix4sDrawUniform.js\";import{Matrix4sPassUniform as l}from\"../../shaderModules/Matrix4sPassUniform.js\";import{createTexture2DPassSizeUniforms as p}from\"../../shaderModules/Texture2DPassUniform.js\";import{TextureSizeUniformType as c}from\"../../shaderModules/TextureSizeUniformType.js\";class n extends i{constructor(){super(...arguments),this.origin=e()}}function h(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new l(\"shadowMapMatrix\",((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),f(e,a))}function v(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new d(\"shadowMapMatrix\",((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),f(e,a))}function f(e,i){const d=e.fragment;d.include(a),d.uniforms.add([...p(\"shadowMapTex\",((e,a)=>a.shadowMap.depthTexture),i.hasWebGL2Context?c.None:c.Size),new t(\"numCascades\",((e,a)=>a.shadowMap.numCascades)),new o(\"cascadeDistances\",((e,a)=>a.shadowMap.cascadeDistances))]),d.code.add(r`\n    int chooseCascade(float depth, out mat4 mat) {\n      vec4 distance = cascadeDistances;\n\n      // choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      return i;\n    }\n\n    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n      return 0.5 * lv.xyz + vec3(0.5);\n    }\n\n    vec2 cascadeCoordinates(int i, vec3 lvpos) {\n      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n    }\n\n    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\n      return rgba2float(texture2D(_depthTex, uv));\n    }\n\n    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\n      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n    }\n\n    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {\n      float halfPixelSize = 0.5 / textureSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);\n\n      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\n      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      mat4 mat;\n      int i = chooseCascade(_linearDepth, mat);\n\n      if (i >= numCascades) { return 0.0; }\n\n      vec3 lvpos = lightSpacePosition(_vpos, mat);\n\n      // vertex completely outside? -> no shadow\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = cascadeCoordinates(i, lvpos);\n\n      vec2 textureSize = ${s(i,\"shadowMapTex\")};\n\n      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);\n    }\n  `)}export{n as ReadShadowMapBindParameters,v as ReadShadowMapDraw,h as ReadShadowMapPass};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}