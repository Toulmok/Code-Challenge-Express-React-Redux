{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { isSome as e } from \"../../../../../../core/maybe.js\";\nimport { RgbaFloatEncoding as t } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { addCameraPosition as i } from \"../util/View.glsl.js\";\nimport { textureSize as o } from \"../util/WebGL2Utils.js\";\nimport { Float4PassUniform as r } from \"../../shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as a } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as l } from \"../../shaderModules/interfaces.js\";\nimport { createTexture2DPassSizeUniforms as p } from \"../../shaderModules/Texture2DPassUniform.js\";\nimport { TextureSizeUniformType as s } from \"../../shaderModules/TextureSizeUniformType.js\";\nimport { STIPPLE_TEXTURE_PADDING as n, computeLongestPattern as d, computeTextureSize as c } from \"../../../materials/StippleTextureRepository.js\";\nimport { ensureColor4 as f } from \"../../../shaders/ensureColor4.js\";\nfunction u(e, t) {\n  e.constants.add(\"stippleAlphaColorDiscard\", \"float\", .001), e.constants.add(\"stippleAlphaHighlightDiscard\", \"float\", .5), t.stippleEnabled ? m(e, t) : S(e);\n}\nfunction m(e, d) {\n  const c = !(d.draped && d.stipplePreferContinuous),\n    {\n      vertex: u,\n      fragment: m\n    } = e;\n  m.include(t), d.draped || (i(u, d), u.uniforms.add(new a(\"worldToScreenPerDistanceRatio\", (e, t) => 1 / t.camera.perScreenPixelRatio)), u.code.add(l`float computeWorldToScreenRatio(vec3 segmentCenter) {\nfloat segmentDistanceToCamera = length(segmentCenter - cameraPosition);\nreturn worldToScreenPerDistanceRatio / segmentDistanceToCamera;\n}`)), e.varyings.add(\"vStippleDistance\", \"float\"), d.stippleRequiresClamp && e.varyings.add(\"vStippleDistanceLimits\", \"vec2\"), d.stippleRequiresStretchMeasure && e.varyings.add(\"vStipplePatternStretch\", \"float\"), u.code.add(l`\n    float discretizeWorldToScreenRatio(float worldToScreenRatio) {\n      float step = ${x};\n\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n      return discreteWorldToScreenRatio;\n    }\n  `), u.code.add(l`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`), u.code.add(l`\n    if (segmentLengthPseudoScreen >= ${c ? \"patternLength\" : \"1e4\"}) {\n  `), u.uniforms.add(new a(\"pixelRatio\", (e, t) => t.camera.pixelRatio)), u.code.add(l`\n        // Round the screen length to get an integer number of pattern repetitions (minimum 1).\n        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);\n        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));\n        float segmentLengthScreenRounded = flooredRepetitions * patternLength;\n\n        ${d.stippleRequiresStretchMeasure ? l`\n              float stretch = repetitions / flooredRepetitions;\n\n              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.\n              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.\n              vStipplePatternStretch = max(0.75, stretch);` : \"\"}\n\n        return vec2(0.0, segmentLengthScreenRounded);\n      }\n      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);\n    }\n  `), m.constants.add(\"stippleTexturePadding\", \"float\", n);\n  const S = d.hasWebGL2Context ? s.None : s.Size;\n  m.uniforms.add(p(\"stipplePatternTexture\", e => e.stippleTexture, S)), m.uniforms.add([new a(\"stipplePatternSDFNormalizer\", e => h(e.stipplePattern)), new a(\"stipplePatternPixelSizeInv\", e => 1 / g(e))]), m.code.add(l`\n    float padStippleTexture(float u) {\n      float paddedTextureSize = ${o(d, \"stipplePatternTexture\")}.x;\n      float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;\n\n      return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;\n    }\n  `), m.code.add(l`\n    float getStippleSDF(out bool isClamped) {\n      ${d.stippleRequiresClamp ? l`\n          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);\n          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;\n          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;` : l`\n          float stippleDistanceClamped = vStippleDistance;\n          isClamped = false;`}\n\n      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;\n      ${d.stippleScaleWithLineWidth ? l`u *= vLineSizeInv;` : \"\"}\n      u = padStippleTexture(fract(u));\n\n      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));\n      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;\n\n      ${d.stippleRequiresStretchMeasure ? l`return (sdf - 0.5) * vStipplePatternStretch + 0.5;` : l`return sdf;`}\n    }\n\n    float getStippleSDF() {\n      bool ignored;\n      return getStippleSDF(ignored);\n    }\n\n    float getStippleAlpha() {\n      bool isClamped;\n      float stippleSDF = getStippleSDF(isClamped);\n\n      float antiAliasedResult = ${d.stippleScaleWithLineWidth ? l`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);` : l`clamp(stippleSDF + 0.5, 0.0, 1.0);`}\n\n      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;\n    }\n  `), d.stippleOffColorEnabled ? (m.uniforms.add(new r(\"stippleOffColor\", e => f(e.stippleOffColor))), m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) {}\n#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)) : m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`);\n}\nfunction S(e) {\n  e.fragment.code.add(l`float getStippleAlpha() { return 1.0; }\n#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n#define blendStipple(color, _stippleAlpha_) color`);\n}\nfunction h(t) {\n  return e(t) ? (Math.floor(.5 * (d(t) - 1)) + .5) / t.pixelRatio : 1;\n}\nfunction g(t) {\n  const i = t.stipplePattern;\n  return e(i) ? c(t.stipplePattern) / i.pixelRatio : 1;\n}\nconst x = l.float(.4);\nexport { u as LineStipple, g as computePixelSize };","map":{"version":3,"names":["isSome","e","RgbaFloatEncoding","t","addCameraPosition","i","textureSize","o","Float4PassUniform","r","FloatPassUniform","a","glsl","l","createTexture2DPassSizeUniforms","p","TextureSizeUniformType","s","STIPPLE_TEXTURE_PADDING","n","computeLongestPattern","d","computeTextureSize","c","ensureColor4","f","u","constants","add","stippleEnabled","m","S","draped","stipplePreferContinuous","vertex","fragment","include","uniforms","camera","perScreenPixelRatio","code","varyings","stippleRequiresClamp","stippleRequiresStretchMeasure","x","pixelRatio","hasWebGL2Context","None","Size","stippleTexture","h","stipplePattern","g","stippleScaleWithLineWidth","stippleOffColorEnabled","stippleOffColor","Math","floor","float","LineStipple","computePixelSize"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{isSome as e}from\"../../../../../../core/maybe.js\";import{RgbaFloatEncoding as t}from\"../util/RgbaFloatEncoding.glsl.js\";import{addCameraPosition as i}from\"../util/View.glsl.js\";import{textureSize as o}from\"../util/WebGL2Utils.js\";import{Float4PassUniform as r}from\"../../shaderModules/Float4PassUniform.js\";import{FloatPassUniform as a}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as l}from\"../../shaderModules/interfaces.js\";import{createTexture2DPassSizeUniforms as p}from\"../../shaderModules/Texture2DPassUniform.js\";import{TextureSizeUniformType as s}from\"../../shaderModules/TextureSizeUniformType.js\";import{STIPPLE_TEXTURE_PADDING as n,computeLongestPattern as d,computeTextureSize as c}from\"../../../materials/StippleTextureRepository.js\";import{ensureColor4 as f}from\"../../../shaders/ensureColor4.js\";function u(e,t){e.constants.add(\"stippleAlphaColorDiscard\",\"float\",.001),e.constants.add(\"stippleAlphaHighlightDiscard\",\"float\",.5),t.stippleEnabled?m(e,t):S(e)}function m(e,d){const c=!(d.draped&&d.stipplePreferContinuous),{vertex:u,fragment:m}=e;m.include(t),d.draped||(i(u,d),u.uniforms.add(new a(\"worldToScreenPerDistanceRatio\",((e,t)=>1/t.camera.perScreenPixelRatio))),u.code.add(l`float computeWorldToScreenRatio(vec3 segmentCenter) {\nfloat segmentDistanceToCamera = length(segmentCenter - cameraPosition);\nreturn worldToScreenPerDistanceRatio / segmentDistanceToCamera;\n}`)),e.varyings.add(\"vStippleDistance\",\"float\"),d.stippleRequiresClamp&&e.varyings.add(\"vStippleDistanceLimits\",\"vec2\"),d.stippleRequiresStretchMeasure&&e.varyings.add(\"vStipplePatternStretch\",\"float\"),u.code.add(l`\n    float discretizeWorldToScreenRatio(float worldToScreenRatio) {\n      float step = ${x};\n\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n      return discreteWorldToScreenRatio;\n    }\n  `),u.code.add(l`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),u.code.add(l`\n    if (segmentLengthPseudoScreen >= ${c?\"patternLength\":\"1e4\"}) {\n  `),u.uniforms.add(new a(\"pixelRatio\",((e,t)=>t.camera.pixelRatio))),u.code.add(l`\n        // Round the screen length to get an integer number of pattern repetitions (minimum 1).\n        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);\n        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));\n        float segmentLengthScreenRounded = flooredRepetitions * patternLength;\n\n        ${d.stippleRequiresStretchMeasure?l`\n              float stretch = repetitions / flooredRepetitions;\n\n              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.\n              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.\n              vStipplePatternStretch = max(0.75, stretch);`:\"\"}\n\n        return vec2(0.0, segmentLengthScreenRounded);\n      }\n      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);\n    }\n  `),m.constants.add(\"stippleTexturePadding\",\"float\",n);const S=d.hasWebGL2Context?s.None:s.Size;m.uniforms.add(p(\"stipplePatternTexture\",(e=>e.stippleTexture),S)),m.uniforms.add([new a(\"stipplePatternSDFNormalizer\",(e=>h(e.stipplePattern))),new a(\"stipplePatternPixelSizeInv\",(e=>1/g(e)))]),m.code.add(l`\n    float padStippleTexture(float u) {\n      float paddedTextureSize = ${o(d,\"stipplePatternTexture\")}.x;\n      float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;\n\n      return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;\n    }\n  `),m.code.add(l`\n    float getStippleSDF(out bool isClamped) {\n      ${d.stippleRequiresClamp?l`\n          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);\n          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;\n          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:l`\n          float stippleDistanceClamped = vStippleDistance;\n          isClamped = false;`}\n\n      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;\n      ${d.stippleScaleWithLineWidth?l`u *= vLineSizeInv;`:\"\"}\n      u = padStippleTexture(fract(u));\n\n      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));\n      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;\n\n      ${d.stippleRequiresStretchMeasure?l`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:l`return sdf;`}\n    }\n\n    float getStippleSDF() {\n      bool ignored;\n      return getStippleSDF(ignored);\n    }\n\n    float getStippleAlpha() {\n      bool isClamped;\n      float stippleSDF = getStippleSDF(isClamped);\n\n      float antiAliasedResult = ${d.stippleScaleWithLineWidth?l`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:l`clamp(stippleSDF + 0.5, 0.0, 1.0);`}\n\n      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;\n    }\n  `),d.stippleOffColorEnabled?(m.uniforms.add(new r(\"stippleOffColor\",(e=>f(e.stippleOffColor)))),m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) {}\n#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):m.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function S(e){e.fragment.code.add(l`float getStippleAlpha() { return 1.0; }\n#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n#define blendStipple(color, _stippleAlpha_) color`)}function h(t){return e(t)?(Math.floor(.5*(d(t)-1))+.5)/t.pixelRatio:1}function g(t){const i=t.stipplePattern;return e(i)?c(t.stipplePattern)/i.pixelRatio:1}const x=l.float(.4);export{u as LineStipple,g as computePixelSize};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,MAAM,IAAIC,CAAC,QAAK,iCAAiC;AAAC,SAAOC,iBAAiB,IAAIC,CAAC,QAAK,mCAAmC;AAAC,SAAOC,iBAAiB,IAAIC,CAAC,QAAK,sBAAsB;AAAC,SAAOC,WAAW,IAAIC,CAAC,QAAK,wBAAwB;AAAC,SAAOC,iBAAiB,IAAIC,CAAC,QAAK,0CAA0C;AAAC,SAAOC,gBAAgB,IAAIC,CAAC,QAAK,yCAAyC;AAAC,SAAOC,IAAI,IAAIC,CAAC,QAAK,mCAAmC;AAAC,SAAOC,+BAA+B,IAAIC,CAAC,QAAK,6CAA6C;AAAC,SAAOC,sBAAsB,IAAIC,CAAC,QAAK,+CAA+C;AAAC,SAAOC,uBAAuB,IAAIC,CAAC,EAACC,qBAAqB,IAAIC,CAAC,EAACC,kBAAkB,IAAIC,CAAC,QAAK,gDAAgD;AAAC,SAAOC,YAAY,IAAIC,CAAC,QAAK,kCAAkC;AAAC,SAASC,CAACA,CAACzB,CAAC,EAACE,CAAC,EAAC;EAACF,CAAC,CAAC0B,SAAS,CAACC,GAAG,CAAC,0BAA0B,EAAC,OAAO,EAAC,IAAI,CAAC,EAAC3B,CAAC,CAAC0B,SAAS,CAACC,GAAG,CAAC,8BAA8B,EAAC,OAAO,EAAC,EAAE,CAAC,EAACzB,CAAC,CAAC0B,cAAc,GAACC,CAAC,CAAC7B,CAAC,EAACE,CAAC,CAAC,GAAC4B,CAAC,CAAC9B,CAAC,CAAC;AAAA;AAAC,SAAS6B,CAACA,CAAC7B,CAAC,EAACoB,CAAC,EAAC;EAAC,MAAME,CAAC,GAAC,EAAEF,CAAC,CAACW,MAAM,IAAEX,CAAC,CAACY,uBAAuB,CAAC;IAAC;MAACC,MAAM,EAACR,CAAC;MAACS,QAAQ,EAACL;IAAC,CAAC,GAAC7B,CAAC;EAAC6B,CAAC,CAACM,OAAO,CAACjC,CAAC,CAAC,EAACkB,CAAC,CAACW,MAAM,KAAG3B,CAAC,CAACqB,CAAC,EAACL,CAAC,CAAC,EAACK,CAAC,CAACW,QAAQ,CAACT,GAAG,CAAC,IAAIjB,CAAC,CAAC,+BAA+B,EAAE,CAACV,CAAC,EAACE,CAAC,KAAG,CAAC,GAACA,CAAC,CAACmC,MAAM,CAACC,mBAAmB,CAAE,CAAC,EAACb,CAAC,CAACc,IAAI,CAACZ,GAAG,CAACf,CAAE;AAClsC;AACA;AACA,EAAE,CAAC,CAAC,EAACZ,CAAC,CAACwC,QAAQ,CAACb,GAAG,CAAC,kBAAkB,EAAC,OAAO,CAAC,EAACP,CAAC,CAACqB,oBAAoB,IAAEzC,CAAC,CAACwC,QAAQ,CAACb,GAAG,CAAC,wBAAwB,EAAC,MAAM,CAAC,EAACP,CAAC,CAACsB,6BAA6B,IAAE1C,CAAC,CAACwC,QAAQ,CAACb,GAAG,CAAC,wBAAwB,EAAC,OAAO,CAAC,EAACF,CAAC,CAACc,IAAI,CAACZ,GAAG,CAACf,CAAE;AACvN;AACA,qBAAqB+B,CAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,EAAClB,CAAC,CAACc,IAAI,CAACZ,GAAG,CAACf,CAAE,+IAA8I,CAAC,EAACa,CAAC,CAACc,IAAI,CAACZ,GAAG,CAACf,CAAE;AAC/K,uCAAuCU,CAAC,GAAC,eAAe,GAAC,KAAM;AAC/D,GAAG,CAAC,EAACG,CAAC,CAACW,QAAQ,CAACT,GAAG,CAAC,IAAIjB,CAAC,CAAC,YAAY,EAAE,CAACV,CAAC,EAACE,CAAC,KAAGA,CAAC,CAACmC,MAAM,CAACO,UAAU,CAAE,CAAC,EAACnB,CAAC,CAACc,IAAI,CAACZ,GAAG,CAACf,CAAE;AACnF;AACA;AACA;AACA;AACA;AACA,UAAUQ,CAAC,CAACsB,6BAA6B,GAAC9B,CAAE;AAC5C;AACA;AACA;AACA;AACA,2DAA2D,GAAC,EAAG;AAC/D;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,EAACiB,CAAC,CAACH,SAAS,CAACC,GAAG,CAAC,uBAAuB,EAAC,OAAO,EAACT,CAAC,CAAC;EAAC,MAAMY,CAAC,GAACV,CAAC,CAACyB,gBAAgB,GAAC7B,CAAC,CAAC8B,IAAI,GAAC9B,CAAC,CAAC+B,IAAI;EAAClB,CAAC,CAACO,QAAQ,CAACT,GAAG,CAACb,CAAC,CAAC,uBAAuB,EAAEd,CAAC,IAAEA,CAAC,CAACgD,cAAc,EAAElB,CAAC,CAAC,CAAC,EAACD,CAAC,CAACO,QAAQ,CAACT,GAAG,CAAC,CAAC,IAAIjB,CAAC,CAAC,6BAA6B,EAAEV,CAAC,IAAEiD,CAAC,CAACjD,CAAC,CAACkD,cAAc,CAAC,CAAE,EAAC,IAAIxC,CAAC,CAAC,4BAA4B,EAAEV,CAAC,IAAE,CAAC,GAACmD,CAAC,CAACnD,CAAC,CAAC,CAAE,CAAC,CAAC,EAAC6B,CAAC,CAACU,IAAI,CAACZ,GAAG,CAACf,CAAE;AACjT;AACA,kCAAkCN,CAAC,CAACc,CAAC,EAAC,uBAAuB,CAAE;AAC/D;AACA;AACA;AACA;AACA,GAAG,CAAC,EAACS,CAAC,CAACU,IAAI,CAACZ,GAAG,CAACf,CAAE;AAClB;AACA,QAAQQ,CAAC,CAACqB,oBAAoB,GAAC7B,CAAE;AACjC;AACA;AACA,wGAAwG,GAACA,CAAE;AAC3G;AACA,6BAA8B;AAC9B;AACA;AACA,QAAQQ,CAAC,CAACgC,yBAAyB,GAACxC,CAAE,oBAAmB,GAAC,EAAG;AAC7D;AACA;AACA;AACA;AACA;AACA,QAAQQ,CAAC,CAACsB,6BAA6B,GAAC9B,CAAE,oDAAmD,GAACA,CAAE,aAAa;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkCQ,CAAC,CAACgC,yBAAyB,GAACxC,CAAE,iDAAgD,GAACA,CAAE,oCAAoC;AACvJ;AACA;AACA;AACA,GAAG,CAAC,EAACQ,CAAC,CAACiC,sBAAsB,IAAExB,CAAC,CAACO,QAAQ,CAACT,GAAG,CAAC,IAAInB,CAAC,CAAC,iBAAiB,EAAER,CAAC,IAAEwB,CAAC,CAACxB,CAAC,CAACsD,eAAe,CAAC,CAAE,CAAC,EAACzB,CAAC,CAACU,IAAI,CAACZ,GAAG,CAACf,CAAE;AAC/G,oFAAoF,CAAC,IAAEiB,CAAC,CAACU,IAAI,CAACZ,GAAG,CAACf,CAAE;AACpG,kFAAkF,CAAC;AAAA;AAAC,SAASkB,CAACA,CAAC9B,CAAC,EAAC;EAACA,CAAC,CAACkC,QAAQ,CAACK,IAAI,CAACZ,GAAG,CAACf,CAAE;AACxH;AACA,kDAAkD,CAAC;AAAA;AAAC,SAASqC,CAACA,CAAC/C,CAAC,EAAC;EAAC,OAAOF,CAAC,CAACE,CAAC,CAAC,GAAC,CAACqD,IAAI,CAACC,KAAK,CAAC,EAAE,IAAEpC,CAAC,CAAClB,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,GAAC,EAAE,IAAEA,CAAC,CAAC0C,UAAU,GAAC,CAAC;AAAA;AAAC,SAASO,CAACA,CAACjD,CAAC,EAAC;EAAC,MAAME,CAAC,GAACF,CAAC,CAACgD,cAAc;EAAC,OAAOlD,CAAC,CAACI,CAAC,CAAC,GAACkB,CAAC,CAACpB,CAAC,CAACgD,cAAc,CAAC,GAAC9C,CAAC,CAACwC,UAAU,GAAC,CAAC;AAAA;AAAC,MAAMD,CAAC,GAAC/B,CAAC,CAAC6C,KAAK,CAAC,EAAE,CAAC;AAAC,SAAOhC,CAAC,IAAIiC,WAAW,EAACP,CAAC,IAAIQ,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}