{"ast":null,"code":"import _regeneratorRuntime from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/code-challenge-react/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { request } from \"./request.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\nimport { ArcGISJobError } from \"./utils/ArcGISJobError.js\";\nimport { JOB_STATUSES } from \"./types/job-statuses.js\";\nimport mitt from \"mitt\";\nimport { processJobParams } from \"./utils/process-job-params.js\";\nvar DefaultJobOptions = {\n  pollingRate: 2000,\n  startMonitoring: false\n};\n/**\n * Jobs represent long running processing tasks running on ArcGIS Services. Typically these represent complex analysis tasks such as [geoprocessing tasks](https://developers.arcgis.com/rest/services-reference/enterprise/submit-gp-job.htm), [logistics analysis such as fleet routing](https://developers.arcgis.com/rest/network/api-reference/vehicle-routing-problem-service.htm) or [spatial analysis tasks](https://developers.arcgis.com/rest/analysis/api-reference/tasks-overview.htm).\n *\n * To create a {@linkcode Job}, use the {@linkcode Job.submitJob} method which will return an instance of the {@linkcode Job} class with a unique id.\n *\n * If you have an existing job you can use {@linkcode Job.serialize} and {@linkcode Job.deserialize} to save job information as a string and recreate the job to get results later.\n *\n * ```js\n * import { Job,  JOB_STATUSES  } from \"@esri/arcgis-rest-request\";\n *\n * const job  = async Job.submitJob(options);\n *\n * // will automatically wait for job completion and get results when the job is finished.\n * job.getAllResults().then((results) => {console.log(results)})\n *\n * // watch for all status updates\n * job.on(\"status\", ({jobStatus}) => {console.log(job.status)})\n * ```\n *\n * By default event monitoring is started when you call {@linkcode Job.waitForCompletion}, {@linkcode Job.getAllResults} or, {@linkcode Job.getResult} and stops automatically when those promises complete. Use {@linkcode Job.startEventMonitoring} and {@linkcode Job.stopEventMonitoring} to manually start and stop event monitoring outside those methods. Starting monitoring with {@linkcode Job.startEventMonitoring} will not stop monitoring when {@linkcode Job.waitForCompletion}, {@linkcode Job.getAllResults} or, {@linkcode Job.getResult} complete.\n */\nexport var Job = /*#__PURE__*/function () {\n  function Job(options) {\n    var _this = this;\n    _classCallCheck(this, Job);\n    /**\n     * Function that calls the {@linkcode Job.getJobInfo} to check the job status, and emits the current job status. There are custom event emitters that\n     * the user is able to listen based on the job status. Refer to {@linkcode JOB_STATUSES} to see the various enums of the job status.\n     * To get results array from the job task, the job status must be {@linkcode JOB_STATUSES.Success}.\n     *\n     * These job statuses are based on what are returned from the job request task and have been into an enum type in {@linkcode JOB_STATUSES}.\n     *\n     * Reference https://developers.arcgis.com/rest/services-reference/enterprise/geoanalytics-checking-job-status.htm\n     */\n    this.executePoll = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var result;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _this.getJobInfo();\n          case 3:\n            result = _context.sent;\n            _context.next = 10;\n            break;\n          case 6:\n            _context.prev = 6;\n            _context.t0 = _context[\"catch\"](0);\n            _this.emitter.emit(JOB_STATUSES.Error, _context.t0);\n            return _context.abrupt(\"return\");\n          case 10:\n            _this.emitter.emit(JOB_STATUSES.Status, result);\n            _this.emitter.emit(result.status, result);\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[0, 6]]);\n    }));\n    var _Object$assign = Object.assign(Object.assign({}, DefaultJobOptions), options),\n      url = _Object$assign.url,\n      id = _Object$assign.id,\n      pollingRate = _Object$assign.pollingRate,\n      authentication = _Object$assign.authentication;\n    // Setup internal properties\n    this.url = url;\n    this.id = id;\n    this.authentication = authentication;\n    this._pollingRate = pollingRate;\n    this.emitter = mitt();\n    if (options.startMonitoring) {\n      this.startEventMonitoring(pollingRate);\n    }\n  }\n  _createClass(Job, [{\n    key: \"jobUrl\",\n    get:\n    /**\n     * Getter that appends the job id to the base url.\n     */\n    function get() {\n      return \"\".concat(this.url, \"/jobs/\").concat(this.id);\n    }\n    /**\n     * Returns `true` if the job is polling for status changes.\n     */\n  }, {\n    key: \"isMonitoring\",\n    get: function get() {\n      return !!this.setIntervalHandler;\n    }\n    /**\n     * The rate at which event monitoring is occurring in milliseconds.\n     */\n  }, {\n    key: \"pollingRate\",\n    get: function get() {\n      return this._pollingRate;\n    }\n    /**\n     * Sets a new polling rate and restart polling for status changes.\n     */,\n    set: function set(newRate) {\n      this.stopEventMonitoring();\n      this.startEventMonitoring(newRate);\n    }\n    /**\n     * Retrieves the status of the current job.\n     *\n     * @returns An object with the job id and jobStatus.\n     */\n  }, {\n    key: \"getJobInfo\",\n    value: function getJobInfo() {\n      return request(this.jobUrl, {\n        authentication: this.authentication\n      }).then(function (rawJobInfo) {\n        var info = Object.assign({\n          id: rawJobInfo.jobId,\n          status: undefined\n        }, rawJobInfo);\n        delete info.jobId;\n        delete info.jobStatus;\n        switch (rawJobInfo.jobStatus) {\n          case \"esriJobCancelled\":\n            info.status = JOB_STATUSES.Cancelled;\n            break;\n          case \"esriJobCancelling\":\n            info.status = JOB_STATUSES.Cancelling;\n            break;\n          case \"esriJobNew\":\n            info.status = JOB_STATUSES.New;\n            break;\n          case \"esriJobWaiting\":\n            info.status = JOB_STATUSES.Waiting;\n            break;\n          case \"esriJobExecuting\":\n            info.status = JOB_STATUSES.Executing;\n            break;\n          case \"esriJobSubmitted\":\n            info.status = JOB_STATUSES.Submitted;\n            break;\n          case \"esriJobTimedOut\":\n            info.status = JOB_STATUSES.TimedOut;\n            break;\n          case \"esriJobFailed\":\n            info.status = JOB_STATUSES.Failed;\n            break;\n          case \"expectedFailure\":\n            info.status = JOB_STATUSES.Failure;\n            break;\n          case \"esriJobSucceeded\":\n            info.status = JOB_STATUSES.Success;\n            break;\n        }\n        return info;\n      });\n    }\n    /**\n     * A handler that listens for an eventName and returns custom handler.\n     *\n     * @param eventName A string of what event to listen for.\n     * @param handler A function of what to do when eventName was called.\n     */\n  }, {\n    key: \"on\",\n    value: function on(eventName, handler) {\n      this.emitter.on(eventName, handler);\n    }\n    /**\n     * A handler that listens for an event once and returns a custom handler.\n     *\n     * @param eventName A string of what event to listen for.\n     * @param handler A function of what to do when eventName was called.\n     */\n  }, {\n    key: \"once\",\n    value: function once(eventName, handler) {\n      var _this2 = this;\n      var fn = function fn(arg) {\n        _this2.emitter.off(eventName, fn);\n        handler(arg);\n      };\n      this.emitter.on(eventName, fn);\n      handler.__arcgis_job_once_original_function__ = fn;\n    }\n    /**\n     * A handler that will remove a listener after its emitted and returns a custom handler.\n     *\n     * @param eventName A string of what event to listen for.\n     * @param handler A function of what to do when eventName was called.\n     */\n  }, {\n    key: \"off\",\n    value: function off(eventName, handler) {\n      if (handler.__arcgis_job_once_original_function__) {\n        this.emitter.off(eventName, handler.__arcgis_job_once_original_function__);\n        return;\n      }\n      this.emitter.off(eventName, handler);\n    }\n    /**\n     * Get the specific results of a successful job by result name. To get all results see {@linkcode Job.getAllResults}.\n     *\n     * If monitoring is disabled it will be enabled until the job classes resolves or rejects this promise.\n     *\n     * ```\n     * Job.submitJob(options)\n     *  .then((job) => {\n     *    return job.getResult(\"result_name\")\n     *  }).then(result => {\n     *    console.log(result);\n     *  }).catch(e => {\n     *    if(e.name === \"ArcGISJobError\") {\n     *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n     *    }\n     *  })\n     * ```\n     *\n     *  Will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n     *\n     * @param result The name of the result that you want to retrieve.\n     * @returns An object representing the individual result of the job.\n     */\n  }, {\n    key: \"getResult\",\n    value: function () {\n      var _getResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(result) {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", this.waitForCompletion().then(function (jobInfo) {\n                return request(_this3.jobUrl + \"/\" + jobInfo.results[result].paramUrl, {\n                  authentication: _this3.authentication\n                });\n              }));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getResult(_x) {\n        return _getResult.apply(this, arguments);\n      }\n      return getResult;\n    }()\n    /**\n     * Formats the requestOptions to JSON format.\n     *\n     * @returns The `Job` as a plain JavaScript object.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        url: this.url,\n        startMonitoring: this.isMonitoring,\n        pollingRate: this.pollingRate\n      };\n    }\n    /**\n     * Converts the `Job` to a JSON string. You can rehydrate the state of the `Job` with {@linkcode Job.deserialize}.\n     *\n     * @returns A JSON string representing the `Job`.\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return JSON.stringify(this);\n    }\n    /**\n     * Checks for job status and if the job status is successful it resolves the job information. Otherwise will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n     *\n     * ```\n     * Job.submitJob(options)\n     *  .then((job) => {\n     *    return job.waitForCompletion();\n     *  })\n     * .then((jobInfo) => {\n     *    console.log(\"job finished\", e.jobInfo);\n     *  })\n     * .catch(e => {\n     *    if(e.name === \"ArcGISJobError\") {\n     *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n     *    }\n     *  })\n     * ```\n     *\n     * @returns An object with a successful job status, id, and results.\n     */\n  }, {\n    key: \"waitForCompletion\",\n    value: function () {\n      var _waitForCompletion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this4 = this;\n        var jobInfo;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.getJobInfo();\n            case 2:\n              jobInfo = _context3.sent;\n              if (!(jobInfo.status === JOB_STATUSES.Success)) {\n                _context3.next = 5;\n                break;\n              }\n              return _context3.abrupt(\"return\", Promise.resolve(jobInfo));\n            case 5:\n              if (!(jobInfo.status === JOB_STATUSES.Cancelling || jobInfo.status === JOB_STATUSES.Cancelled || jobInfo.status === JOB_STATUSES.Failed || jobInfo.status === JOB_STATUSES.Failure || jobInfo.status === JOB_STATUSES.TimedOut)) {\n                _context3.next = 8;\n                break;\n              }\n              this.stopInternalEventMonitoring();\n              return _context3.abrupt(\"return\", Promise.reject(new ArcGISJobError(\"Job cancelled or failed.\", jobInfo)));\n            case 8:\n              return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                _this4.startInternalEventMonitoring();\n                _this4.once(JOB_STATUSES.Cancelled, function (jobInfo) {\n                  _this4.stopInternalEventMonitoring();\n                  reject(new ArcGISJobError(\"Job cancelled.\", jobInfo));\n                });\n                _this4.once(JOB_STATUSES.TimedOut, function (jobInfo) {\n                  _this4.stopInternalEventMonitoring();\n                  reject(new ArcGISJobError(\"Job timed out.\", jobInfo));\n                });\n                _this4.once(JOB_STATUSES.Failed, function (jobInfo) {\n                  _this4.stopInternalEventMonitoring();\n                  reject(new ArcGISJobError(\"Job failed.\", jobInfo));\n                });\n                _this4.once(JOB_STATUSES.Success, function (jobInfo) {\n                  _this4.stopInternalEventMonitoring();\n                  resolve(jobInfo);\n                });\n              }));\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function waitForCompletion() {\n        return _waitForCompletion.apply(this, arguments);\n      }\n      return waitForCompletion;\n    }()\n    /**\n     * Gets all the results from a successful job by ordering all the result paramUrl requests and calling each of them until all of them are complete and returns an object with all the results.\n     *\n     * If monitoring is disabled it will be enabled until the job classes resolves or rejects this promise.\n     *\n     * ```\n     * Job.submitJob(options)\n     *  .then((job) => {\n     *    return job.getAllResults();\n     *  }).then(allResults => {\n     *    console.log(allResults);\n     *  }).catch(e => {\n     *    if(e.name === \"ArcGISJobError\") {\n     *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n     *    }\n     *  })\n     * ```\n     *\n     * Will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n     *\n     * @returns An object representing all the results from a job.\n     */\n  }, {\n    key: \"getAllResults\",\n    value: function () {\n      var _getAllResults = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this5 = this;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", this.waitForCompletion().then(function (jobInfo) {\n                var keys = Object.keys(jobInfo.results);\n                var requests = keys.map(function (key) {\n                  return request(_this5.jobUrl + \"/\" + jobInfo.results[key].paramUrl, {\n                    authentication: _this5.authentication\n                  }).then(function (results) {\n                    return results;\n                  });\n                });\n                return Promise.all(requests).then(function (resultsArray) {\n                  return keys.reduce(function (finalResults, key, index) {\n                    finalResults[keys[index]] = resultsArray[index];\n                    return finalResults;\n                  }, {});\n                });\n              }));\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getAllResults() {\n        return _getAllResults.apply(this, arguments);\n      }\n      return getAllResults;\n    }()\n    /**\n     * Cancels the job request and voids the job.\n     *\n     * @returns An object that has job id, job status and messages array sequencing the status of the cancellation being submitted and completed.\n     */\n  }, {\n    key: \"cancelJob\",\n    value: function cancelJob() {\n      var _this6 = this;\n      return request(this.jobUrl + \"/cancel\", {\n        authentication: this.authentication,\n        params: {\n          id: this.id,\n          returnMessages: false\n        }\n      }).then(function (response) {\n        _this6.emitter.emit(\"cancelled\", response);\n        return response;\n      });\n    }\n    /**\n     * An internal monitoring if the user specifies startMonitoring: false, we need to check the status to see when the results are returned.\n     */\n  }, {\n    key: \"startInternalEventMonitoring\",\n    value: function startInternalEventMonitoring() {\n      var pollingRate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultJobOptions.pollingRate;\n      this._pollingRate = pollingRate;\n      /* istanbul ignore else - if monitoring is already running do nothing */\n      if (!this.isMonitoring) {\n        this.setIntervalHandler = setInterval(this.executePoll, this.pollingRate);\n      }\n    }\n    /**\n     * Stops the internal monitoring once the job has been successfully completed with results.\n     */\n  }, {\n    key: \"stopInternalEventMonitoring\",\n    value: function stopInternalEventMonitoring() {\n      if (this.isMonitoring && !this.didUserEnableMonitoring) {\n        clearTimeout(this.setIntervalHandler);\n      }\n    }\n    /**\n     * Starts the event polling if the user enables the startMonitoring param.\n     *\n     * @param pollingRate Able to pass in a specific number or will default to 5000.\n     */\n  }, {\n    key: \"startEventMonitoring\",\n    value: function startEventMonitoring() {\n      var pollingRate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultJobOptions.pollingRate;\n      this._pollingRate = pollingRate;\n      this.didUserEnableMonitoring = true;\n      /* istanbul ignore else - if not monitoring do nothing */\n      if (!this.isMonitoring) {\n        this.setIntervalHandler = setInterval(this.executePoll, this.pollingRate);\n      }\n    }\n    /**\n     * Stops the event polling rate. This is can only be enabled if the user calls this method directly.\n     */\n  }, {\n    key: \"stopEventMonitoring\",\n    value: function stopEventMonitoring() {\n      /* istanbul ignore else - if not monitoring do nothing */\n      if (this.isMonitoring && this.didUserEnableMonitoring) {\n        clearTimeout(this.setIntervalHandler);\n      }\n    }\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(serializeString, options) {\n      var jobOptions = Object.assign(Object.assign(Object.assign({}, DefaultJobOptions), JSON.parse(serializeString)), options);\n      return request(\"\".concat(jobOptions.url, \"/jobs/\").concat(jobOptions.id), {\n        authentication: jobOptions.authentication\n      }).then(function () {\n        return new Job(jobOptions);\n      });\n    }\n    /**\n     * Creates a new instance of {@linkcode Job} from an existing job id.\n     *\n     * @param options Requires request endpoint url and id from an existing job id.\n     * @returns An new instance of Job class with options.\n     */\n  }, {\n    key: \"fromExistingJob\",\n    value: function fromExistingJob(options) {\n      var jobOptions = Object.assign(Object.assign({}, DefaultJobOptions), options);\n      var baseUrl = cleanUrl(jobOptions.url.replace(/\\/submitJob\\/?/, \"\"));\n      return request(\"\".concat(baseUrl, \"/jobs/\").concat(jobOptions.id), {\n        authentication: jobOptions.authentication\n      }).then(function () {\n        return new Job(jobOptions);\n      });\n    }\n    /**\n     * Submits a job request that will return a new instance of {@linkcode Job}.\n     *\n     * @param requestOptions Requires url and params from requestOptions.\n     * @returns An new instance of Job class with the returned job id from submitJob request and requestOptions;\n     */\n  }, {\n    key: \"submitJob\",\n    value: function submitJob(requestOptions) {\n      var _Object$assign2 = Object.assign(Object.assign({}, DefaultJobOptions), requestOptions),\n        url = _Object$assign2.url,\n        params = _Object$assign2.params,\n        authentication = _Object$assign2.authentication,\n        pollingRate = _Object$assign2.pollingRate,\n        startMonitoring = _Object$assign2.startMonitoring;\n      var processedParams = processJobParams(params);\n      var baseUrl = cleanUrl(url.replace(/\\/submitJob\\/?/, \"\"));\n      var submitUrl = baseUrl + \"/submitJob\";\n      return request(submitUrl, {\n        params: processedParams,\n        authentication: authentication\n      }).then(function (response) {\n        return new Job({\n          url: baseUrl,\n          authentication: authentication,\n          id: response.jobId,\n          startMonitoring: startMonitoring,\n          pollingRate: pollingRate\n        });\n      });\n    }\n  }]);\n  return Job;\n}();","map":{"version":3,"names":["request","cleanUrl","ArcGISJobError","JOB_STATUSES","mitt","processJobParams","DefaultJobOptions","pollingRate","startMonitoring","Job","options","_this","_classCallCheck","executePoll","_asyncToGenerator","_regeneratorRuntime","mark","_callee","result","wrap","_callee$","_context","prev","next","getJobInfo","sent","t0","emitter","emit","Error","abrupt","Status","status","stop","_Object$assign","Object","assign","url","id","authentication","_pollingRate","startEventMonitoring","_createClass","key","get","concat","setIntervalHandler","set","newRate","stopEventMonitoring","value","jobUrl","then","rawJobInfo","info","jobId","undefined","jobStatus","Cancelled","Cancelling","New","Waiting","Executing","Submitted","TimedOut","Failed","Failure","Success","on","eventName","handler","once","_this2","fn","arg","off","__arcgis_job_once_original_function__","_getResult","_callee2","_this3","_callee2$","_context2","waitForCompletion","jobInfo","results","paramUrl","getResult","_x","apply","arguments","toJSON","isMonitoring","serialize","JSON","stringify","_waitForCompletion","_callee3","_this4","_callee3$","_context3","Promise","resolve","stopInternalEventMonitoring","reject","startInternalEventMonitoring","_getAllResults","_callee4","_this5","_callee4$","_context4","keys","requests","map","all","resultsArray","reduce","finalResults","index","getAllResults","cancelJob","_this6","params","returnMessages","response","length","setInterval","didUserEnableMonitoring","clearTimeout","deserialize","serializeString","jobOptions","parse","fromExistingJob","baseUrl","replace","submitJob","requestOptions","_Object$assign2","processedParams","submitUrl"],"sources":["C:\\code-challenge-react\\node_modules\\@esri\\arcgis-rest-request\\src\\job.ts"],"sourcesContent":["import { request } from \"./request.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\nimport { ArcGISJobError } from \"./utils/ArcGISJobError.js\";\nimport { JOB_STATUSES } from \"./types/job-statuses.js\";\nimport { IAuthenticationManager } from \"./utils/IAuthenticationManager.js\";\nimport mitt from \"mitt\";\nimport { processJobParams } from \"./utils/process-job-params.js\";\n\n/**\n * Options for creating a new {@linkcode Job}.\n */\nexport interface IJobOptions {\n  /**\n   * The ID of the job. Can be used to rehydrate an instance of {@linkcode Job} with {@linkcode Job.fromExistingJob} or {@linkcode Job.deserialize}.\n   */\n  id: string;\n\n  /**\n   * The base URL of the job without `/submitJob` or a trailing job id.\n   */\n  url: string;\n\n  /**\n   * Automatically monitor the job for status changes once it is created. Defaults to `false`.\n   */\n  startMonitoring?: boolean;\n\n  /**\n   * Rate in milliseconds to poll for job status changes. Defaults to `2000`.\n   */\n  pollingRate?: number;\n\n  /**\n   * Authentication manager or access token to use for all job requests.\n   */\n  authentication?: IAuthenticationManager | string;\n}\n\n/**\n * Options for {@linkcode Job.submitJob}.\n */\nexport interface ISubmitJobOptions {\n  /**\n   * Parameters necessary that are passed to the {@linkcode Job.submitJob} method.\n   */\n  params: any;\n\n  /**\n   * The base URL of the job without `/submitJob` or a trailing job id.\n   */\n  url: string;\n\n  /**\n   * Automatically monitor the job for status changes once it is created. Defaults to `false`.\n   */\n  startMonitoring?: boolean;\n\n  /**\n   * Rate in milliseconds to poll for job status changes. Defaults to `2000`.\n   */\n  pollingRate?: number;\n\n  /**\n   * Authentication manager or access token to use for all job requests.\n   */\n  authentication?: IAuthenticationManager | string;\n}\n\n/**\n * Describes the status of a job. See the [GP Job documentation for more information](https://developers.arcgis.com/rest/services-reference/enterprise/gp-job.htm).\n */\nexport interface IJobInfo {\n  /**\n   * The ID of the job. Can be used to rehydrate an instance of {@linkcode Job} with {@linkcode Job.fromExistingJob} or {@linkcode Job.deserialize}.\n   */\n  id: string;\n  /**\n   * Represents the status of the current job.\n   */\n  status: JOB_STATUSES;\n  /**\n   * A results property that are returned from a successful job.\n   */\n  results?: {\n    [key: string]: {\n      paramUrl: string;\n    };\n  };\n  /**\n   * An input property that are returned from a successful job.\n   */\n  inputs?: {\n    [key: string]: {\n      paramUrl: string;\n    };\n  };\n  /**\n   * A message property that are returned from a successful job.\n   */\n  messages?: Array<{\n    type: string;\n    description: string;\n  }>;\n  /**\n   * A progress property that is returned while the job status is {@linkcode JOB_STATUSES.Executing}\n   */\n  progress?: {\n    type: string;\n    message: string;\n    percentage: number;\n  };\n}\n\nconst DefaultJobOptions: Partial<IJobOptions> = {\n  pollingRate: 2000,\n  startMonitoring: false\n};\n\n/**\n * Jobs represent long running processing tasks running on ArcGIS Services. Typically these represent complex analysis tasks such as [geoprocessing tasks](https://developers.arcgis.com/rest/services-reference/enterprise/submit-gp-job.htm), [logistics analysis such as fleet routing](https://developers.arcgis.com/rest/network/api-reference/vehicle-routing-problem-service.htm) or [spatial analysis tasks](https://developers.arcgis.com/rest/analysis/api-reference/tasks-overview.htm).\n *\n * To create a {@linkcode Job}, use the {@linkcode Job.submitJob} method which will return an instance of the {@linkcode Job} class with a unique id.\n *\n * If you have an existing job you can use {@linkcode Job.serialize} and {@linkcode Job.deserialize} to save job information as a string and recreate the job to get results later.\n *\n * ```js\n * import { Job,  JOB_STATUSES  } from \"@esri/arcgis-rest-request\";\n *\n * const job  = async Job.submitJob(options);\n *\n * // will automatically wait for job completion and get results when the job is finished.\n * job.getAllResults().then((results) => {console.log(results)})\n *\n * // watch for all status updates\n * job.on(\"status\", ({jobStatus}) => {console.log(job.status)})\n * ```\n *\n * By default event monitoring is started when you call {@linkcode Job.waitForCompletion}, {@linkcode Job.getAllResults} or, {@linkcode Job.getResult} and stops automatically when those promises complete. Use {@linkcode Job.startEventMonitoring} and {@linkcode Job.stopEventMonitoring} to manually start and stop event monitoring outside those methods. Starting monitoring with {@linkcode Job.startEventMonitoring} will not stop monitoring when {@linkcode Job.waitForCompletion}, {@linkcode Job.getAllResults} or, {@linkcode Job.getResult} complete.\n */\nexport class Job {\n  static deserialize(serializeString: string, options?: IJobOptions) {\n    const jobOptions: IJobOptions = {\n      ...DefaultJobOptions,\n      ...JSON.parse(serializeString),\n      ...options\n    };\n\n    return request(`${jobOptions.url}/jobs/${jobOptions.id}`, {\n      authentication: jobOptions.authentication\n    }).then(() => {\n      return new Job(jobOptions);\n    });\n  }\n\n  /**\n   * Creates a new instance of {@linkcode Job} from an existing job id.\n   *\n   * @param options Requires request endpoint url and id from an existing job id.\n   * @returns An new instance of Job class with options.\n   */\n  static fromExistingJob(options: IJobOptions) {\n    const jobOptions: IJobOptions = {\n      ...DefaultJobOptions,\n      ...options\n    };\n    const baseUrl = cleanUrl(jobOptions.url.replace(/\\/submitJob\\/?/, \"\"));\n    return request(`${baseUrl}/jobs/${jobOptions.id}`, {\n      authentication: jobOptions.authentication\n    }).then(() => {\n      return new Job(jobOptions);\n    });\n  }\n\n  /**\n   * Submits a job request that will return a new instance of {@linkcode Job}.\n   *\n   * @param requestOptions Requires url and params from requestOptions.\n   * @returns An new instance of Job class with the returned job id from submitJob request and requestOptions;\n   */\n  static submitJob(requestOptions: ISubmitJobOptions) {\n    const {\n      url,\n      params,\n      authentication,\n      pollingRate,\n      startMonitoring\n    }: Partial<ISubmitJobOptions> = {\n      ...DefaultJobOptions,\n      ...requestOptions\n    };\n\n    const processedParams = processJobParams(params);\n    const baseUrl = cleanUrl(url.replace(/\\/submitJob\\/?/, \"\"));\n    const submitUrl = baseUrl + \"/submitJob\";\n    return request(submitUrl, {\n      params: processedParams,\n      authentication\n    }).then(\n      (response) =>\n        new Job({\n          url: baseUrl,\n          authentication,\n          id: response.jobId,\n          startMonitoring,\n          pollingRate\n        })\n    );\n  }\n\n  /**\n   * The base URL of the job.\n   */\n  readonly url: string;\n  /**\n   * The job id indicating the specific job.\n   */\n  readonly id: string;\n  /**\n   * Authentication manager or access token to use for all job requests.\n   */\n  readonly authentication: IAuthenticationManager | string;\n\n  /**\n   * Internal instance of [`mitt`](https://github.com/developit/mitt) used for event handlers. It is recommended to use {@linkcode Job.on}, {@linkcode Job.off} or {@linkcode Job.once} instead of `emitter.`\n   */\n  private emitter: any;\n\n  /**\n   * Private pollingRate that is set if the user changes the pollingRate.\n   */\n  private _pollingRate: number;\n  /**\n   * Private boolean that checks to see if the user enables startMonitoring.\n   */\n  private didUserEnableMonitoring: any;\n  /**\n   * Internal handler for `setInterval()` used when polling.;\n   */\n  private setIntervalHandler: any;\n\n\n  constructor(options: IJobOptions) {\n    const { url, id, pollingRate, authentication }: Partial<IJobOptions> = {\n      ...DefaultJobOptions,\n      ...options\n    };\n\n    // Setup internal properties\n    this.url = url;\n    this.id = id;\n    this.authentication = authentication;\n    this._pollingRate = pollingRate;\n    this.emitter = mitt();\n\n    if (options.startMonitoring) {\n      this.startEventMonitoring(pollingRate);\n    }\n  }\n\n  /**\n   * Getter that appends the job id to the base url.\n   */\n  private get jobUrl() {\n    return `${this.url}/jobs/${this.id}`;\n  }\n\n  /**\n   * Returns `true` if the job is polling for status changes.\n   */\n  get isMonitoring() {\n    return !!this.setIntervalHandler;\n  }\n\n  /**\n   * The rate at which event monitoring is occurring in milliseconds.\n   */\n  get pollingRate() {\n    return this._pollingRate;\n  }\n\n  /**\n   * Sets a new polling rate and restart polling for status changes.\n   */\n  set pollingRate(newRate: number) {\n    this.stopEventMonitoring();\n    this.startEventMonitoring(newRate);\n  }\n\n  /**\n   * Retrieves the status of the current job.\n   *\n   * @returns An object with the job id and jobStatus.\n   */\n  getJobInfo(): Promise<IJobInfo> {\n    return request(this.jobUrl, {\n      authentication: this.authentication\n    }).then((rawJobInfo: any) => {\n      const info: any = Object.assign(\n        {\n          id: rawJobInfo.jobId,\n          status: undefined\n        },\n        rawJobInfo\n      );\n\n      delete info.jobId;\n      delete info.jobStatus;\n\n      switch (rawJobInfo.jobStatus) {\n        case \"esriJobCancelled\":\n          info.status = JOB_STATUSES.Cancelled;\n          break;\n        case \"esriJobCancelling\":\n          info.status = JOB_STATUSES.Cancelling;\n          break;\n        case \"esriJobNew\":\n          info.status = JOB_STATUSES.New;\n          break;\n        case \"esriJobWaiting\":\n          info.status = JOB_STATUSES.Waiting;\n          break;\n        case \"esriJobExecuting\":\n          info.status = JOB_STATUSES.Executing;\n          break;\n        case \"esriJobSubmitted\":\n          info.status = JOB_STATUSES.Submitted;\n          break;\n        case \"esriJobTimedOut\":\n          info.status = JOB_STATUSES.TimedOut;\n          break;\n        case \"esriJobFailed\":\n          info.status = JOB_STATUSES.Failed;\n          break;\n        case \"expectedFailure\":\n          info.status = JOB_STATUSES.Failure;\n          break;\n        case \"esriJobSucceeded\":\n          info.status = JOB_STATUSES.Success;\n          break;\n      }\n\n      return info as IJobInfo;\n    });\n  }\n\n  /**\n   * Function that calls the {@linkcode Job.getJobInfo} to check the job status, and emits the current job status. There are custom event emitters that\n   * the user is able to listen based on the job status. Refer to {@linkcode JOB_STATUSES} to see the various enums of the job status.\n   * To get results array from the job task, the job status must be {@linkcode JOB_STATUSES.Success}.\n   *\n   * These job statuses are based on what are returned from the job request task and have been into an enum type in {@linkcode JOB_STATUSES}.\n   *\n   * Reference https://developers.arcgis.com/rest/services-reference/enterprise/geoanalytics-checking-job-status.htm\n   */\n  private executePoll = async () => {\n    let result;\n    try {\n      result = await this.getJobInfo();\n    } catch (error) {\n      this.emitter.emit(JOB_STATUSES.Error, error);\n      return;\n    }\n\n    this.emitter.emit(JOB_STATUSES.Status, result);\n    this.emitter.emit(result.status, result);\n  };\n\n  /**\n   * A handler that listens for an eventName and returns custom handler.\n   *\n   * @param eventName A string of what event to listen for.\n   * @param handler A function of what to do when eventName was called.\n   */\n  on(eventName: string, handler: (e: IJobInfo) => void) {\n    this.emitter.on(eventName, handler);\n  }\n\n  /**\n   * A handler that listens for an event once and returns a custom handler.\n   *\n   * @param eventName A string of what event to listen for.\n   * @param handler A function of what to do when eventName was called.\n   */\n  once(eventName: string, handler: (e: IJobInfo) => void) {\n    const fn = (arg: any) => {\n      this.emitter.off(eventName, fn);\n      handler(arg);\n    };\n\n    this.emitter.on(eventName, fn);\n\n    (handler as any).__arcgis_job_once_original_function__ = fn;\n  }\n\n  /**\n   * A handler that will remove a listener after its emitted and returns a custom handler.\n   *\n   * @param eventName A string of what event to listen for.\n   * @param handler A function of what to do when eventName was called.\n   */\n  off(eventName: string, handler: (e: IJobInfo) => void) {\n    if ((handler as any).__arcgis_job_once_original_function__) {\n      this.emitter.off(\n        eventName,\n        (handler as any).__arcgis_job_once_original_function__\n      );\n      return;\n    }\n    this.emitter.off(eventName, handler);\n  }\n\n  /**\n   * Get the specific results of a successful job by result name. To get all results see {@linkcode Job.getAllResults}.\n   *\n   * If monitoring is disabled it will be enabled until the job classes resolves or rejects this promise.\n   *\n   * ```\n   * Job.submitJob(options)\n   *  .then((job) => {\n   *    return job.getResult(\"result_name\")\n   *  }).then(result => {\n   *    console.log(result);\n   *  }).catch(e => {\n   *    if(e.name === \"ArcGISJobError\") {\n   *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n   *    }\n   *  })\n   * ```\n   *\n   *  Will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n   *\n   * @param result The name of the result that you want to retrieve.\n   * @returns An object representing the individual result of the job.\n   */\n  async getResult(result: string) {\n    return this.waitForCompletion().then((jobInfo: any) => {\n      return request(this.jobUrl + \"/\" + jobInfo.results[result].paramUrl, {\n        authentication: this.authentication\n      });\n    });\n  }\n\n  /**\n   * Formats the requestOptions to JSON format.\n   *\n   * @returns The `Job` as a plain JavaScript object.\n   */\n  toJSON(): IJobOptions {\n    return {\n      id: this.id,\n      url: this.url,\n      startMonitoring: this.isMonitoring,\n      pollingRate: this.pollingRate\n    };\n  }\n\n  /**\n   * Converts the `Job` to a JSON string. You can rehydrate the state of the `Job` with {@linkcode Job.deserialize}.\n   *\n   * @returns A JSON string representing the `Job`.\n   */\n  serialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Checks for job status and if the job status is successful it resolves the job information. Otherwise will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n   *\n   * ```\n   * Job.submitJob(options)\n   *  .then((job) => {\n   *    return job.waitForCompletion();\n   *  })\n   * .then((jobInfo) => {\n   *    console.log(\"job finished\", e.jobInfo);\n   *  })\n   * .catch(e => {\n   *    if(e.name === \"ArcGISJobError\") {\n   *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n   *    }\n   *  })\n   * ```\n   *\n   * @returns An object with a successful job status, id, and results.\n   */\n  async waitForCompletion(): Promise<IJobInfo> {\n    const jobInfo = await this.getJobInfo();\n    if (jobInfo.status === JOB_STATUSES.Success) {\n      return Promise.resolve(jobInfo);\n    }\n    //if jobStatus comes back immediately with one of the statuses\n    if (\n      jobInfo.status === JOB_STATUSES.Cancelling ||\n      jobInfo.status === JOB_STATUSES.Cancelled ||\n      jobInfo.status === JOB_STATUSES.Failed ||\n      jobInfo.status === JOB_STATUSES.Failure ||\n      jobInfo.status === JOB_STATUSES.TimedOut\n    ) {\n      this.stopInternalEventMonitoring();\n\n      return Promise.reject(\n        new ArcGISJobError(\"Job cancelled or failed.\", jobInfo)\n      );\n    }\n\n    //waits to see what the status is if not immediate\n    return new Promise((resolve, reject) => {\n      this.startInternalEventMonitoring();\n\n      this.once(JOB_STATUSES.Cancelled, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        reject(new ArcGISJobError(\"Job cancelled.\", jobInfo));\n      });\n\n      this.once(JOB_STATUSES.TimedOut, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        reject(new ArcGISJobError(\"Job timed out.\", jobInfo));\n      });\n\n      this.once(JOB_STATUSES.Failed, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        reject(new ArcGISJobError(\"Job failed.\", jobInfo));\n      });\n\n      this.once(JOB_STATUSES.Success, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        resolve(jobInfo);\n      });\n    });\n  }\n\n  /**\n   * Gets all the results from a successful job by ordering all the result paramUrl requests and calling each of them until all of them are complete and returns an object with all the results.\n   *\n   * If monitoring is disabled it will be enabled until the job classes resolves or rejects this promise.\n   *\n   * ```\n   * Job.submitJob(options)\n   *  .then((job) => {\n   *    return job.getAllResults();\n   *  }).then(allResults => {\n   *    console.log(allResults);\n   *  }).catch(e => {\n   *    if(e.name === \"ArcGISJobError\") {\n   *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n   *    }\n   *  })\n   * ```\n   *\n   * Will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n   *\n   * @returns An object representing all the results from a job.\n   */\n  async getAllResults() {\n    return this.waitForCompletion().then((jobInfo: any) => {\n      const keys = Object.keys(jobInfo.results);\n\n      const requests = keys.map((key) => {\n        return request(this.jobUrl + \"/\" + jobInfo.results[key].paramUrl, {\n          authentication: this.authentication\n        }).then((results) => {\n          return results;\n        });\n      });\n\n      return Promise.all(requests).then((resultsArray: any) => {\n        return keys.reduce((finalResults: any, key: string, index: number) => {\n          finalResults[keys[index]] = resultsArray[index];\n          return finalResults;\n        }, {});\n      });\n    });\n  }\n\n  /**\n   * Cancels the job request and voids the job.\n   *\n   * @returns An object that has job id, job status and messages array sequencing the status of the cancellation being submitted and completed.\n   */\n  cancelJob() {\n    return request(this.jobUrl + \"/cancel\", {\n      authentication: this.authentication,\n      params: { id: this.id, returnMessages: false }\n    }).then((response: any) => {\n      this.emitter.emit(\"cancelled\", response);\n      return response;\n    });\n  }\n\n  /**\n   * An internal monitoring if the user specifies startMonitoring: false, we need to check the status to see when the results are returned.\n   */\n  private startInternalEventMonitoring(\n    pollingRate = DefaultJobOptions.pollingRate\n  ) {\n    this._pollingRate = pollingRate;\n\n    /* istanbul ignore else - if monitoring is already running do nothing */\n    if (!this.isMonitoring) {\n      this.setIntervalHandler = setInterval(this.executePoll, this.pollingRate);\n    }\n  }\n\n  /**\n   * Stops the internal monitoring once the job has been successfully completed with results.\n   */\n  private stopInternalEventMonitoring() {\n    if (this.isMonitoring && !this.didUserEnableMonitoring) {\n      clearTimeout(this.setIntervalHandler);\n    }\n  }\n\n  /**\n   * Starts the event polling if the user enables the startMonitoring param.\n   *\n   * @param pollingRate Able to pass in a specific number or will default to 5000.\n   */\n  startEventMonitoring(pollingRate = DefaultJobOptions.pollingRate) {\n    this._pollingRate = pollingRate;\n    this.didUserEnableMonitoring = true;\n\n    /* istanbul ignore else - if not monitoring do nothing */\n    if (!this.isMonitoring) {\n      this.setIntervalHandler = setInterval(this.executePoll, this.pollingRate);\n    }\n  }\n\n  /**\n   * Stops the event polling rate. This is can only be enabled if the user calls this method directly.\n   */\n  stopEventMonitoring() {\n    /* istanbul ignore else - if not monitoring do nothing */\n    if (this.isMonitoring && this.didUserEnableMonitoring) {\n      clearTimeout(this.setIntervalHandler);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}