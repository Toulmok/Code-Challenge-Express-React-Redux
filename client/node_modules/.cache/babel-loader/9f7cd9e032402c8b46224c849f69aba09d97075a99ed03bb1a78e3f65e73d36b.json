{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { c as e } from \"../../../../../../chunks/vec3f64.js\";\nimport { RgbaFloatEncoding as a } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { textureSize as s } from \"../util/WebGL2Utils.js\";\nimport { Float4PassUniform as o } from \"../../shaderModules/Float4PassUniform.js\";\nimport { IntegerPassUniform as t } from \"../../shaderModules/IntegerPassUniform.js\";\nimport { NoParameters as i, glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4sDrawUniform as d } from \"../../shaderModules/Matrix4sDrawUniform.js\";\nimport { Matrix4sPassUniform as l } from \"../../shaderModules/Matrix4sPassUniform.js\";\nimport { createTexture2DPassSizeUniforms as p } from \"../../shaderModules/Texture2DPassUniform.js\";\nimport { TextureSizeUniformType as c } from \"../../shaderModules/TextureSizeUniformType.js\";\nclass n extends i {\n  constructor() {\n    super(...arguments), this.origin = e();\n  }\n}\nfunction h(e, a) {\n  a.receiveShadows && (e.fragment.uniforms.add(new l(\"shadowMapMatrix\", (e, a) => a.shadowMap.getShadowMapMatrices(e.origin), 4)), f(e, a));\n}\nfunction v(e, a) {\n  a.receiveShadows && (e.fragment.uniforms.add(new d(\"shadowMapMatrix\", (e, a) => a.shadowMap.getShadowMapMatrices(e.origin), 4)), f(e, a));\n}\nfunction f(e, i) {\n  const d = e.fragment;\n  d.include(a), d.uniforms.add([...p(\"shadowMapTex\", (e, a) => a.shadowMap.depthTexture, i.hasWebGL2Context ? c.None : c.Size), new t(\"numCascades\", (e, a) => a.shadowMap.numCascades), new o(\"cascadeDistances\", (e, a) => a.shadowMap.cascadeDistances)]), d.code.add(r`\n    int chooseCascade(float depth, out mat4 mat) {\n      vec4 distance = cascadeDistances;\n\n      // choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      return i;\n    }\n\n    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n      return 0.5 * lv.xyz + vec3(0.5);\n    }\n\n    vec2 cascadeCoordinates(int i, vec3 lvpos) {\n      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n    }\n\n    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\n      return rgba2float(texture2D(_depthTex, uv));\n    }\n\n    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\n      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n    }\n\n    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {\n      float halfPixelSize = 0.5 / textureSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);\n\n      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\n      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      mat4 mat;\n      int i = chooseCascade(_linearDepth, mat);\n\n      if (i >= numCascades) { return 0.0; }\n\n      vec3 lvpos = lightSpacePosition(_vpos, mat);\n\n      // vertex completely outside? -> no shadow\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = cascadeCoordinates(i, lvpos);\n\n      vec2 textureSize = ${s(i, \"shadowMapTex\")};\n\n      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);\n    }\n  `);\n}\nexport { n as ReadShadowMapBindParameters, v as ReadShadowMapDraw, h as ReadShadowMapPass };","map":{"version":3,"names":["c","e","RgbaFloatEncoding","a","textureSize","s","Float4PassUniform","o","IntegerPassUniform","t","NoParameters","i","glsl","r","Matrix4sDrawUniform","d","Matrix4sPassUniform","l","createTexture2DPassSizeUniforms","p","TextureSizeUniformType","n","constructor","arguments","origin","h","receiveShadows","fragment","uniforms","add","shadowMap","getShadowMapMatrices","f","v","include","depthTexture","hasWebGL2Context","None","Size","numCascades","cascadeDistances","code","ReadShadowMapBindParameters","ReadShadowMapDraw","ReadShadowMapPass"],"sources":["C:/code-challenge-react/client/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{c as e}from\"../../../../../../chunks/vec3f64.js\";import{RgbaFloatEncoding as a}from\"../util/RgbaFloatEncoding.glsl.js\";import{textureSize as s}from\"../util/WebGL2Utils.js\";import{Float4PassUniform as o}from\"../../shaderModules/Float4PassUniform.js\";import{IntegerPassUniform as t}from\"../../shaderModules/IntegerPassUniform.js\";import{NoParameters as i,glsl as r}from\"../../shaderModules/interfaces.js\";import{Matrix4sDrawUniform as d}from\"../../shaderModules/Matrix4sDrawUniform.js\";import{Matrix4sPassUniform as l}from\"../../shaderModules/Matrix4sPassUniform.js\";import{createTexture2DPassSizeUniforms as p}from\"../../shaderModules/Texture2DPassUniform.js\";import{TextureSizeUniformType as c}from\"../../shaderModules/TextureSizeUniformType.js\";class n extends i{constructor(){super(...arguments),this.origin=e()}}function h(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new l(\"shadowMapMatrix\",((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),f(e,a))}function v(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new d(\"shadowMapMatrix\",((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),f(e,a))}function f(e,i){const d=e.fragment;d.include(a),d.uniforms.add([...p(\"shadowMapTex\",((e,a)=>a.shadowMap.depthTexture),i.hasWebGL2Context?c.None:c.Size),new t(\"numCascades\",((e,a)=>a.shadowMap.numCascades)),new o(\"cascadeDistances\",((e,a)=>a.shadowMap.cascadeDistances))]),d.code.add(r`\n    int chooseCascade(float depth, out mat4 mat) {\n      vec4 distance = cascadeDistances;\n\n      // choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      return i;\n    }\n\n    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n      return 0.5 * lv.xyz + vec3(0.5);\n    }\n\n    vec2 cascadeCoordinates(int i, vec3 lvpos) {\n      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n    }\n\n    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\n      return rgba2float(texture2D(_depthTex, uv));\n    }\n\n    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\n      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n    }\n\n    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {\n      float halfPixelSize = 0.5 / textureSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);\n\n      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\n      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\n      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      mat4 mat;\n      int i = chooseCascade(_linearDepth, mat);\n\n      if (i >= numCascades) { return 0.0; }\n\n      vec3 lvpos = lightSpacePosition(_vpos, mat);\n\n      // vertex completely outside? -> no shadow\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = cascadeCoordinates(i, lvpos);\n\n      vec2 textureSize = ${s(i,\"shadowMapTex\")};\n\n      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);\n    }\n  `)}export{n as ReadShadowMapBindParameters,v as ReadShadowMapDraw,h as ReadShadowMapPass};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}