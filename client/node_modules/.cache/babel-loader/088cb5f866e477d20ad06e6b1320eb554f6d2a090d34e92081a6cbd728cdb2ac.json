{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { f as o } from \"../../../../../../chunks/vec2f64.js\";\nimport { IsNaN as r } from \"../../../core/shaderLibrary/util/IsNaN.glsl.js\";\nimport { Float2PassUniform as e } from \"../../../core/shaderModules/Float2PassUniform.js\";\nimport { glsl as a } from \"../../../core/shaderModules/interfaces.js\";\nimport { Matrix3PassUniform as s } from \"../../../core/shaderModules/Matrix3PassUniform.js\";\nimport { Matrix4PassUniform as t } from \"../../../core/shaderModules/Matrix4PassUniform.js\";\nconst l = o(.5, -4e-4);\nfunction i(o, i) {\n  const c = o.vertex;\n  c.include(r), c.constants.add(\"depthBias\", \"vec2\", l), c.uniforms.add(new e(\"inverseViewport\", (o, r) => r.inverseViewport)), i.legacy ? (c.uniforms.add(new t(\"proj\", (o, r) => r.camera.projectionMatrix)), c.code.add(a`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {\nfloat offsetXY = depthBias.x;\nvec4 projNormal = proj * localView * vec4(globalNormal, 0.0);\nreturn offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;\n}`)) : (c.uniforms.add(new s(\"transformNormalViewFromGlobal\", o => o.transformNormalViewFromGlobal)), c.uniforms.add(new t(\"transformProjFromView\", o => o.transformProjFromView)), c.code.add(a`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {\nfloat offsetXY = depthBias.x;\nvec4 projNormal = transformProjFromView * vec4(transformNormalViewFromGlobal * globalNormal, 0.0);\nreturn offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;\n}`)), c.code.add(a`float _calculateProjectedBiasZ(vec4 projPos) {\nfloat offsetZ = depthBias.y;\nreturn sqrt(max(projPos.z,0.0)) * offsetZ;\n}\nvec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\nvec2 offsetXY = calculateProjectedBiasXY(projPos, worldNormal);\nif (!isNaN(offsetXY.x) && !isNaN(offsetXY.y)) {\nprojPos.xy += offsetXY;\n}\nprojPos.z += _calculateProjectedBiasZ(projPos);\nreturn projPos;\n}`);\n}\nexport { i as AdjustProjectedPosition };","map":{"version":3,"names":["f","o","IsNaN","r","Float2PassUniform","e","glsl","a","Matrix3PassUniform","s","Matrix4PassUniform","t","l","i","c","vertex","include","constants","add","uniforms","inverseViewport","legacy","camera","projectionMatrix","code","transformNormalViewFromGlobal","transformProjFromView","AdjustProjectedPosition"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{f as o}from\"../../../../../../chunks/vec2f64.js\";import{IsNaN as r}from\"../../../core/shaderLibrary/util/IsNaN.glsl.js\";import{Float2PassUniform as e}from\"../../../core/shaderModules/Float2PassUniform.js\";import{glsl as a}from\"../../../core/shaderModules/interfaces.js\";import{Matrix3PassUniform as s}from\"../../../core/shaderModules/Matrix3PassUniform.js\";import{Matrix4PassUniform as t}from\"../../../core/shaderModules/Matrix4PassUniform.js\";const l=o(.5,-4e-4);function i(o,i){const c=o.vertex;c.include(r),c.constants.add(\"depthBias\",\"vec2\",l),c.uniforms.add(new e(\"inverseViewport\",((o,r)=>r.inverseViewport))),i.legacy?(c.uniforms.add(new t(\"proj\",((o,r)=>r.camera.projectionMatrix))),c.code.add(a`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {\nfloat offsetXY = depthBias.x;\nvec4 projNormal = proj * localView * vec4(globalNormal, 0.0);\nreturn offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;\n}`)):(c.uniforms.add(new s(\"transformNormalViewFromGlobal\",(o=>o.transformNormalViewFromGlobal))),c.uniforms.add(new t(\"transformProjFromView\",(o=>o.transformProjFromView))),c.code.add(a`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {\nfloat offsetXY = depthBias.x;\nvec4 projNormal = transformProjFromView * vec4(transformNormalViewFromGlobal * globalNormal, 0.0);\nreturn offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;\n}`)),c.code.add(a`float _calculateProjectedBiasZ(vec4 projPos) {\nfloat offsetZ = depthBias.y;\nreturn sqrt(max(projPos.z,0.0)) * offsetZ;\n}\nvec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\nvec2 offsetXY = calculateProjectedBiasXY(projPos, worldNormal);\nif (!isNaN(offsetXY.x) && !isNaN(offsetXY.y)) {\nprojPos.xy += offsetXY;\n}\nprojPos.z += _calculateProjectedBiasZ(projPos);\nreturn projPos;\n}`)}export{i as AdjustProjectedPosition};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,CAAC,IAAIC,CAAC,QAAK,qCAAqC;AAAC,SAAOC,KAAK,IAAIC,CAAC,QAAK,gDAAgD;AAAC,SAAOC,iBAAiB,IAAIC,CAAC,QAAK,kDAAkD;AAAC,SAAOC,IAAI,IAAIC,CAAC,QAAK,2CAA2C;AAAC,SAAOC,kBAAkB,IAAIC,CAAC,QAAK,mDAAmD;AAAC,SAAOC,kBAAkB,IAAIC,CAAC,QAAK,mDAAmD;AAAC,MAAMC,CAAC,GAACX,CAAC,CAAC,EAAE,EAAC,CAAC,IAAI,CAAC;AAAC,SAASY,CAACA,CAACZ,CAAC,EAACY,CAAC,EAAC;EAAC,MAAMC,CAAC,GAACb,CAAC,CAACc,MAAM;EAACD,CAAC,CAACE,OAAO,CAACb,CAAC,CAAC,EAACW,CAAC,CAACG,SAAS,CAACC,GAAG,CAAC,WAAW,EAAC,MAAM,EAACN,CAAC,CAAC,EAACE,CAAC,CAACK,QAAQ,CAACD,GAAG,CAAC,IAAIb,CAAC,CAAC,iBAAiB,EAAE,CAACJ,CAAC,EAACE,CAAC,KAAGA,CAAC,CAACiB,eAAe,CAAE,CAAC,EAACP,CAAC,CAACQ,MAAM,IAAEP,CAAC,CAACK,QAAQ,CAACD,GAAG,CAAC,IAAIP,CAAC,CAAC,MAAM,EAAE,CAACV,CAAC,EAACE,CAAC,KAAGA,CAAC,CAACmB,MAAM,CAACC,gBAAgB,CAAE,CAAC,EAACT,CAAC,CAACU,IAAI,CAACN,GAAG,CAACX,CAAE;AACvsB;AACA;AACA;AACA,EAAE,CAAC,KAAGO,CAAC,CAACK,QAAQ,CAACD,GAAG,CAAC,IAAIT,CAAC,CAAC,+BAA+B,EAAER,CAAC,IAAEA,CAAC,CAACwB,6BAA6B,CAAE,CAAC,EAACX,CAAC,CAACK,QAAQ,CAACD,GAAG,CAAC,IAAIP,CAAC,CAAC,uBAAuB,EAAEV,CAAC,IAAEA,CAAC,CAACyB,qBAAqB,CAAE,CAAC,EAACZ,CAAC,CAACU,IAAI,CAACN,GAAG,CAACX,CAAE;AAC3L;AACA;AACA;AACA,EAAE,CAAC,CAAC,EAACO,CAAC,CAACU,IAAI,CAACN,GAAG,CAACX,CAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC;AAAA;AAAC,SAAOM,CAAC,IAAIc,uBAAuB"},"metadata":{},"sourceType":"module","externalDependencies":[]}