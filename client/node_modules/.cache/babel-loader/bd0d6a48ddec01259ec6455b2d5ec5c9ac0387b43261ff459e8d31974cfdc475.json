{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { unwrapOr as e } from \"../core/maybe.js\";\nimport { addLinearDepth as i, addCalculateLinearDepth as t } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { ShaderOutput as o } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as r } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { ObjectAndLayerIdColor as n } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";\nimport { RibbonVertexPosition as a } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { OutputDepth as s } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { LineStipple as l, computePixelSize as d } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";\nimport { MarkerSizing as p } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";\nimport { multipassTerrainTest as c } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { PiUtils as g } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";\nimport { symbolAlphaCutoff as m } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as v } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as f } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as D } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as b } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as S } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as x } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { TransparencyPassType as L } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nimport { VertexAttribute as w } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { LineMarkerSpace as y } from \"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";\nimport { CapType as C } from \"../views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js\";\nconst j = 1;\nfunction R(R) {\n  const A = new x(),\n    {\n      vertex: P,\n      fragment: F\n    } = A,\n    z = R.hasMultipassTerrain && (R.output === o.Color || R.output === o.Alpha);\n  A.include(g), A.include(a, R), A.include(l, R);\n  const E = R.applyMarkerOffset && !R.draped;\n  E && (P.uniforms.add(new D(\"markerScale\", e => e.markerScale)), A.include(p, {\n    space: y.World\n  })), R.output === o.Depth && A.include(s, R), A.include(n, R), f(P, R), P.uniforms.add([new S(\"inverseProjectionMatrix\", (e, i) => i.camera.inverseProjectionMatrix), new h(\"nearFar\", (e, i) => i.camera.nearFar), new D(\"miterLimit\", e => \"miter\" !== e.join ? 0 : e.miterLimit), new u(\"viewport\", (e, i) => i.camera.fullViewport)]), P.constants.add(\"LARGE_HALF_FLOAT\", \"float\", 65500), A.attributes.add(w.POSITION, \"vec3\"), A.attributes.add(w.SUBDIVISIONFACTOR, \"float\"), A.attributes.add(w.UV0, \"vec2\"), A.attributes.add(w.AUXPOS1, \"vec3\"), A.attributes.add(w.AUXPOS2, \"vec3\"), A.varyings.add(\"vColor\", \"vec4\"), A.varyings.add(\"vpos\", \"vec3\"), i(A), z && A.varyings.add(\"depth\", \"float\");\n  const T = R.capType === C.ROUND,\n    W = R.stippleEnabled && R.stippleScaleWithLineWidth || T;\n  W && A.varyings.add(\"vLineWidth\", \"float\");\n  const O = R.stippleEnabled && R.stippleScaleWithLineWidth;\n  O && A.varyings.add(\"vLineSizeInv\", \"float\");\n  const V = R.innerColorEnabled || T;\n  V && A.varyings.add(\"vLineDistance\", \"float\");\n  const N = R.stippleEnabled && T,\n    I = R.falloffEnabled || N;\n  I && A.varyings.add(\"vLineDistanceNorm\", \"float\"), T && (A.varyings.add(\"vSegmentSDF\", \"float\"), A.varyings.add(\"vReverseSegmentSDF\", \"float\")), P.code.add(b`#define PERPENDICULAR(v) vec2(v.y, -v.x);\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`), P.code.add(b`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), t(A), P.code.add(b`\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearFar[0] * 0.99;\n\n      if(pos.z > -nearFar[0]) {\n        //current pos behind ncp --> we need to clip\n        if (!isStartVertex) {\n          if(prev.z < -nearFar[0]) {\n            //previous in front of ncp\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        } else {\n          if(next.z < -nearFar[0]) {\n            //next in front of ncp\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        if (prev.z > -nearFar[0]) {\n          //previous behind ncp\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        if (next.z > -nearFar[0]) {\n          //next behind ncp\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      ${z ? \"depth = pos.z;\" : \"\"}\n      linearDepth = calculateLinearDepth(nearFar,pos.z);\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n  `), P.uniforms.add(new D(\"pixelRatio\", (e, i) => i.camera.pixelRatio)), P.code.add(b`\n  void main(void) {\n    // unpack values from uv0.y\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n\n    float coverage = 1.0;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isJoin = abs(uv0.y) < 3.0;\n\n      float lineSize = getSize();\n      float lineWidth = lineSize * pixelRatio;\n\n      ${W ? b`vLineWidth = lineWidth;` : \"\"}\n      ${O ? b`vLineSizeInv = 1.0 / lineSize;` : \"\"}\n\n      // convert sub-pixel coverage to alpha\n      if (lineWidth < 1.0) {\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }else{\n        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if\n        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly\n        // so we only really care to round anything larger than 1.\n        lineWidth = floor(lineWidth + 0.5);\n      }\n\n      vec4 pos  = view * vec4(position.xyz, 1.0);\n      vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n      vec4 next = view * vec4(auxpos2.xyz, 1.0);\n  `), E && P.code.add(b`vec4 other = isStartVertex ? next : prev;\nbool markersHidden = areWorldMarkersHidden(pos, other);\nif(!isJoin && !markersHidden) {\npos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;\n}`), P.code.add(b`clipAndTransform(pos, prev, next, isStartVertex);\nvec2 left = (pos.xy - prev.xy);\nvec2 right = (next.xy - pos.xy);\nfloat leftLen = length(left);\nfloat rightLen = length(right);`);\n  (R.stippleEnabled || T) && P.code.add(b`\n      float isEndVertex = float(!isStartVertex);\n      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);\n      vec2 segment = mix(right, left, isEndVertex);\n      ${T ? b`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);` : \"\"}\n    `), P.code.add(b`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`), R.roundJoins ? P.code.add(b`\n        vec2 startDir = leftLen < 0.001 ? right : left;\n        startDir = PERPENDICULAR(startDir);\n\n        vec2 endDir = rightLen < 0.001 ? left : right;\n        endDir = PERPENDICULAR(endDir);\n\n        float factor = ${R.stippleEnabled ? b`min(1.0, subdivisionFactor * ${b.float((j + 2) / (j + 1))})` : b`subdivisionFactor`};\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);\n      `) : P.code.add(b`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;\n}\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);\n  const _ = R.capType !== C.BUTT;\n  return P.code.add(b`\n        displacementLen = lineWidth;\n      }\n    } else {\n      // CAP handling ---------------------------------------------------\n      joinDisplacementDir = isStartVertex ? right : left;\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      ${_ ? b`capDisplacementDir = isStartVertex ? -right : left;` : \"\"}\n    }\n  `), P.code.add(b`\n    // Displacement (in pixels) caused by join/or cap\n    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n\n    ${I || V ? b`float lineDistNorm = sign(uv0.y) * pos.w;` : \"\"}\n\n    ${V ? b`vLineDistance = lineWidth * lineDistNorm;` : \"\"}\n    ${I ? b`vLineDistanceNorm = lineDistNorm;` : \"\"}\n\n    pos.xy += dpos;\n  `), T && P.code.add(b`vec2 segmentDir = normalize(segment);\nvSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;\nvReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`), R.stippleEnabled && (R.draped ? P.uniforms.add(new D(\"worldToScreenRatio\", (e, i) => 1 / i.screenToPCSRatio)) : P.code.add(b`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);\nfloat worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), P.code.add(b`float segmentLengthScreenDouble = length(segment);\nfloat segmentLengthScreen = segmentLengthScreenDouble * 0.5;\nfloat discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);\nfloat segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));\nvStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`), R.draped ? P.code.add(b`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;\nfloat startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`) : P.code.add(b`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;\nfloat segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), P.uniforms.add(new D(\"stipplePatternPixelSize\", e => d(e))), P.code.add(b`\n      float patternLength = ${R.stippleScaleWithLineWidth ? \"lineSize * \" : \"\"} stipplePatternPixelSize;\n\n      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader\n      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);\n\n      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);\n\n      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)\n      if (segmentLengthScreenDouble >= 0.001) {\n        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the\n        // original vertex positions, and slightly outside of that range at the displaced positions\n        vec2 stippleDisplacement = pos.xy - segmentOrigin;\n        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);\n\n        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)\n        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);\n      }\n\n      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance\n      vStippleDistanceLimits *= pos.w;\n      vStippleDistance *= pos.w;\n\n      // Disable stipple distance limits on caps\n      vStippleDistanceLimits = isJoin ?\n                                 vStippleDistanceLimits :\n                                 isStartVertex ?\n                                  vec2(-1e038, vStippleDistanceLimits.y) :\n                                  vec2(vStippleDistanceLimits.x, 1e038);\n    `)), P.code.add(b`\n      // Convert back into NDC\n      pos.xy = (pos.xy / viewport.zw) * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      ${R.wireframe && !R.draped ? \"pos.z -= 0.001 * pos.w;\" : \"\"}\n\n      // transform final position to camera space for slicing\n      vpos = (inverseProjectionMatrix * pos).xyz;\n      gl_Position = pos;\n      forwardObjectAndLayerIdColor();\n    }\n  }\n  `), z && A.include(c, R), A.include(r, R), F.include(v), F.code.add(b`\n  void main() {\n    discardBySlice(vpos);\n    ${z ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n  `), R.wireframe ? F.code.add(b`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`) : (T && F.code.add(b`\n      float sdf = min(vSegmentSDF, vReverseSegmentSDF);\n      vec2 fragmentPosition = vec2(\n        min(sdf, 0.0),\n        vLineDistance\n      ) * gl_FragCoord.w;\n\n      float fragmentRadius = length(fragmentPosition);\n      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);\n\n      if (capCoverage < ${b.float(m)}) {\n        discard;\n      }\n    `), N ? F.code.add(b`\n      vec2 stipplePosition = vec2(\n        min(getStippleSDF() * 2.0 - 1.0, 0.0),\n        vLineDistanceNorm * gl_FragCoord.w\n      );\n      float stippleRadius = length(stipplePosition * vLineWidth);\n      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);\n      float stippleAlpha = step(${b.float(m)}, stippleCoverage);\n      `) : F.code.add(b`float stippleAlpha = getStippleAlpha();`), F.uniforms.add(new u(\"intrinsicColor\", e => e.color)), R.output !== o.ObjectAndLayerIdColor && F.code.add(b`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`), F.code.add(b`vec4 color = intrinsicColor * vColor;`), R.innerColorEnabled && (F.uniforms.add(new u(\"innerColor\", i => e(i.innerColor, i.color))), F.uniforms.add(new D(\"innerWidth\", (e, i) => e.innerWidth * i.camera.pixelRatio)), F.code.add(b`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)), F.code.add(b`vec4 finalColor = blendStipple(color, stippleAlpha);`), R.falloffEnabled && (F.uniforms.add(new D(\"falloff\", e => e.falloff)), F.code.add(b`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))), F.code.add(b`\n    ${R.output === o.ObjectAndLayerIdColor ? b`finalColor.a = 1.0;` : \"\"}\n\n    if (finalColor.a < ${b.float(m)}) {\n      discard;\n    }\n\n    ${R.output === o.Alpha ? b`gl_FragColor = vec4(finalColor.a);` : \"\"}\n    ${R.output === o.Color ? b`gl_FragColor = highlightSlice(finalColor, vpos);` : \"\"}\n    ${R.output === o.Color && R.transparencyPassType === L.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n    ${R.output === o.Highlight ? b`gl_FragColor = vec4(1.0);` : \"\"}\n    ${R.output === o.Depth ? b`outputDepth(linearDepth);` : \"\"}\n    ${R.output === o.ObjectAndLayerIdColor ? b`outputObjectAndLayerIdColor();` : \"\"}\n  }\n  `), A;\n}\nconst A = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  RIBBONLINE_NUM_ROUND_JOIN_SUBDIVISIONS: j,\n  build: R\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { j as R, A as a, R as b };","map":{"version":3,"names":["unwrapOr","e","addLinearDepth","i","addCalculateLinearDepth","t","ShaderOutput","o","SliceDraw","r","ObjectAndLayerIdColor","n","RibbonVertexPosition","a","OutputDepth","s","LineStipple","l","computePixelSize","d","MarkerSizing","p","multipassTerrainTest","c","PiUtils","g","symbolAlphaCutoff","m","ColorConversion","v","addProjViewLocalOrigin","f","Float2PassUniform","h","Float4PassUniform","u","FloatPassUniform","D","glsl","b","Matrix4PassUniform","S","ShaderBuilder","x","TransparencyPassType","L","VertexAttribute","w","LineMarkerSpace","y","CapType","C","j","R","A","vertex","P","fragment","F","z","hasMultipassTerrain","output","Color","Alpha","include","E","applyMarkerOffset","draped","uniforms","add","markerScale","space","World","Depth","camera","inverseProjectionMatrix","nearFar","join","miterLimit","fullViewport","constants","attributes","POSITION","SUBDIVISIONFACTOR","UV0","AUXPOS1","AUXPOS2","varyings","T","capType","ROUND","W","stippleEnabled","stippleScaleWithLineWidth","O","V","innerColorEnabled","N","I","falloffEnabled","code","pixelRatio","roundJoins","float","_","BUTT","screenToPCSRatio","wireframe","color","innerColor","innerWidth","falloff","transparencyPassType","Highlight","Object","freeze","defineProperty","__proto__","RIBBONLINE_NUM_ROUND_JOIN_SUBDIVISIONS","build","Symbol","toStringTag","value"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/RibbonLine.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{unwrapOr as e}from\"../core/maybe.js\";import{addLinearDepth as i,addCalculateLinearDepth as t}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as o}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as r}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{ObjectAndLayerIdColor as n}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";import{RibbonVertexPosition as a}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{LineStipple as l,computePixelSize as d}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";import{MarkerSizing as p}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";import{multipassTerrainTest as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{PiUtils as g}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";import{symbolAlphaCutoff as m}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as v}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as f}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as D}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as b}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as S}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as x}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{TransparencyPassType as L}from\"../views/3d/webgl-engine/lib/TransparencyPassType.js\";import{VertexAttribute as w}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{LineMarkerSpace as y}from\"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";import{CapType as C}from\"../views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js\";const j=1;function R(R){const A=new x,{vertex:P,fragment:F}=A,z=R.hasMultipassTerrain&&(R.output===o.Color||R.output===o.Alpha);A.include(g),A.include(a,R),A.include(l,R);const E=R.applyMarkerOffset&&!R.draped;E&&(P.uniforms.add(new D(\"markerScale\",(e=>e.markerScale))),A.include(p,{space:y.World})),R.output===o.Depth&&A.include(s,R),A.include(n,R),f(P,R),P.uniforms.add([new S(\"inverseProjectionMatrix\",((e,i)=>i.camera.inverseProjectionMatrix)),new h(\"nearFar\",((e,i)=>i.camera.nearFar)),new D(\"miterLimit\",(e=>\"miter\"!==e.join?0:e.miterLimit)),new u(\"viewport\",((e,i)=>i.camera.fullViewport))]),P.constants.add(\"LARGE_HALF_FLOAT\",\"float\",65500),A.attributes.add(w.POSITION,\"vec3\"),A.attributes.add(w.SUBDIVISIONFACTOR,\"float\"),A.attributes.add(w.UV0,\"vec2\"),A.attributes.add(w.AUXPOS1,\"vec3\"),A.attributes.add(w.AUXPOS2,\"vec3\"),A.varyings.add(\"vColor\",\"vec4\"),A.varyings.add(\"vpos\",\"vec3\"),i(A),z&&A.varyings.add(\"depth\",\"float\");const T=R.capType===C.ROUND,W=R.stippleEnabled&&R.stippleScaleWithLineWidth||T;W&&A.varyings.add(\"vLineWidth\",\"float\");const O=R.stippleEnabled&&R.stippleScaleWithLineWidth;O&&A.varyings.add(\"vLineSizeInv\",\"float\");const V=R.innerColorEnabled||T;V&&A.varyings.add(\"vLineDistance\",\"float\");const N=R.stippleEnabled&&T,I=R.falloffEnabled||N;I&&A.varyings.add(\"vLineDistanceNorm\",\"float\"),T&&(A.varyings.add(\"vSegmentSDF\",\"float\"),A.varyings.add(\"vReverseSegmentSDF\",\"float\")),P.code.add(b`#define PERPENDICULAR(v) vec2(v.y, -v.x);\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`),P.code.add(b`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),t(A),P.code.add(b`\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearFar[0] * 0.99;\n\n      if(pos.z > -nearFar[0]) {\n        //current pos behind ncp --> we need to clip\n        if (!isStartVertex) {\n          if(prev.z < -nearFar[0]) {\n            //previous in front of ncp\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        } else {\n          if(next.z < -nearFar[0]) {\n            //next in front of ncp\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        if (prev.z > -nearFar[0]) {\n          //previous behind ncp\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        if (next.z > -nearFar[0]) {\n          //next behind ncp\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      ${z?\"depth = pos.z;\":\"\"}\n      linearDepth = calculateLinearDepth(nearFar,pos.z);\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n  `),P.uniforms.add(new D(\"pixelRatio\",((e,i)=>i.camera.pixelRatio))),P.code.add(b`\n  void main(void) {\n    // unpack values from uv0.y\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n\n    float coverage = 1.0;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isJoin = abs(uv0.y) < 3.0;\n\n      float lineSize = getSize();\n      float lineWidth = lineSize * pixelRatio;\n\n      ${W?b`vLineWidth = lineWidth;`:\"\"}\n      ${O?b`vLineSizeInv = 1.0 / lineSize;`:\"\"}\n\n      // convert sub-pixel coverage to alpha\n      if (lineWidth < 1.0) {\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }else{\n        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if\n        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly\n        // so we only really care to round anything larger than 1.\n        lineWidth = floor(lineWidth + 0.5);\n      }\n\n      vec4 pos  = view * vec4(position.xyz, 1.0);\n      vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n      vec4 next = view * vec4(auxpos2.xyz, 1.0);\n  `),E&&P.code.add(b`vec4 other = isStartVertex ? next : prev;\nbool markersHidden = areWorldMarkersHidden(pos, other);\nif(!isJoin && !markersHidden) {\npos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;\n}`),P.code.add(b`clipAndTransform(pos, prev, next, isStartVertex);\nvec2 left = (pos.xy - prev.xy);\nvec2 right = (next.xy - pos.xy);\nfloat leftLen = length(left);\nfloat rightLen = length(right);`);(R.stippleEnabled||T)&&P.code.add(b`\n      float isEndVertex = float(!isStartVertex);\n      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);\n      vec2 segment = mix(right, left, isEndVertex);\n      ${T?b`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:\"\"}\n    `),P.code.add(b`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`),R.roundJoins?P.code.add(b`\n        vec2 startDir = leftLen < 0.001 ? right : left;\n        startDir = PERPENDICULAR(startDir);\n\n        vec2 endDir = rightLen < 0.001 ? left : right;\n        endDir = PERPENDICULAR(endDir);\n\n        float factor = ${R.stippleEnabled?b`min(1.0, subdivisionFactor * ${b.float((j+2)/(j+1))})`:b`subdivisionFactor`};\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);\n      `):P.code.add(b`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;\n}\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const _=R.capType!==C.BUTT;return P.code.add(b`\n        displacementLen = lineWidth;\n      }\n    } else {\n      // CAP handling ---------------------------------------------------\n      joinDisplacementDir = isStartVertex ? right : left;\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      ${_?b`capDisplacementDir = isStartVertex ? -right : left;`:\"\"}\n    }\n  `),P.code.add(b`\n    // Displacement (in pixels) caused by join/or cap\n    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n\n    ${I||V?b`float lineDistNorm = sign(uv0.y) * pos.w;`:\"\"}\n\n    ${V?b`vLineDistance = lineWidth * lineDistNorm;`:\"\"}\n    ${I?b`vLineDistanceNorm = lineDistNorm;`:\"\"}\n\n    pos.xy += dpos;\n  `),T&&P.code.add(b`vec2 segmentDir = normalize(segment);\nvSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;\nvReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),R.stippleEnabled&&(R.draped?P.uniforms.add(new D(\"worldToScreenRatio\",((e,i)=>1/i.screenToPCSRatio))):P.code.add(b`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);\nfloat worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),P.code.add(b`float segmentLengthScreenDouble = length(segment);\nfloat segmentLengthScreen = segmentLengthScreenDouble * 0.5;\nfloat discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);\nfloat segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));\nvStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),R.draped?P.code.add(b`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;\nfloat startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):P.code.add(b`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;\nfloat segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),P.uniforms.add(new D(\"stipplePatternPixelSize\",(e=>d(e)))),P.code.add(b`\n      float patternLength = ${R.stippleScaleWithLineWidth?\"lineSize * \":\"\"} stipplePatternPixelSize;\n\n      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader\n      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);\n\n      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);\n\n      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)\n      if (segmentLengthScreenDouble >= 0.001) {\n        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the\n        // original vertex positions, and slightly outside of that range at the displaced positions\n        vec2 stippleDisplacement = pos.xy - segmentOrigin;\n        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);\n\n        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)\n        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);\n      }\n\n      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance\n      vStippleDistanceLimits *= pos.w;\n      vStippleDistance *= pos.w;\n\n      // Disable stipple distance limits on caps\n      vStippleDistanceLimits = isJoin ?\n                                 vStippleDistanceLimits :\n                                 isStartVertex ?\n                                  vec2(-1e038, vStippleDistanceLimits.y) :\n                                  vec2(vStippleDistanceLimits.x, 1e038);\n    `)),P.code.add(b`\n      // Convert back into NDC\n      pos.xy = (pos.xy / viewport.zw) * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      ${R.wireframe&&!R.draped?\"pos.z -= 0.001 * pos.w;\":\"\"}\n\n      // transform final position to camera space for slicing\n      vpos = (inverseProjectionMatrix * pos).xyz;\n      gl_Position = pos;\n      forwardObjectAndLayerIdColor();\n    }\n  }\n  `),z&&A.include(c,R),A.include(r,R),F.include(v),F.code.add(b`\n  void main() {\n    discardBySlice(vpos);\n    ${z?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n  `),R.wireframe?F.code.add(b`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(T&&F.code.add(b`\n      float sdf = min(vSegmentSDF, vReverseSegmentSDF);\n      vec2 fragmentPosition = vec2(\n        min(sdf, 0.0),\n        vLineDistance\n      ) * gl_FragCoord.w;\n\n      float fragmentRadius = length(fragmentPosition);\n      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);\n\n      if (capCoverage < ${b.float(m)}) {\n        discard;\n      }\n    `),N?F.code.add(b`\n      vec2 stipplePosition = vec2(\n        min(getStippleSDF() * 2.0 - 1.0, 0.0),\n        vLineDistanceNorm * gl_FragCoord.w\n      );\n      float stippleRadius = length(stipplePosition * vLineWidth);\n      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);\n      float stippleAlpha = step(${b.float(m)}, stippleCoverage);\n      `):F.code.add(b`float stippleAlpha = getStippleAlpha();`),F.uniforms.add(new u(\"intrinsicColor\",(e=>e.color))),R.output!==o.ObjectAndLayerIdColor&&F.code.add(b`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),F.code.add(b`vec4 color = intrinsicColor * vColor;`),R.innerColorEnabled&&(F.uniforms.add(new u(\"innerColor\",(i=>e(i.innerColor,i.color)))),F.uniforms.add(new D(\"innerWidth\",((e,i)=>e.innerWidth*i.camera.pixelRatio))),F.code.add(b`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),F.code.add(b`vec4 finalColor = blendStipple(color, stippleAlpha);`),R.falloffEnabled&&(F.uniforms.add(new D(\"falloff\",(e=>e.falloff))),F.code.add(b`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),F.code.add(b`\n    ${R.output===o.ObjectAndLayerIdColor?b`finalColor.a = 1.0;`:\"\"}\n\n    if (finalColor.a < ${b.float(m)}) {\n      discard;\n    }\n\n    ${R.output===o.Alpha?b`gl_FragColor = vec4(finalColor.a);`:\"\"}\n    ${R.output===o.Color?b`gl_FragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${R.output===o.Color&&R.transparencyPassType===L.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n    ${R.output===o.Highlight?b`gl_FragColor = vec4(1.0);`:\"\"}\n    ${R.output===o.Depth?b`outputDepth(linearDepth);`:\"\"}\n    ${R.output===o.ObjectAndLayerIdColor?b`outputObjectAndLayerIdColor();`:\"\"}\n  }\n  `),A}const A=Object.freeze(Object.defineProperty({__proto__:null,RIBBONLINE_NUM_ROUND_JOIN_SUBDIVISIONS:j,build:R},Symbol.toStringTag,{value:\"Module\"}));export{j as R,A as a,R as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}