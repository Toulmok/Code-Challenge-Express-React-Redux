{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { w as e } from \"./mat4.js\";\nimport { c as r } from \"./mat4f64.js\";\nimport { n as o, s as a } from \"./vec3.js\";\nimport { c as i } from \"./vec3f64.js\";\nimport { OverlayIndex as l } from \"../views/3d/terrain/interfaces.js\";\nimport { addLinearDepth as t, addNearFar as n, ForwardLinearDepth as s } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { ShaderOutput as d } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as c } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as v } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { NormalAttribute as m } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";\nimport { PositionAttribute as g } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js\";\nimport { TextureCoordinateAttribute as p } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { VertexTangent as h } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js\";\nimport { OutputDepth as w } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as u } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { EvaluateAmbientOcclusion as b } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js\";\nimport { EvaluateSceneLighting as f, addAmbientBoostFactor as y, addLightingGlobalFactor as C } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";\nimport { addMainLightDirection as x, addMainLightIntensity as L } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";\nimport { NormalUtils as O } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";\nimport { PBRMode as S } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";\nimport { ReadShadowMapDraw as j } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";\nimport { OverlayMode as z } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";\nimport { OverlayTerrainPassParameters as T, OverlayTerrain as _, TerrainTexture as F } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js\";\nimport { addProjViewLocalOrigin as P, addViewNormal as M, addCameraPosition as N } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float3PassUniform as D } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { glsl as $ } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4DrawUniform as W } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js\";\nimport { ShaderBuilder as U } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as V } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass A extends T {}\nfunction k(r) {\n  const i = new U(),\n    {\n      vertex: T,\n      fragment: A,\n      varyings: k\n    } = i;\n  i.include(g), i.include(m, r), i.include(p, r);\n  const G = () => {\n    i.include(O, r), T.code.add($`\n      vec3 decodeNormalTerrain(vec2 e) {\n        float z = 1.0 - abs(e.x) - abs(e.y);\n        vec3 n = vec3(e + vec2(e.x >= 0.0 ? 1.0 : -1.0, e.y >= 0.0 ? 1.0 : -1.0) * min(z,0.0),z);\n        return normalize(n);\n      }\n\n      vec3 getNormal() {\n        return  ${r.shading ? $`decodeNormalTerrain(normalCompressed)` : $`getLocalUp(position, localOrigin)`};\n      }\n  `);\n  };\n  P(T, r), i.include(v, r);\n  const H = r.overlayMode !== z.Disabled;\n  switch (r.output) {\n    case d.Color:\n      {\n        i.include(F, r), i.include(f, r), H && i.include(_, {\n          ...r,\n          pbrMode: r.pbrMode === S.Terrain ? S.TerrainWithWater : S.Water\n        });\n        const t = r.overlayMode === z.EnabledWithWater;\n        t && i.include(h, r), k.add(\"vnormal\", \"vec3\"), k.add(\"vpos\", \"vec3\"), k.add(\"vup\", \"vec3\"), G(), (r.atmosphere || r.screenSizePerspective) && M(T);\n        const n = r.receiveShadows && !r.renderOccluded;\n        n && i.include(s, r), r.atmosphere && k.add(\"wnormal\", \"vec3\"), r.screenSizePerspective && (k.add(\"screenSizeDistanceToCamera\", \"float\"), k.add(\"screenSizeCosAngle\", \"float\")), T.code.add($`\n        void main(void) {\n          //Position\n          vpos = position;\n          vec3 positionWorld = position + localOrigin;\n          gl_Position = transformPosition(proj, view, vpos);\n\n          //Normal\n          vnormal = getNormal();\n\n          //Up\n          vup = getLocalUp(position, localOrigin);\n\n          ${t ? $`forwardVertexTangent(vnormal);` : $``}\n\n          ${r.atmosphere ? $`wnormal = normalize((viewNormal * vec4(normalize(positionWorld), 1.0)).xyz);` : \"\"}\n\n          //Texture UV\n          vec2 uv = getUV0();\n          forwardTextureCoordinatesWithTransform(uv);\n          ${H ? $`setOverlayVTC(uv);` : \"\"}\n          ${r.tileBorders ? $`forwardTextureCoordinates();` : \"\"}\n\n          ${r.screenSizePerspective ? $`\n          vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n          screenSizeDistanceToCamera = length(viewPos);\n          vec3 viewSpaceNormal = (viewNormal * vec4(normalize(positionWorld), 1.0)).xyz;\n          screenSizeCosAngle = abs(viewSpaceNormal.z);` : \"\"}\n\n          ${n ? $`forwardLinearDepth();` : \"\"}\n\n        }\n      `), i.extensions.add(\"GL_OES_standard_derivatives\"), i.extensions.add(\"GL_EXT_shader_texture_lod\"), i.include(c, r), i.include(f, r), i.include(b, r), i.include(j, r), N(A, r), y(A), C(A), A.uniforms.add([T.uniforms.get(\"localOrigin\"), new D(\"viewDirection\", (e, r) => o(E, a(E, r.camera.viewMatrix[12], r.camera.viewMatrix[13], r.camera.viewMatrix[14])))]), t && A.uniforms.add([new V(\"ovWaterTex\", (e, r) => 0 === r.overlays.length ? null : r.overlays[l.INNER].getNormalTexture(e.overlaySource)), new W(\"view\", (r, o) => e(B, o.camera.viewMatrix, r.origin))]), A.code.add($`const float sliceOpacity = 0.2;\nfloat lum(vec3 c) {\nreturn (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;\n}`), x(A), L(A), A.code.add($`\n        void main() {\n          vec3 normal = normalize(vnormal);\n          float vndl = dot(normal, mainLightDirection);\n\n          float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n          float shadow = ${r.receiveShadows && !r.renderOccluded ? \"readShadowMap(vpos, linearDepth)\" : r.spherical && r.shading ? \"lightingGlobalFactor * (1.0 - additionalAmbientScale)\" : \"0.0\"};\n\n          float ssao = evaluateAmbientOcclusionInverse();\n          vec4 tileColor = getTileColor();\n\n          ${H ? $`\n              vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n              vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n              ${r.invisible ? $`if (overlayColor.a == 0.0) { discard; }` : \"\"}\n              vec4 groundColor = tileColor;\n              tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n\n          // If combined alpha is 0 we can discard pixel. The performance impact by having a discard here\n          // is neglectable because terrain typically renders first into the framebuffer.\n          if(tileColor.a <= 0.0) {\n            discard;\n          }\n\n          bool sliced = rejectBySlice(vpos);\n          if (sliced) {\n            tileColor *= sliceOpacity;\n          }\n          ${r.atmosphere ? $`\n              float ndotl = clamp(vndl, 0.0, 1.0);\n              vec3 atm = vec3(clamp(1.0 - dot(-viewDirection, wnormal), 0.0, 1.0));\n              atm *= clamp(1.0 - lum(tileColor.rgb) * 1.5, 0.0, 1.0); // avoid atmosphere on bright base maps\n              atm *= clamp(ndotl * 2.0, 0.0, 1.0); // avoid atmosphere on dark side of the globe\n              atm *= tileColor.a; // premultiply with tile alpha` : \"\"}\n\n          vec3 albedo = ${r.atmosphere ? $`atm + tileColor.rgb;` : $`tileColor.rgb;`}\n\n          // heuristic shading function used in the old terrain, now used to add ambient lighting\n\n          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n          ${r.pbrMode === S.Terrain || r.pbrMode === S.TerrainWithWater ? $`gl_FragColor = vec4(evaluateTerrainLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight, normalize(vpos - cameraPosition), vup), tileColor.a);` : $`gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);`}\n          ${t ? $`\n              vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);\n              float waterNormalLength = length(overlayWaterMask);\n              if (waterNormalLength > 0.95) {\n                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n                vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n                vec4 viewPosition = view*vec4(vpos, 1.0);\n                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + localOrigin);\n                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n                float opacity = sliced ? sliceOpacity : 1.0;\n                // un-gamma the ground color to mix in linear space\n                gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w) * opacity;\n              }` : \"\"}\n          ${r.screenSizePerspective ? $`\n            float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, vec4(0.0, 0.0, 0.0, 0.0));\n            if (perspectiveScale <= 0.25) {\n              gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n            }\n            else if (perspectiveScale <= 0.5) {\n              gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n            }\n            else if (perspectiveScale >= 0.99) {\n              gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n            }\n            else {\n              gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n            }` : \"\"}\n          ${r.visualizeNormals ? r.spherical ? $`\n                  vec3 localUp = normalize(vpos + localOrigin);\n                  vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), localUp));\n                  vec3 forward = normalize(cross(localUp, right));\n                  mat3 tbn = mat3(right, forward, localUp);\n                  vec3 tNormal = normalize(normal * tbn);\n                  gl_FragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              ` : $`\n                  vec3 tNormal = normalize(normal);\n                  gl_FragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              ` : \"\"}\n          ${r.tileBorders ? $`\n              vec2 dVuv = fwidth(vuv0);\n              vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv0, 1.0 - vuv0));\n              float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n              gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);` : \"\"}\n          gl_FragColor = highlightSlice(gl_FragColor, vpos);\n        }\n      `);\n      }\n      break;\n    case d.Depth:\n      H && i.include(_, r), i.include(w, r), t(i), n(i), T.code.add($`\n              void main(void) {\n                ${H ? $`setOverlayVTC(getUV0());` : \"\"}\n                gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n              }\n          `), A.code.add($`\n              void main() {\n                ${H && r.invisible ? $`if (getCombinedOverlayColor().a == 0.0) { discard; }` : \"\"}\n                outputDepth(linearDepth);\n              }\n          `);\n      break;\n    case d.Shadow:\n    case d.ShadowHighlight:\n    case d.ShadowExcludeHighlight:\n      i.include(w, r), t(i), n(i), T.code.add($`void main(void) {\ngl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n}`), A.code.add($`void main() {\noutputDepth(linearDepth);\n}`);\n      break;\n    case d.Normal:\n      H && i.include(_, r), k.add(\"vnormal\", \"vec3\"), M(T), G(), T.code.add($`\n            void main(void) {\n              ${H ? $`setOverlayVTC(getUV0());` : \"\"}\n              gl_Position = transformPosition(proj, view, position);\n              vnormal = normalize((viewNormal * vec4(getNormal(), 1.0)).xyz);\n            }\n        `), A.code.add($`\n            void main() {\n              ${H && r.invisible ? $`if (getCombinedOverlayColor().a == 0.0) { discard; }` : \"\"}\n              vec3 normal = normalize(vnormal);\n              if (gl_FrontFacing == false) {\n                normal = -normal;\n              }\n              gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n            }\n        `);\n      break;\n    case d.Highlight:\n      H && i.include(_, r), T.code.add($`\n          void main() {\n            ${H ? $`setOverlayVTC(getUV0());` : \"\"}\n            gl_Position = transformPosition(proj, view, position);\n          }\n        `), i.include(u, r), A.code.add($`\n          void main() {\n            ${H ? $`if (getCombinedOverlayColor().a == 0.0) { discard; }` : \"\"}\n            outputHighlight();\n          }\n        `);\n  }\n  return r.output === d.ObjectAndLayerIdColor && (i.include(_, {\n    ...r,\n    pbrMode: S.Disabled\n  }), T.code.add($`void main(void) {\ngl_Position = transformPosition(proj, view, position);\nsetOverlayVTC(getUV0());\n}`), A.code.add($`void main() {\ngl_FragColor = getOverlayColorTexel(vtcOverlay);\n}`)), i;\n}\nconst B = r(),\n  E = i(),\n  G = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    TerrainPassParameters: A,\n    build: k\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { A as T, G as a, k as b };","map":{"version":3,"names":["w","e","c","r","n","o","s","a","i","OverlayIndex","l","addLinearDepth","t","addNearFar","ForwardLinearDepth","ShaderOutput","d","SliceDraw","Transform","v","NormalAttribute","m","PositionAttribute","g","TextureCoordinateAttribute","p","VertexTangent","h","OutputDepth","OutputHighlight","u","EvaluateAmbientOcclusion","b","EvaluateSceneLighting","f","addAmbientBoostFactor","y","addLightingGlobalFactor","C","addMainLightDirection","x","addMainLightIntensity","L","NormalUtils","O","PBRMode","S","ReadShadowMapDraw","j","OverlayMode","z","OverlayTerrainPassParameters","T","OverlayTerrain","_","TerrainTexture","F","addProjViewLocalOrigin","P","addViewNormal","M","addCameraPosition","N","Float3PassUniform","D","glsl","$","Matrix4DrawUniform","W","ShaderBuilder","U","Texture2DPassUniform","V","A","k","vertex","fragment","varyings","include","G","code","add","shading","H","overlayMode","Disabled","output","Color","pbrMode","Terrain","TerrainWithWater","Water","EnabledWithWater","atmosphere","screenSizePerspective","receiveShadows","renderOccluded","tileBorders","extensions","uniforms","get","E","camera","viewMatrix","overlays","length","INNER","getNormalTexture","overlaySource","B","origin","spherical","invisible","visualizeNormals","Depth","Shadow","ShadowHighlight","ShadowExcludeHighlight","Normal","Highlight","ObjectAndLayerIdColor","Object","freeze","defineProperty","__proto__","TerrainPassParameters","build","Symbol","toStringTag","value"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/Terrain.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{w as e}from\"./mat4.js\";import{c as r}from\"./mat4f64.js\";import{n as o,s as a}from\"./vec3.js\";import{c as i}from\"./vec3f64.js\";import{OverlayIndex as l}from\"../views/3d/terrain/interfaces.js\";import{addLinearDepth as t,addNearFar as n,ForwardLinearDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as d}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as c}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as v}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{NormalAttribute as m}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";import{PositionAttribute as g}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js\";import{TextureCoordinateAttribute as p}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{VertexTangent as h}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js\";import{OutputDepth as w}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as u}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{EvaluateAmbientOcclusion as b}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js\";import{EvaluateSceneLighting as f,addAmbientBoostFactor as y,addLightingGlobalFactor as C}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";import{addMainLightDirection as x,addMainLightIntensity as L}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{NormalUtils as O}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";import{PBRMode as S}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";import{ReadShadowMapDraw as j}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{OverlayMode as z}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";import{OverlayTerrainPassParameters as T,OverlayTerrain as _,TerrainTexture as F}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js\";import{addProjViewLocalOrigin as P,addViewNormal as M,addCameraPosition as N}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float3PassUniform as D}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{glsl as $}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4DrawUniform as W}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js\";import{ShaderBuilder as U}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as V}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class A extends T{}function k(r){const i=new U,{vertex:T,fragment:A,varyings:k}=i;i.include(g),i.include(m,r),i.include(p,r);const G=()=>{i.include(O,r),T.code.add($`\n      vec3 decodeNormalTerrain(vec2 e) {\n        float z = 1.0 - abs(e.x) - abs(e.y);\n        vec3 n = vec3(e + vec2(e.x >= 0.0 ? 1.0 : -1.0, e.y >= 0.0 ? 1.0 : -1.0) * min(z,0.0),z);\n        return normalize(n);\n      }\n\n      vec3 getNormal() {\n        return  ${r.shading?$`decodeNormalTerrain(normalCompressed)`:$`getLocalUp(position, localOrigin)`};\n      }\n  `)};P(T,r),i.include(v,r);const H=r.overlayMode!==z.Disabled;switch(r.output){case d.Color:{i.include(F,r),i.include(f,r),H&&i.include(_,{...r,pbrMode:r.pbrMode===S.Terrain?S.TerrainWithWater:S.Water});const t=r.overlayMode===z.EnabledWithWater;t&&i.include(h,r),k.add(\"vnormal\",\"vec3\"),k.add(\"vpos\",\"vec3\"),k.add(\"vup\",\"vec3\"),G(),(r.atmosphere||r.screenSizePerspective)&&M(T);const n=r.receiveShadows&&!r.renderOccluded;n&&i.include(s,r),r.atmosphere&&k.add(\"wnormal\",\"vec3\"),r.screenSizePerspective&&(k.add(\"screenSizeDistanceToCamera\",\"float\"),k.add(\"screenSizeCosAngle\",\"float\")),T.code.add($`\n        void main(void) {\n          //Position\n          vpos = position;\n          vec3 positionWorld = position + localOrigin;\n          gl_Position = transformPosition(proj, view, vpos);\n\n          //Normal\n          vnormal = getNormal();\n\n          //Up\n          vup = getLocalUp(position, localOrigin);\n\n          ${t?$`forwardVertexTangent(vnormal);`:$``}\n\n          ${r.atmosphere?$`wnormal = normalize((viewNormal * vec4(normalize(positionWorld), 1.0)).xyz);`:\"\"}\n\n          //Texture UV\n          vec2 uv = getUV0();\n          forwardTextureCoordinatesWithTransform(uv);\n          ${H?$`setOverlayVTC(uv);`:\"\"}\n          ${r.tileBorders?$`forwardTextureCoordinates();`:\"\"}\n\n          ${r.screenSizePerspective?$`\n          vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n          screenSizeDistanceToCamera = length(viewPos);\n          vec3 viewSpaceNormal = (viewNormal * vec4(normalize(positionWorld), 1.0)).xyz;\n          screenSizeCosAngle = abs(viewSpaceNormal.z);`:\"\"}\n\n          ${n?$`forwardLinearDepth();`:\"\"}\n\n        }\n      `),i.extensions.add(\"GL_OES_standard_derivatives\"),i.extensions.add(\"GL_EXT_shader_texture_lod\"),i.include(c,r),i.include(f,r),i.include(b,r),i.include(j,r),N(A,r),y(A),C(A),A.uniforms.add([T.uniforms.get(\"localOrigin\"),new D(\"viewDirection\",((e,r)=>o(E,a(E,r.camera.viewMatrix[12],r.camera.viewMatrix[13],r.camera.viewMatrix[14]))))]),t&&A.uniforms.add([new V(\"ovWaterTex\",((e,r)=>0===r.overlays.length?null:r.overlays[l.INNER].getNormalTexture(e.overlaySource))),new W(\"view\",((r,o)=>e(B,o.camera.viewMatrix,r.origin)))]),A.code.add($`const float sliceOpacity = 0.2;\nfloat lum(vec3 c) {\nreturn (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;\n}`),x(A),L(A),A.code.add($`\n        void main() {\n          vec3 normal = normalize(vnormal);\n          float vndl = dot(normal, mainLightDirection);\n\n          float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n          float shadow = ${r.receiveShadows&&!r.renderOccluded?\"readShadowMap(vpos, linearDepth)\":r.spherical&&r.shading?\"lightingGlobalFactor * (1.0 - additionalAmbientScale)\":\"0.0\"};\n\n          float ssao = evaluateAmbientOcclusionInverse();\n          vec4 tileColor = getTileColor();\n\n          ${H?$`\n              vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n              vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n              ${r.invisible?$`if (overlayColor.a == 0.0) { discard; }`:\"\"}\n              vec4 groundColor = tileColor;\n              tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n\n          // If combined alpha is 0 we can discard pixel. The performance impact by having a discard here\n          // is neglectable because terrain typically renders first into the framebuffer.\n          if(tileColor.a <= 0.0) {\n            discard;\n          }\n\n          bool sliced = rejectBySlice(vpos);\n          if (sliced) {\n            tileColor *= sliceOpacity;\n          }\n          ${r.atmosphere?$`\n              float ndotl = clamp(vndl, 0.0, 1.0);\n              vec3 atm = vec3(clamp(1.0 - dot(-viewDirection, wnormal), 0.0, 1.0));\n              atm *= clamp(1.0 - lum(tileColor.rgb) * 1.5, 0.0, 1.0); // avoid atmosphere on bright base maps\n              atm *= clamp(ndotl * 2.0, 0.0, 1.0); // avoid atmosphere on dark side of the globe\n              atm *= tileColor.a; // premultiply with tile alpha`:\"\"}\n\n          vec3 albedo = ${r.atmosphere?$`atm + tileColor.rgb;`:$`tileColor.rgb;`}\n\n          // heuristic shading function used in the old terrain, now used to add ambient lighting\n\n          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n          ${r.pbrMode===S.Terrain||r.pbrMode===S.TerrainWithWater?$`gl_FragColor = vec4(evaluateTerrainLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight, normalize(vpos - cameraPosition), vup), tileColor.a);`:$`gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);`}\n          ${t?$`\n              vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);\n              float waterNormalLength = length(overlayWaterMask);\n              if (waterNormalLength > 0.95) {\n                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n                vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n                vec4 viewPosition = view*vec4(vpos, 1.0);\n                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + localOrigin);\n                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n                float opacity = sliced ? sliceOpacity : 1.0;\n                // un-gamma the ground color to mix in linear space\n                gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w) * opacity;\n              }`:\"\"}\n          ${r.screenSizePerspective?$`\n            float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, vec4(0.0, 0.0, 0.0, 0.0));\n            if (perspectiveScale <= 0.25) {\n              gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n            }\n            else if (perspectiveScale <= 0.5) {\n              gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n            }\n            else if (perspectiveScale >= 0.99) {\n              gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n            }\n            else {\n              gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n            }`:\"\"}\n          ${r.visualizeNormals?r.spherical?$`\n                  vec3 localUp = normalize(vpos + localOrigin);\n                  vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), localUp));\n                  vec3 forward = normalize(cross(localUp, right));\n                  mat3 tbn = mat3(right, forward, localUp);\n                  vec3 tNormal = normalize(normal * tbn);\n                  gl_FragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              `:$`\n                  vec3 tNormal = normalize(normal);\n                  gl_FragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              `:\"\"}\n          ${r.tileBorders?$`\n              vec2 dVuv = fwidth(vuv0);\n              vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv0, 1.0 - vuv0));\n              float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n              gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);`:\"\"}\n          gl_FragColor = highlightSlice(gl_FragColor, vpos);\n        }\n      `)}break;case d.Depth:H&&i.include(_,r),i.include(w,r),t(i),n(i),T.code.add($`\n              void main(void) {\n                ${H?$`setOverlayVTC(getUV0());`:\"\"}\n                gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n              }\n          `),A.code.add($`\n              void main() {\n                ${H&&r.invisible?$`if (getCombinedOverlayColor().a == 0.0) { discard; }`:\"\"}\n                outputDepth(linearDepth);\n              }\n          `);break;case d.Shadow:case d.ShadowHighlight:case d.ShadowExcludeHighlight:i.include(w,r),t(i),n(i),T.code.add($`void main(void) {\ngl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n}`),A.code.add($`void main() {\noutputDepth(linearDepth);\n}`);break;case d.Normal:H&&i.include(_,r),k.add(\"vnormal\",\"vec3\"),M(T),G(),T.code.add($`\n            void main(void) {\n              ${H?$`setOverlayVTC(getUV0());`:\"\"}\n              gl_Position = transformPosition(proj, view, position);\n              vnormal = normalize((viewNormal * vec4(getNormal(), 1.0)).xyz);\n            }\n        `),A.code.add($`\n            void main() {\n              ${H&&r.invisible?$`if (getCombinedOverlayColor().a == 0.0) { discard; }`:\"\"}\n              vec3 normal = normalize(vnormal);\n              if (gl_FrontFacing == false) {\n                normal = -normal;\n              }\n              gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n            }\n        `);break;case d.Highlight:H&&i.include(_,r),T.code.add($`\n          void main() {\n            ${H?$`setOverlayVTC(getUV0());`:\"\"}\n            gl_Position = transformPosition(proj, view, position);\n          }\n        `),i.include(u,r),A.code.add($`\n          void main() {\n            ${H?$`if (getCombinedOverlayColor().a == 0.0) { discard; }`:\"\"}\n            outputHighlight();\n          }\n        `)}return r.output===d.ObjectAndLayerIdColor&&(i.include(_,{...r,pbrMode:S.Disabled}),T.code.add($`void main(void) {\ngl_Position = transformPosition(proj, view, position);\nsetOverlayVTC(getUV0());\n}`),A.code.add($`void main() {\ngl_FragColor = getOverlayColorTexel(vtcOverlay);\n}`)),i}const B=r(),E=i(),G=Object.freeze(Object.defineProperty({__proto__:null,TerrainPassParameters:A,build:k},Symbol.toStringTag,{value:\"Module\"}));export{A as T,G as a,k as b};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}