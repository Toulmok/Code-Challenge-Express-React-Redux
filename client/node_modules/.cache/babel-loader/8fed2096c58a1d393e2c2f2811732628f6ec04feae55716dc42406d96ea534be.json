{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { Z as e } from \"./vec3f64.js\";\nimport { RasterColorizerType as a, RasterColorizerStretchType as o } from \"../views/2d/engine/imagery/enums.js\";\nimport { Colormap as l } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";\nimport { CommonPassParameters as r, Common as i } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";\nimport { TileBackground as t } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileBackground.glsl.js\";\nimport { TileComposite as u } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js\";\nimport { ColorConversion as n } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { BooleanPassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js\";\nimport { Float2PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { FloatsPassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js\";\nimport { IntegerPassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js\";\nimport { glsl as g } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as p } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as x } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass v extends r {\n  constructor(a, o, l, r, i, t) {\n    super(a, r, i), this.colormap = o, this.symbolizer = l, this.u_colormap = t, this.backgroundColor = e, this.fboTexture = null, this.baseOpacity = 1;\n  }\n}\nclass _ extends v {}\nclass y extends v {}\nfunction h(e) {\n  const o = new p();\n  return o.include(u), o.include(i, e), o.include(l, e), o.include(t, e), o.fragment.code.add(g`vec4 applyBackgroundBlend(vec4 layerColor) {\nvec4 bgColor = getBackground(vuv);\nreturn blendLayers(bgColor, layerColor, u_opacity);\n}`), e.colorizerType === a.Stretch ? C(o, e) : e.colorizerType === a.Lut ? b(o) : e.colorizerType === a.Hillshade && w(o, e), o;\n}\nfunction b(e) {\n  e.fragment.code.add(g`void main() {\nvec2 pixelLocation = getPixelLocation(uv);\nif (isOutside(pixelLocation)) {\ngl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = applyBackgroundBlend(colormap(currentPixel, true));\n}`);\n}\nfunction C(e, a) {\n  e.fragment.uniforms.add([new f(\"u_bandCount\", e => e.symbolizer.u_bandCount), new d(\"u_minCutOff\", e => e.symbolizer.u_minCutOff, 3), new d(\"u_maxCutOff\", e => e.symbolizer.u_maxCutOff, 3), new d(\"u_factor\", e => e.symbolizer.u_factor, 3), new m(\"u_minOutput\", e => e.symbolizer.u_minOutput), new m(\"u_maxOutput\", e => e.symbolizer.u_maxOutput), new s(\"u_useGamma\", e => e.symbolizer.u_useGamma), new d(\"u_gamma\", e => e.symbolizer.u_gamma, 3), new d(\"u_gammaCorrection\", e => e.symbolizer.u_gammaCorrection, 3), new m(\"u_opacity\", e => e.common.u_opacity)]), e.fragment.code.add(g`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);\n  const l = a.applyColormap ? g`gl_FragColor = applyBackgroundBlend(colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma));` : g`gl_FragColor = applyBackgroundBlend(vec4(grayVal, grayVal, grayVal, currentPixel.a));`;\n  e.fragment.code.add(g`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(uv);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        ${a.stretchType === o.Noop ? g`\n        gl_FragColor = applyBackgroundBlend(currentPixel);` : g`\n        if (currentPixel.a == 0.0) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${l}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor = applyBackgroundBlend(vec4(redVal, greenVal, blueVal, currentPixel.a));\n        }`}\n      }`);\n}\nfunction w(e, a) {\n  const o = e.fragment;\n  o.uniforms.add([new x(\"u_image\", e => e.u_image), new f(\"u_hillshadeType\", e => e.symbolizer.u_hillshadeType), new d(\"u_sinZcosAs\", e => e.symbolizer.u_sinZcosAs, 6), new d(\"u_sinZsinAs\", e => e.symbolizer.u_sinZsinAs, 6), new d(\"u_cosZs\", e => e.symbolizer.u_cosZs, 6), new d(\"u_weights\", e => e.symbolizer.u_weights, 6), new c(\"u_factor\", e => e.symbolizer.u_factor), new m(\"u_minValue\", e => e.symbolizer.u_minValue), new m(\"u_maxValue\", e => e.symbolizer.u_maxValue), new c(\"u_srcImageSize\", e => e.common.u_srcImageSize)]), o.include(n), o.code.add(g`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec4 color = colormap(vec4(val, val, val, 1.0), false);\nvec3 hsv = rgb2hsv(color.rgb);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv), 1.0) * alpha * color.a;\n}`), o.code.add(g`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);\n  const l = a.applyColormap ? g`gl_FragColor = applyBackgroundBlend(overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha));` : g`hillshade *= alpha;\ngl_FragColor = applyBackgroundBlend(vec4(hillshade, hillshade, hillshade, alpha));`;\n  o.code.add(g`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(uv);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture2D(u_image, pixelLocation);\n      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${l}\n    }\n  `);\n}\nconst z = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  ColorizerHillshadeUniforms: y,\n  ColorizerStretchUniforms: _,\n  ColorizerUniforms: v,\n  build: h\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { v as C, z as R, _ as a, y as b, h as c };","map":{"version":3,"names":["Z","e","RasterColorizerType","a","RasterColorizerStretchType","o","Colormap","l","CommonPassParameters","r","Common","i","TileBackground","t","TileComposite","u","ColorConversion","n","BooleanPassUniform","s","Float2PassUniform","c","FloatPassUniform","m","FloatsPassUniform","d","IntegerPassUniform","f","glsl","g","ShaderBuilder","p","Texture2DPassUniform","x","v","constructor","colormap","symbolizer","u_colormap","backgroundColor","fboTexture","baseOpacity","_","y","h","include","fragment","code","add","colorizerType","Stretch","C","Lut","b","Hillshade","w","uniforms","u_bandCount","u_minCutOff","u_maxCutOff","u_factor","u_minOutput","u_maxOutput","u_useGamma","u_gamma","u_gammaCorrection","common","u_opacity","applyColormap","stretchType","Noop","u_image","u_hillshadeType","u_sinZcosAs","u_sinZsinAs","u_cosZs","u_weights","u_minValue","u_maxValue","u_srcImageSize","z","Object","freeze","defineProperty","__proto__","ColorizerHillshadeUniforms","ColorizerStretchUniforms","ColorizerUniforms","build","Symbol","toStringTag","value","R"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/RasterColorizer.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{Z as e}from\"./vec3f64.js\";import{RasterColorizerType as a,RasterColorizerStretchType as o}from\"../views/2d/engine/imagery/enums.js\";import{Colormap as l}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";import{CommonPassParameters as r,Common as i}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";import{TileBackground as t}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileBackground.glsl.js\";import{TileComposite as u}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js\";import{ColorConversion as n}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{BooleanPassUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js\";import{Float2PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{FloatPassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{FloatsPassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js\";import{IntegerPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js\";import{glsl as g}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as p}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as x}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class v extends r{constructor(a,o,l,r,i,t){super(a,r,i),this.colormap=o,this.symbolizer=l,this.u_colormap=t,this.backgroundColor=e,this.fboTexture=null,this.baseOpacity=1}}class _ extends v{}class y extends v{}function h(e){const o=new p;return o.include(u),o.include(i,e),o.include(l,e),o.include(t,e),o.fragment.code.add(g`vec4 applyBackgroundBlend(vec4 layerColor) {\nvec4 bgColor = getBackground(vuv);\nreturn blendLayers(bgColor, layerColor, u_opacity);\n}`),e.colorizerType===a.Stretch?C(o,e):e.colorizerType===a.Lut?b(o):e.colorizerType===a.Hillshade&&w(o,e),o}function b(e){e.fragment.code.add(g`void main() {\nvec2 pixelLocation = getPixelLocation(uv);\nif (isOutside(pixelLocation)) {\ngl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = applyBackgroundBlend(colormap(currentPixel, true));\n}`)}function C(e,a){e.fragment.uniforms.add([new f(\"u_bandCount\",(e=>e.symbolizer.u_bandCount)),new d(\"u_minCutOff\",(e=>e.symbolizer.u_minCutOff),3),new d(\"u_maxCutOff\",(e=>e.symbolizer.u_maxCutOff),3),new d(\"u_factor\",(e=>e.symbolizer.u_factor),3),new m(\"u_minOutput\",(e=>e.symbolizer.u_minOutput)),new m(\"u_maxOutput\",(e=>e.symbolizer.u_maxOutput)),new s(\"u_useGamma\",(e=>e.symbolizer.u_useGamma)),new d(\"u_gamma\",(e=>e.symbolizer.u_gamma),3),new d(\"u_gammaCorrection\",(e=>e.symbolizer.u_gammaCorrection),3),new m(\"u_opacity\",(e=>e.common.u_opacity))]),e.fragment.code.add(g`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);const l=a.applyColormap?g`gl_FragColor = applyBackgroundBlend(colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma));`:g`gl_FragColor = applyBackgroundBlend(vec4(grayVal, grayVal, grayVal, currentPixel.a));`;e.fragment.code.add(g`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(uv);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        ${a.stretchType===o.Noop?g`\n        gl_FragColor = applyBackgroundBlend(currentPixel);`:g`\n        if (currentPixel.a == 0.0) {\n          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${l}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor = applyBackgroundBlend(vec4(redVal, greenVal, blueVal, currentPixel.a));\n        }`}\n      }`)}function w(e,a){const o=e.fragment;o.uniforms.add([new x(\"u_image\",(e=>e.u_image)),new f(\"u_hillshadeType\",(e=>e.symbolizer.u_hillshadeType)),new d(\"u_sinZcosAs\",(e=>e.symbolizer.u_sinZcosAs),6),new d(\"u_sinZsinAs\",(e=>e.symbolizer.u_sinZsinAs),6),new d(\"u_cosZs\",(e=>e.symbolizer.u_cosZs),6),new d(\"u_weights\",(e=>e.symbolizer.u_weights),6),new c(\"u_factor\",(e=>e.symbolizer.u_factor)),new m(\"u_minValue\",(e=>e.symbolizer.u_minValue)),new m(\"u_maxValue\",(e=>e.symbolizer.u_maxValue)),new c(\"u_srcImageSize\",(e=>e.common.u_srcImageSize))]),o.include(n),o.code.add(g`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec4 color = colormap(vec4(val, val, val, 1.0), false);\nvec3 hsv = rgb2hsv(color.rgb);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv), 1.0) * alpha * color.a;\n}`),o.code.add(g`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);const l=a.applyColormap?g`gl_FragColor = applyBackgroundBlend(overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha));`:g`hillshade *= alpha;\ngl_FragColor = applyBackgroundBlend(vec4(hillshade, hillshade, hillshade, alpha));`;o.code.add(g`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(uv);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture2D(u_image, pixelLocation);\n      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${l}\n    }\n  `)}const z=Object.freeze(Object.defineProperty({__proto__:null,ColorizerHillshadeUniforms:y,ColorizerStretchUniforms:_,ColorizerUniforms:v,build:h},Symbol.toStringTag,{value:\"Module\"}));export{v as C,z as R,_ as a,y as b,h as c};\n"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQtB,CAAE;AACV;AACA,GAAG,CAAC;AAAA;AAAC,MAAMyE,CAAC,GAACC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;EAACC,SAAS,EAAC,IAAI;EAACC,0BAA0B,EAAC1C,CAAC;EAAC2C,wBAAwB,EAAC5C,CAAC;EAAC6C,iBAAiB,EAACrD,CAAC;EAACsD,KAAK,EAAC5C;AAAC,CAAC,EAAC6C,MAAM,CAACC,WAAW,EAAC;EAACC,KAAK,EAAC;AAAQ,CAAC,CAAC,CAAC;AAAC,SAAOzD,CAAC,IAAIiB,CAAC,EAAC6B,CAAC,IAAIY,CAAC,EAAClD,CAAC,IAAIvC,CAAC,EAACwC,CAAC,IAAIU,CAAC,EAACT,CAAC,IAAIvB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}