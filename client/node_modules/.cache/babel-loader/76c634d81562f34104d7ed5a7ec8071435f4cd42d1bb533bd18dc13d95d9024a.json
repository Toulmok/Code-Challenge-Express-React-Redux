{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { earth as e, mars as o, moon as r } from \"../geometry/support/Ellipsoid.js\";\nimport { OverlayIndex as a, RenderTargetType as i } from \"../views/3d/terrain/interfaces.js\";\nimport { IntegratedMeshMode as l } from \"../views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js\";\nimport { ComponentData as t, ComponentDataType as d } from \"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js\";\nimport { VertexDiscardByOpacity as n } from \"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js\";\nimport { ForwardLinearDepth as s } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { ShaderOutput as c } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SlicePass as m } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { NormalAttributeType as g } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";\nimport { TextureCoordinateAttribute as v } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { VertexColor as u } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { VertexNormal as h } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js\";\nimport { VertexPosition as p } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js\";\nimport { OutputDepth as C } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as w } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { ReadLinearDepth as b } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { ComputeMaterialColor as y } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js\";\nimport { ComputeNormalTexture as x } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js\";\nimport { ComputeShadingNormal as f } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js\";\nimport { EvaluateSceneLighting as L, addLightingGlobalFactor as M } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";\nimport { addMainLightIntensity as j } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";\nimport { multipassTerrainTest as T } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { PBRMode as O, PhysicallyBasedRenderingParameters as S } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";\nimport { ReadBaseColorTexture as N } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js\";\nimport { ReadShadowMapPass as W } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";\nimport { OverlayIM as A, getColorTexture as P } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";\nimport { symbolAlphaCutoff as B } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { DiscardOrAdjustAlphaDraw as R } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";\nimport { EllipsoidMode as _ } from \"../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode.js\";\nimport { glsl as D } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as $ } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as z } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { TransparencyPassType as F } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nfunction E(a) {\n  const i = new $();\n  i.include(p, a), i.include(h, a), i.include(u, a), i.include(v, a), i.include(s, a), i.include(t, a), i.include(R, a), i.include(m, a), i.include(N, a), i.include(n, a);\n  const {\n    vertex: E,\n    fragment: I\n  } = i;\n  a.pbrMode !== O.Normal && a.pbrMode !== O.Schematic || (i.include(S, a), a.hasNormalTexture && i.include(x, a));\n  const G = a.output === c.Shadow || a.output === c.ShadowHighlight || a.output === c.ShadowExcludeHighlight;\n  G && a.componentData === d.Varying ? E.code.add(D`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`) : E.code.add(D`#define discardShadows(castShadows) {}`);\n  const H = a.integratedMeshMode === l.ColorOverlay || a.integratedMeshMode === l.ColorOverlayWithWater,\n    k = H && a.output === c.Color && a.pbrMode === O.WaterOnIntegratedMesh;\n  return H && (i.include(L, a), i.include(A, a), a.spherical ? E.code.add(D`\n      const float invEllipsoidRadius = ${D.float(1 / (a.ellipsoidMode === _.Earth ? e.radius : a.ellipsoidMode === _.Mars ? o.radius : r.radius))};\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);\n      }\n      `) : E.code.add(D`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)), k && (i.varyings.add(\"tbnTangent\", \"vec3\"), i.varyings.add(\"tbnBiTangent\", \"vec3\"), i.varyings.add(\"groundNormal\", \"vec3\")), E.code.add(D`\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      ${a.output === c.ObjectAndLayerIdColor ? D`externalColor.a = 1.0;` : \"\"}\n\n      if (externalColor.a < ${D.float(B)}) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      forwardPosition(readElevationOffset());\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth();\n      ${a.output === c.ObjectAndLayerIdColor ? D`forwardObjectAndLayerIdColor();` : \"\"}\n      ${k ? a.spherical ? D`\n                groundNormal = normalize(positionWorld());\n                tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n                tbnBiTangent = normalize(cross(groundNormal, tbnTangent));` : D`\n                groundNormal = vec3(0.0, 0.0, 1.0);\n                tbnTangent = vec3(1.0, 0.0, 0.0);\n                tbnBiTangent = vec3(0.0, 1.0, 0.0);` : \"\"}\n      ${H ? D`setOverlayVTC(projectOverlay(position));` : \"\"}\n    }\n  `), a.output === c.Alpha && (I.include(b), i.include(T, a), i.include(y, a), H && I.uniforms.add(new z(\"ovColorTex\", (e, o) => P(e, o))), I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${a.hasMultipassTerrain ? D`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : \"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${H ? D`\n                vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);\n                materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n\n        gl_FragColor = vec4(materialColor.a);\n      }\n    `)), a.output === c.Color && (I.include(b), i.include(T, a), i.include(y, a), i.include(f, a), i.include(L, a), a.receiveShadows ? (i.include(W, a), I.code.add(D`float evaluateShadow() {\nreturn readShadowMap(vPositionWorldCameraRelative, linearDepth);\n}`)) : I.code.add(D`float evaluateShadow() { return 0.0; }`), H && I.uniforms.add(new z(\"ovColorTex\", (e, o) => P(e, o))), I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${a.hasMultipassTerrain ? D`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : \"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${H ? D`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);` : \"\"}\n    `), a.pbrMode === O.Normal || a.pbrMode === O.Schematic ? (j(I), I.code.add(D`\n        ${a.pbrMode === O.Normal ? D`\n                applyPBRFactors();\n                if (int(externalColorMixMode) == 3) {\n                  mrr = vec3(0.0, 0.6, 0.2);\n                }` : \"\"}\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * mainLightIntensity[2];\n      `), a.hasNormalTexture ? I.code.add(D`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\nvec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`) : I.code.add(D`vec3 shadingNormal = normalVertex;`), I.code.add(D`${a.spherical ? D`vec3 normalGround = normalize(positionWorld());` : D`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}\n      `), I.code.add(D`\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n\n        ${a.snowCover ? D`\n                vec3 surfaceNormal = normalize(shadingNormalWorld());\n                float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));\n                materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);\n\n                shadingNormal = mix(shadingNormal, surfaceNormal, snow);\n                ssao = mix(ssao, 0.0, snow);\n                mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);\n                emission = mix(emission, vec3(0.0), snow);` : \"\"}\n\n        ${H ? D` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        `)) : (a.receiveShadows ? I.code.add(D`float shadow = evaluateShadow();`) : a.spherical ? (M(I), I.code.add(D`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());\nfloat shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`)) : I.code.add(D`float shadow = 0.0;`), k && I.uniforms.add(new z(\"ovNormalTex\", (e, o) => V(o))), a.snowCover && (i.extensions.add(\"GL_OES_standard_derivatives\"), I.code.add(D`vec3 surfaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));\nfloat snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));\nmaterialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)), I.code.add(D`\n        float ambientOcclusion = evaluateAmbientOcclusion();\n        vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n\n        ${H ? D` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n\n        vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ${k ? D`\n              vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);\n              float waterNormalLength = length(overlayWaterMask);\n              if (waterNormalLength > 0.95) {\n                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());\n                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n                // un-gamma the ground color to mix in linear space\n                shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);\n              }` : \"\"}\n      `)), I.code.add(D`\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n        ${a.transparencyPassType === F.Color ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n      }\n    `)), (a.output === c.Depth || G) && (i.include(C, a), I.code.add(D`void main() {\ndiscardBySlice(vPositionWorldCameraRelative);\nvec4 textureColor = readBaseColorTexture();\ndiscardOrAdjustAlpha(textureColor);\noutputDepth(linearDepth);\n}`)), a.output === c.Normal && (i.include(f, a), I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ${a.normalType === g.Ground ? \"0.0\" : \"1.0\"};\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    `)), a.output === c.ObjectAndLayerIdColor && i.fragment.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ${H ? D`gl_FragColor = getOverlayColorTexel(vtcOverlay);` : \"outputObjectAndLayerIdColor();\"}\n      }\n    `), a.output === c.Highlight && (i.include(w, a), I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ${H ? D`\n                vec4 overlayColor = getCombinedOverlayColor();\n                if (overlayColor.a == 0.0) {\n                  gl_FragColor = vec4(0.0);\n                  return;\n                }` : \"\"}\n\n        outputHighlight();\n      }\n    `)), i;\n}\nfunction V(e) {\n  return 0 === e.overlays.length ? null : e.overlays[a.INNER].getValidTexture(i.Water);\n}\nconst I = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: E,\n  getOverlayNormalTexture: V\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { I as C, E as b, V as g };","map":{"version":3,"names":["earth","e","mars","o","moon","r","OverlayIndex","a","RenderTargetType","i","IntegratedMeshMode","l","ComponentData","t","ComponentDataType","d","VertexDiscardByOpacity","n","ForwardLinearDepth","s","ShaderOutput","c","SlicePass","m","NormalAttributeType","g","TextureCoordinateAttribute","v","VertexColor","u","VertexNormal","h","VertexPosition","p","OutputDepth","C","OutputHighlight","w","ReadLinearDepth","b","ComputeMaterialColor","y","ComputeNormalTexture","x","ComputeShadingNormal","f","EvaluateSceneLighting","L","addLightingGlobalFactor","M","addMainLightIntensity","j","multipassTerrainTest","T","PBRMode","O","PhysicallyBasedRenderingParameters","S","ReadBaseColorTexture","N","ReadShadowMapPass","W","OverlayIM","A","getColorTexture","P","symbolAlphaCutoff","B","DiscardOrAdjustAlphaDraw","R","EllipsoidMode","_","glsl","D","ShaderBuilder","$","Texture2DPassUniform","z","TransparencyPassType","F","E","include","vertex","fragment","I","pbrMode","Normal","Schematic","hasNormalTexture","G","output","Shadow","ShadowHighlight","ShadowExcludeHighlight","componentData","Varying","code","add","H","integratedMeshMode","ColorOverlay","ColorOverlayWithWater","k","Color","WaterOnIntegratedMesh","spherical","float","ellipsoidMode","Earth","radius","Mars","varyings","ObjectAndLayerIdColor","Alpha","uniforms","hasMultipassTerrain","receiveShadows","snowCover","V","extensions","transparencyPassType","Depth","normalType","Ground","Highlight","overlays","length","INNER","getValidTexture","Water","Object","freeze","defineProperty","__proto__","build","getOverlayNormalTexture","Symbol","toStringTag","value"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/chunks/ComponentShader.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{earth as e,mars as o,moon as r}from\"../geometry/support/Ellipsoid.js\";import{OverlayIndex as a,RenderTargetType as i}from\"../views/3d/terrain/interfaces.js\";import{IntegratedMeshMode as l}from\"../views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js\";import{ComponentData as t,ComponentDataType as d}from\"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js\";import{VertexDiscardByOpacity as n}from\"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js\";import{ForwardLinearDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as c}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SlicePass as m}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{NormalAttributeType as g}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";import{TextureCoordinateAttribute as v}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{VertexColor as u}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{VertexNormal as h}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js\";import{VertexPosition as p}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js\";import{OutputDepth as C}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as w}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{ReadLinearDepth as b}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{ComputeMaterialColor as y}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js\";import{ComputeNormalTexture as x}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js\";import{ComputeShadingNormal as f}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js\";import{EvaluateSceneLighting as L,addLightingGlobalFactor as M}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";import{addMainLightIntensity as j}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{multipassTerrainTest as T}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{PBRMode as O,PhysicallyBasedRenderingParameters as S}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";import{ReadBaseColorTexture as N}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js\";import{ReadShadowMapPass as W}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{OverlayIM as A,getColorTexture as P}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";import{symbolAlphaCutoff as B}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{DiscardOrAdjustAlphaDraw as R}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";import{EllipsoidMode as _}from\"../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode.js\";import{glsl as D}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as $}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as z}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{TransparencyPassType as F}from\"../views/3d/webgl-engine/lib/TransparencyPassType.js\";function E(a){const i=new $;i.include(p,a),i.include(h,a),i.include(u,a),i.include(v,a),i.include(s,a),i.include(t,a),i.include(R,a),i.include(m,a),i.include(N,a),i.include(n,a);const{vertex:E,fragment:I}=i;a.pbrMode!==O.Normal&&a.pbrMode!==O.Schematic||(i.include(S,a),a.hasNormalTexture&&i.include(x,a));const G=a.output===c.Shadow||a.output===c.ShadowHighlight||a.output===c.ShadowExcludeHighlight;G&&a.componentData===d.Varying?E.code.add(D`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`):E.code.add(D`#define discardShadows(castShadows) {}`);const H=a.integratedMeshMode===l.ColorOverlay||a.integratedMeshMode===l.ColorOverlayWithWater,k=H&&a.output===c.Color&&a.pbrMode===O.WaterOnIntegratedMesh;return H&&(i.include(L,a),i.include(A,a),a.spherical?E.code.add(D`\n      const float invEllipsoidRadius = ${D.float(1/(a.ellipsoidMode===_.Earth?e.radius:a.ellipsoidMode===_.Mars?o.radius:r.radius))};\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);\n      }\n      `):E.code.add(D`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)),k&&(i.varyings.add(\"tbnTangent\",\"vec3\"),i.varyings.add(\"tbnBiTangent\",\"vec3\"),i.varyings.add(\"groundNormal\",\"vec3\")),E.code.add(D`\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      ${a.output===c.ObjectAndLayerIdColor?D`externalColor.a = 1.0;`:\"\"}\n\n      if (externalColor.a < ${D.float(B)}) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      forwardPosition(readElevationOffset());\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth();\n      ${a.output===c.ObjectAndLayerIdColor?D`forwardObjectAndLayerIdColor();`:\"\"}\n      ${k?a.spherical?D`\n                groundNormal = normalize(positionWorld());\n                tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n                tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:D`\n                groundNormal = vec3(0.0, 0.0, 1.0);\n                tbnTangent = vec3(1.0, 0.0, 0.0);\n                tbnBiTangent = vec3(0.0, 1.0, 0.0);`:\"\"}\n      ${H?D`setOverlayVTC(projectOverlay(position));`:\"\"}\n    }\n  `),a.output===c.Alpha&&(I.include(b),i.include(T,a),i.include(y,a),H&&I.uniforms.add(new z(\"ovColorTex\",((e,o)=>P(e,o)))),I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${a.hasMultipassTerrain?D`terrainDepthTest(gl_FragCoord, vPosition_view.z);`:\"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${H?D`\n                vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);\n                materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n\n        gl_FragColor = vec4(materialColor.a);\n      }\n    `)),a.output===c.Color&&(I.include(b),i.include(T,a),i.include(y,a),i.include(f,a),i.include(L,a),a.receiveShadows?(i.include(W,a),I.code.add(D`float evaluateShadow() {\nreturn readShadowMap(vPositionWorldCameraRelative, linearDepth);\n}`)):I.code.add(D`float evaluateShadow() { return 0.0; }`),H&&I.uniforms.add(new z(\"ovColorTex\",((e,o)=>P(e,o)))),I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${a.hasMultipassTerrain?D`terrainDepthTest(gl_FragCoord, vPosition_view.z);`:\"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${H?D`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`:\"\"}\n    `),a.pbrMode===O.Normal||a.pbrMode===O.Schematic?(j(I),I.code.add(D`\n        ${a.pbrMode===O.Normal?D`\n                applyPBRFactors();\n                if (int(externalColorMixMode) == 3) {\n                  mrr = vec3(0.0, 0.6, 0.2);\n                }`:\"\"}\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * mainLightIntensity[2];\n      `),a.hasNormalTexture?I.code.add(D`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\nvec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`):I.code.add(D`vec3 shadingNormal = normalVertex;`),I.code.add(D`${a.spherical?D`vec3 normalGround = normalize(positionWorld());`:D`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}\n      `),I.code.add(D`\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n\n        ${a.snowCover?D`\n                vec3 surfaceNormal = normalize(shadingNormalWorld());\n                float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));\n                materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);\n\n                shadingNormal = mix(shadingNormal, surfaceNormal, snow);\n                ssao = mix(ssao, 0.0, snow);\n                mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);\n                emission = mix(emission, vec3(0.0), snow);`:\"\"}\n\n        ${H?D` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        `)):(a.receiveShadows?I.code.add(D`float shadow = evaluateShadow();`):a.spherical?(M(I),I.code.add(D`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());\nfloat shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`)):I.code.add(D`float shadow = 0.0;`),k&&I.uniforms.add(new z(\"ovNormalTex\",((e,o)=>V(o)))),a.snowCover&&(i.extensions.add(\"GL_OES_standard_derivatives\"),I.code.add(D`vec3 surfaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));\nfloat snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));\nmaterialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)),I.code.add(D`\n        float ambientOcclusion = evaluateAmbientOcclusion();\n        vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n\n        ${H?D` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n\n        vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ${k?D`\n              vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);\n              float waterNormalLength = length(overlayWaterMask);\n              if (waterNormalLength > 0.95) {\n                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());\n                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n                // un-gamma the ground color to mix in linear space\n                shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);\n              }`:\"\"}\n      `)),I.code.add(D`\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n        ${a.transparencyPassType===F.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n      }\n    `)),(a.output===c.Depth||G)&&(i.include(C,a),I.code.add(D`void main() {\ndiscardBySlice(vPositionWorldCameraRelative);\nvec4 textureColor = readBaseColorTexture();\ndiscardOrAdjustAlpha(textureColor);\noutputDepth(linearDepth);\n}`)),a.output===c.Normal&&(i.include(f,a),I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ${a.normalType===g.Ground?\"0.0\":\"1.0\"};\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    `)),a.output===c.ObjectAndLayerIdColor&&i.fragment.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ${H?D`gl_FragColor = getOverlayColorTexel(vtcOverlay);`:\"outputObjectAndLayerIdColor();\"}\n      }\n    `),a.output===c.Highlight&&(i.include(w,a),I.code.add(D`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ${H?D`\n                vec4 overlayColor = getCombinedOverlayColor();\n                if (overlayColor.a == 0.0) {\n                  gl_FragColor = vec4(0.0);\n                  return;\n                }`:\"\"}\n\n        outputHighlight();\n      }\n    `)),i}function V(e){return 0===e.overlays.length?null:e.overlays[a.INNER].getValidTexture(i.Water)}const I=Object.freeze(Object.defineProperty({__proto__:null,build:E,getOverlayNormalTexture:V},Symbol.toStringTag,{value:\"Module\"}));export{I as C,E as b,V as g};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}