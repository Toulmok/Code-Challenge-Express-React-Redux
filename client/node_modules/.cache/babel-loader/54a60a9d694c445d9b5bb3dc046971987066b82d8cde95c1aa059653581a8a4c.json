{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { unpackFloatRGBA as e } from \"../../core/floatRGBA.js\";\nimport has from \"../../core/has.js\";\nimport { disposeMaybe as n, isNone as t } from \"../../core/maybe.js\";\nimport { f as o } from \"../../chunks/vec3f64.js\";\nimport { BufferObject as r } from \"./BufferObject.js\";\nimport { encodeDoubleArray as i } from \"./doublePrecisionUtils.js\";\nimport { TargetType as s, DepthStencilTargetType as a, TextureType as c, TextureWrapMode as u, PixelFormat as l, PixelType as p, TextureSamplingMode as f, Usage as v, DataType as h, PrimitiveType as m } from \"./enums.js\";\nimport { FramebufferObject as d } from \"./FramebufferObject.js\";\nimport { VertexArrayObject as _ } from \"./VertexArrayObject.js\";\nimport { VertexElementDescriptor as A } from \"./VertexElementDescriptor.js\";\nimport { WebGLDriverTestModule as b } from \"./WebGLDriverTestModule.js\";\nclass g extends b {\n  constructor(e) {\n    super(), this._rctx = e, this._program = B(this._rctx, !1), this._obfuscated = B(this._rctx, !0);\n  }\n  dispose() {\n    super.dispose(), this._obfuscated = n(this._obfuscated);\n  }\n  _test(e) {\n    if (has(\"force-double-precision-obfuscation\")) return !0;\n    if (t(this._obfuscated)) return !1;\n    const n = this._runProgram(e),\n      o = this._runProgram(this._obfuscated);\n    return 0 !== n && (0 === o || n / o > 5);\n  }\n  _runProgram(n) {\n    const t = this._rctx;\n    t.resetState();\n    const b = new d(t, {\n        colorTarget: s.TEXTURE,\n        depthStencilTarget: a.NONE\n      }, {\n        target: c.TEXTURE_2D,\n        wrapMode: u.CLAMP_TO_EDGE,\n        pixelFormat: l.RGBA,\n        dataType: p.UNSIGNED_BYTE,\n        samplingMode: f.NEAREST,\n        width: 1,\n        height: 1\n      }),\n      g = r.createVertex(t, v.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])),\n      B = new _(t, new Map([[\"position\", 0]]), {\n        geometry: [new A(\"position\", 2, h.UNSIGNED_SHORT, 0, 4)]\n      }, {\n        geometry: g\n      }),\n      E = o(5633261.287538229, 2626832.878767164, 1434988.0495278358),\n      T = o(5633271.46742708, 2626873.6381334523, 1434963.231608387),\n      F = new Float32Array(6);\n    i(E, F, 3);\n    const O = new Float32Array(6);\n    i(T, O, 3), t.useProgram(n), n.setUniform3f(\"u_highA\", F[0], F[2], F[4]), n.setUniform3f(\"u_lowA\", F[1], F[3], F[5]), n.setUniform3f(\"u_highB\", O[0], O[2], O[4]), n.setUniform3f(\"u_lowB\", O[1], O[3], O[5]), t.bindFramebuffer(b), t.setViewport(0, 0, 1, 1), t.bindVAO(B), t.drawArrays(m.TRIANGLE_STRIP, 0, 4);\n    const U = new Uint8Array(4);\n    b.readPixels(0, 0, 1, 1, l.RGBA, p.UNSIGNED_BYTE, U), B.dispose(!1), g.dispose(), b.dispose();\n    const w = (E[2] - T[2]) / 25,\n      I = e(U);\n    return Math.abs(w - I);\n  }\n}\nfunction B(e, n) {\n  const t = `\\n\\n  precision highp float;\\n\\n  attribute vec2 position;\\n\\n  uniform vec3 u_highA;\\n  uniform vec3 u_lowA;\\n  uniform vec3 u_highB;\\n  uniform vec3 u_lowB;\\n\\n  varying vec4 v_color;\\n\\n  ${n ? \"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION\" : \"\"}\\n\\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\\n\\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\\n  }\\n\\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\\n  }\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = dpPlusFrc(hiA, hiB);\\n    vec3 e = dpMinusFrc(t1, hiA);\\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #else\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = hiA + hiB;\\n    vec3 e = t1 - hiA;\\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #endif\\n\\n  const float MAX_RGBA_FLOAT =\\n    255.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\\n\\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n\\n  vec4 float2rgba(const float value) {\\n    // Make sure value is in the domain we can represent\\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\\n\\n    // Decompose value in 32bit fixed point parts represented as\\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\\n    // by a power of 256 (this removes the bits that are represented in the previous\\n    // component) and then converts the fractional part to 8bits.\\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\\n\\n    // Convert uint8 values (from 0 to 255) to floating point representation for\\n    // the shader\\n    const float toU8AsFloat = 1.0 / 255.0;\\n\\n    return fixedPointU8 * toU8AsFloat;\\n  }\\n\\n  void main() {\\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\\n\\n    v_color = float2rgba(val.z / 25.0);\\n\\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\\n  }\\n  `,\n    o = \"\\n  precision highp float;\\n\\n  varying vec4 v_color;\\n\\n  void main() {\\n    gl_FragColor = v_color;\\n  }\\n  \";\n  return e.programCache.acquire(t, o, new Map([[\"position\", 0]]));\n}\nexport { g as DoublePrecisionRequiresObfuscation };","map":{"version":3,"names":["unpackFloatRGBA","e","has","disposeMaybe","n","isNone","t","f","o","BufferObject","r","encodeDoubleArray","i","TargetType","s","DepthStencilTargetType","a","TextureType","c","TextureWrapMode","u","PixelFormat","l","PixelType","p","TextureSamplingMode","Usage","v","DataType","h","PrimitiveType","m","FramebufferObject","d","VertexArrayObject","_","VertexElementDescriptor","A","WebGLDriverTestModule","b","g","constructor","_rctx","_program","B","_obfuscated","dispose","_test","_runProgram","resetState","colorTarget","TEXTURE","depthStencilTarget","NONE","target","TEXTURE_2D","wrapMode","CLAMP_TO_EDGE","pixelFormat","RGBA","dataType","UNSIGNED_BYTE","samplingMode","NEAREST","width","height","createVertex","STATIC_DRAW","Uint16Array","Map","geometry","UNSIGNED_SHORT","E","T","F","Float32Array","O","useProgram","setUniform3f","bindFramebuffer","setViewport","bindVAO","drawArrays","TRIANGLE_STRIP","U","Uint8Array","readPixels","w","I","Math","abs","programCache","acquire","DoublePrecisionRequiresObfuscation"],"sources":["C:/code-challenge-react/frontend/node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{unpackFloatRGBA as e}from\"../../core/floatRGBA.js\";import has from\"../../core/has.js\";import{disposeMaybe as n,isNone as t}from\"../../core/maybe.js\";import{f as o}from\"../../chunks/vec3f64.js\";import{BufferObject as r}from\"./BufferObject.js\";import{encodeDoubleArray as i}from\"./doublePrecisionUtils.js\";import{TargetType as s,DepthStencilTargetType as a,TextureType as c,TextureWrapMode as u,PixelFormat as l,PixelType as p,TextureSamplingMode as f,Usage as v,DataType as h,PrimitiveType as m}from\"./enums.js\";import{FramebufferObject as d}from\"./FramebufferObject.js\";import{VertexArrayObject as _}from\"./VertexArrayObject.js\";import{VertexElementDescriptor as A}from\"./VertexElementDescriptor.js\";import{WebGLDriverTestModule as b}from\"./WebGLDriverTestModule.js\";class g extends b{constructor(e){super(),this._rctx=e,this._program=B(this._rctx,!1),this._obfuscated=B(this._rctx,!0)}dispose(){super.dispose(),this._obfuscated=n(this._obfuscated)}_test(e){if(has(\"force-double-precision-obfuscation\"))return!0;if(t(this._obfuscated))return!1;const n=this._runProgram(e),o=this._runProgram(this._obfuscated);return 0!==n&&(0===o||n/o>5)}_runProgram(n){const t=this._rctx;t.resetState();const b=new d(t,{colorTarget:s.TEXTURE,depthStencilTarget:a.NONE},{target:c.TEXTURE_2D,wrapMode:u.CLAMP_TO_EDGE,pixelFormat:l.RGBA,dataType:p.UNSIGNED_BYTE,samplingMode:f.NEAREST,width:1,height:1}),g=r.createVertex(t,v.STATIC_DRAW,new Uint16Array([0,0,1,0,0,1,1,1])),B=new _(t,new Map([[\"position\",0]]),{geometry:[new A(\"position\",2,h.UNSIGNED_SHORT,0,4)]},{geometry:g}),E=o(5633261.287538229,2626832.878767164,1434988.0495278358),T=o(5633271.46742708,2626873.6381334523,1434963.231608387),F=new Float32Array(6);i(E,F,3);const O=new Float32Array(6);i(T,O,3),t.useProgram(n),n.setUniform3f(\"u_highA\",F[0],F[2],F[4]),n.setUniform3f(\"u_lowA\",F[1],F[3],F[5]),n.setUniform3f(\"u_highB\",O[0],O[2],O[4]),n.setUniform3f(\"u_lowB\",O[1],O[3],O[5]),t.bindFramebuffer(b),t.setViewport(0,0,1,1),t.bindVAO(B),t.drawArrays(m.TRIANGLE_STRIP,0,4);const U=new Uint8Array(4);b.readPixels(0,0,1,1,l.RGBA,p.UNSIGNED_BYTE,U),B.dispose(!1),g.dispose(),b.dispose();const w=(E[2]-T[2])/25,I=e(U);return Math.abs(w-I)}}function B(e,n){const t=`\\n\\n  precision highp float;\\n\\n  attribute vec2 position;\\n\\n  uniform vec3 u_highA;\\n  uniform vec3 u_lowA;\\n  uniform vec3 u_highB;\\n  uniform vec3 u_lowB;\\n\\n  varying vec4 v_color;\\n\\n  ${n?\"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION\":\"\"}\\n\\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\\n\\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\\n  }\\n\\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\\n  }\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = dpPlusFrc(hiA, hiB);\\n    vec3 e = dpMinusFrc(t1, hiA);\\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #else\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = hiA + hiB;\\n    vec3 e = t1 - hiA;\\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #endif\\n\\n  const float MAX_RGBA_FLOAT =\\n    255.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\\n\\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n\\n  vec4 float2rgba(const float value) {\\n    // Make sure value is in the domain we can represent\\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\\n\\n    // Decompose value in 32bit fixed point parts represented as\\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\\n    // by a power of 256 (this removes the bits that are represented in the previous\\n    // component) and then converts the fractional part to 8bits.\\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\\n\\n    // Convert uint8 values (from 0 to 255) to floating point representation for\\n    // the shader\\n    const float toU8AsFloat = 1.0 / 255.0;\\n\\n    return fixedPointU8 * toU8AsFloat;\\n  }\\n\\n  void main() {\\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\\n\\n    v_color = float2rgba(val.z / 25.0);\\n\\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\\n  }\\n  `,o=\"\\n  precision highp float;\\n\\n  varying vec4 v_color;\\n\\n  void main() {\\n    gl_FragColor = v_color;\\n  }\\n  \";return e.programCache.acquire(t,o,new Map([[\"position\",0]]))}export{g as DoublePrecisionRequiresObfuscation};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}